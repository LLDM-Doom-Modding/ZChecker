//
// Base menu items for CCMD menus.
//

class ZCCommandKeeperItem {
	int argpos;	// For speeding up only. "-1" if not set yet, ">= 0" otherwise.

	String identifier;	// Like "add" for zcsummon or "health" for zcsetprop. In theory may be empty, but in practice omitted identifier will be changed to "#<argpos>" automatically.
	String value;		// Like "3", "z-man" or "18.75". May be empty.
	String prefix;		// Primarily for slider-based values like "x:1.819,y:0.54".

	static ZCCommandKeeperItem Create( String identifier, String value, int argpos = -1 ) {
		ZCCommandKeeperItem newitem = ZCCommandKeeperItem( new( "ZCCommandKeeperItem" ) );

		newitem.identifier = identifier;
		newitem.value = value;
		newitem.argpos = argpos;

		return newitem;
	}
}


class ZCCommandKeeperArg {
	const CVAR_ITEMS_SEPARATOR = ZCHECKER_AGRS_SEPARATOR; 	// Separator between items (between pairs "id:value") in one command.
	const CVAR_IDVAL_SEPARATOR = ":";						// Separator between identifier and its value. Only the leftmost character will be treated as it.
	const DEFAULT_ARG_DELIMITER = ",";
	// So, hypothetical CVar for the "zcsummon" command may be saved as:
	//	"#1:*card:3``#2:1``add:4``fwdofs:23.25``arg0:1``tid:unique``hp:999"

	bool isstatic;		// Must not be changed with CVars etc. For example, command itself ("zcadd").
	String defaultval;	// Default value to use on init. If "isstatic == true", used as an unchangeable string.
	String prefix;		// Prefix for any value (including empty??).
	String delimiter;	// Items delimiter in argument (like comma in line "hp:256,x:54.2,z:floor"). Overrides "DEFAULT_ARG_DELIMITER".

	String linkedCVarName;
	CVar linkedCVar;		// Seems like "transient" modifier not so important in menus processing...
} // of class ZCCommandKeeperArg {}



class ZCCommandDictionaryItems {
	Array<ZCInternalStringDictionaryCell> pairs;

	void Push( String identifier, String value ) {
		pairs.Push( ZCInternalStringDictionaryCell.Create( identifier, value ) );
	}

	ZCInternalStringDictionaryCell Find( String identifier ) {
		for ( int i = 0; i < pairs.Size(); i++ ) {
			if ( pairs[ i ].key == identifier )
				return pairs[ i ];
		}

		return NULL;
	}

	void Clear( void ) {
		pairs.Clear();
	}

	int Size( void ) {
		return pairs.Size();
	}
} // of class ZCCommandDictionaryItems {}



class OptionMenuItemZCCommandKeeper: OptionMenuItem {
	const const_ClassName = "MenuZCKeeperCCMD";

	Array<ZCCommandKeeperArg> args;
	Array<ZCCommandKeeperItem> items;


	//Array<OptionMenuItemZCCommandVisual> visuals; // In theory it may be more than 1, e.g. in the "zcact" menu.
	OptionMenuItemZCCommandVisual visual;


	static OptionMenuItemZCCommandKeeper Get( void ) {
		OptionMenu m = OptionMenu( Menu.GetCurrentMenu() );

		if ( m == NULL )
			return NULL;


		OptionMenuDescriptor mDesc = m.mDesc;
		OptionMenuItemZCCommandKeeper item = NULL;

		for ( int i = 0; i < mDesc.mItems.Size(); i++ ) {
			item = OptionMenuItemZCCommandKeeper( mDesc.mItems[ i ] );

			if ( item )
				break;
		}

		if ( !item ) {
			item = new( "OptionMenuItemZCCommandKeeper" );
			mDesc.mItems.Insert( 0, item );
			ZCGlobal.UILog( LL_APIMessage, item.GetClassName() .. ".Get(). Injected omitted CCMD keeper \"" .. item.GetClassName() .. "\"" );
		}

		return item;
	} // of static OptionMenuItemZCCommandKeeper GetKeeper( void ) {}

	protected bool validateArgIndex( int argindex ) {
		if ( argindex >= args.Size() ) {
			ZCGlobal.UILog( LL_Emergency, const_ClassName .. "::validateArgIndex(). Argument number " .. argindex .. " is too large (args.Size() == " .. args.Size() .. ")." );
			return false;
		}

		if ( args[ argindex ] == NULL ) {
			ZCGlobal.UILog( LL_Emergency, const_ClassName .. "::validateArgIndex(). args[ " .. argindex .. " ] is NULL. Array size " .. args.Size() .. ":" );

			for ( int i = 0; i < args.Size(); i++ )
				ZCGlobal.ClearscopeLog( LL_Main | LL_NoDot, "args[ " .. i .. " ] == " .. ZCGlobal.ObjectName( args[ i ] ) );

			return false;
		}

		return true;
	} // of protected bool checkArgIndex( int argindex ) {}

	ZCCommandKeeperItem FindItem( String identifier, int argindex = -1 ) {
		// Iterate over suitable arg indices:
		if ( argindex >= 0 ) {
			for ( int i = 0; i < items.Size(); i++ ) {
				if ( items[ i ].argpos == argindex && items[ i ].identifier == identifier )
					return items[ i ];
			}
		}

		// Iterate over all items, if arg index was not specified or if it was wrong:
		for ( int i = 0; i < items.Size(); i++ ) {
			if ( items[ i ].identifier == identifier ) {
				items[ i ].argpos = argindex;
				return items[ i ];
			}
		}

		// Item not found:
		return NULL;
	}


	OptionMenuItemZCCommandKeeper Init( int argsamount, String initoptions ) {
		// Initializes once per game engine reload (in contrast to "::OnMenuCreated()").

		// Passed amount of arguments excludes the command itself (actual 0th arg):
		argsamount++;

		for ( int i = 0; i < argsamount; i++ )
			args.Push( new( "ZCCommandKeeperArg" ) );


		// Parsing the options string.
		initoptions.Replace( "\t", " " );

		Array<String> options; // Keeper options are separated with a Space character:
		initoptions.Split( options, " ", TOK_SKIPEMPTY );

		// Examples:
		//  "0 default:zcgive   1 cvar:lldm_zcmenuarg_who   2 cvar:lldm_zcmenuarg_zcgive2   3 cvar:- prefix:item"
		//
		//  "all cvar:lldm_zcmenuarg_zcthinkers   1 cvar:lldm_zcmenuarg_who   2 separator:,"


		int changingArg = -1; // "-1" will init options for all args excluding already set.

		for ( int i = 0; i < options.Size(); i++ ) {
			String curopt = options[ i ];

			bool isOptionWrong = false;
			int temp_IntConversion;

			bool argIsStaticVal = false; // Precedence over all other options.
			String argDefaultVal = "";
			String argPrefix = "";
			String argDelimiter = "";
			String argCVarName = "";


			if ( curopt ~== "all" ) {
				changingArg = -1;

			} else if ( ZCGlobal.str2int_Ptr( curopt, +temp_IntConversion, false ) ) {
				if ( temp_IntConversion >= 0 ) {
					changingArg = temp_IntConversion;
				} else {
					isOptionWrong = true;
				}

			} else {
				int colonindex = curopt.IndexOf( ":" );

				if ( colonindex != -1 ) {
					// Split into parts before colon and after it:
					String curoptname = curopt.Left( colonindex );
					String curoptvalue = curopt.Mid( colonindex + 1, curopt.Length() - colonindex );

					curoptname.ToLower();

					//if ( curoptvalue == "-" )
					//	curoptvalue = ""; // Reset value (for convenience "keyword:-" equals to "keyword:").

					// Check for keywords:
					if ( curoptname == "default" ) {
						argDefaultVal = curoptvalue;
					} else if ( curoptname == "static" || curoptname == "unchangeable" ) {
						argIsStaticVal = true;
						argDefaultVal = curoptvalue;
					} else if ( curoptname == "cvar" ) {
						argCVarName = curoptvalue;
					} else if ( curoptname == "prefix" ) {
						argPrefix = curoptvalue;
					} else if ( curoptname == "separator" || curoptname == "delimiter" ) {
						argDelimiter = curoptvalue;

					} else {
						isOptionWrong = true;
					}

				} else {
					isOptionWrong = true;

				} // of else of if ( colonindex != -1 ) {}


				if ( !isOptionWrong ) {
					int argfirst = ( changingArg < 0? 0 : changingArg );
					int arglast = ( changingArg < 0? argsamount - 1 : changingArg );

					for ( int i = argfirst; i <= arglast; i++ ) {
						ZCCommandKeeperArg arg = args[ i ];
						arg.isstatic = argIsStaticVal;

						if ( arg.defaultval == "" )
							arg.defaultval = argDefaultVal;

						if ( !argIsStaticVal ) {
							if ( arg.delimiter == "" ) {
								if ( argDelimiter != "" )
									arg.delimiter = argDelimiter;
								else
									arg.delimiter = ZCCommandKeeperArg.DEFAULT_ARG_DELIMITER;
							}

							if ( arg.prefix == "" )
								arg.prefix = argPrefix;

							if ( arg.linkedCVarName == "" )
								arg.linkedCVarName = argCVarName;
						} else {
							arg.delimiter = arg.prefix = arg.linkedCVarName = "";
						} // of else of if ( !argIsStaticVal ) {}
					} // of for ( int i = argfirst; i < arglast; i++ ) {}

				} // of if ( !isOptionWrong ) {}


			} // of "curopt" parsing.


			if ( isOptionWrong )
				ZCGlobal.UILog( LL_Main, const_ClassName .. "::Init(). Cannot understand option \"" .. curopt .. "\", skipped." );

		} // of for ( int i = 0; i < options.Size(); i++ ) {}


		for ( int i = 0; i < argsamount; i++ ) {
			ZCCommandKeeperArg arg = args[ i ];

			if ( arg.linkedCVarName != "" ) {
				arg.linkedCVar = CVar.FindCVar( arg.linkedCVarName );

				if ( !arg.linkedCVar )
					ZCGlobal.UILog( LL_Emergency, const_ClassName .. "::Init(). Cannot find CVar \"" .. arg.linkedCVarName .. "\"." );
			}
		} // of for ( int i = 0; i < argsamount; i++ ) {}


		Super.Init( GetClassName(), 'None' );


		if ( ZCGlobal.GetLogLevelClearscope() >= LL_APIMessage ) {
			ZCGlobal.ClearscopeLog( LL_APIMessage, const_ClassName .. "::Init(). " .. args.Size() .. " args:" );

			for ( int i = 0; i < args.Size(); i++ ) {
				ZCCommandKeeperArg arg = args[ i ];

				if ( !arg ) {
					ZCGlobal.ClearscopeLog( LL_APIMessage, "#" .. i .. ". <NULL>" );
					continue;
				}

				ZCGlobal.ClearscopeLog( LL_APIMessage, ( arg.isstatic
							? String.Format( "#%i. Static value \"%s\".", i, arg.defaultval )
							: String.Format( "#%i. Default \"%s\", CVar name \"%s\", delim \"%s\", prefix \"%s\".", i, arg.defaultval, arg.linkedCVarName, arg.delimiter, arg.prefix )
						) );
			}
		} // of if ( ZCGlobal.GetLogLevelClearscope() >= LL_APIMessage ) {}

		return self;
	} // of OptionMenuItemZCCommandKeeper Init( int argsamount, String initoptions ) {}

	override void OnMenuCreated() {
		// Initializes every time when entering menu (in contrast to "::Init()").
		ImportArgCVars();
	}


	void ImportArgCVars( void ) {
		Array<String> savedCVarNames;
		savedCVarNames.Clear(); // "OnMenuCreated()" calls once per at least 2 tics, GC should have time to remove array items...

		// Clearing out previous items:
		items.Clear();


		// Update arg values from linked CVars:
		for ( int curargnum = 0; curargnum < args.Size(); curargnum++ ) {
			ZCCommandKeeperArg arg = args[ curargnum ];

			if ( arg.isstatic || !arg.linkedCVar )
				continue; // Skip static (unchangeable) args and args without linked CVars.


			int curindex = savedCVarNames.Find( arg.linkedCVarName );

			if ( curindex == savedCVarNames.Size() ) {
				// Import new CVar:
				savedCVarNames.Push( arg.linkedCVarName );

				String cvarval = arg.linkedCVar.GetString();

				if ( cvarval == "" && arg.defaultval != "" ) {
					// Set up item with its default value:
					cvarval = arg.defaultval;
				}

				if ( cvarval != "" ) {
					Array<String> importeditems;
					importeditems.Clear();
					cvarval.Split( importeditems, ZCCommandKeeperArg.CVAR_ITEMS_SEPARATOR, TOK_KEEPEMPTY );

					for ( int i = 0; i < importeditems.Size(); i++ ) {
						String itemdata = importeditems[ i ];

						if ( itemdata == "" ) {
							ZCGlobal.UILog( LL_Detailed, LLCOLOR_DARK .. const_ClassName .. "::ImportArgCVars(). Empty arg " .. curargnum .. " itemdata " .. i .. "; maybe data is corrupted." );
							continue; // CVar value is broken.
						}

						// Searching for the first "id:value" separator.
						int colonindex = itemdata.IndexOf( ZCCommandKeeperArg.CVAR_IDVAL_SEPARATOR );

						if ( colonindex == -1 ) {
							// No separator in potential pair "id:value". Or is this a normal situation?..
							ZCGlobal.UILog( LL_Detailed, LLCOLOR_DARK .. const_ClassName .. "::ImportArgCVars(). No value in arg " .. curargnum .. " itemdata " .. i .. " (\"" .. itemdata .. "\"); maybe data is corrupted." );

						} else {
							String identifier = itemdata.Left( colonindex );
							String value = itemdata.Mid( colonindex + 1, itemdata.Length() - colonindex + 2 );

							items.Push( ZCCommandKeeperItem.Create( identifier, value, curargnum ) );
						}
					} // of for ( int i = 0; i < items.Size(); i++ ) {}

					ZCGlobal.UILog( LL_Debug, String.Format(
							"%s::ImportArgCVars(). #%i CVar \"%s%s = %s%s\" splitted into %i items.", const_ClassName,
							curargnum, TEXTCOLOR_DARKGREEN, arg.linkedCVarName, cvarval, LLCOLOR_DEBUG, items.Size()
						) );

				} else {
					ZCGlobal.UILog( LL_Debug, String.Format( "%s::ImportArgCVars(). #%i CVar \"%s\" is empty.", const_ClassName, curargnum, arg.linkedCVarName ) );
					continue; // CVar has no id:value pairs at all.

				} // of else of if ( cvarval != "" ) {}

			} // of if ( curindex == savedCVarNames.Size() ) {}

		} // of for ( int curargnum = 0; curargnum < args.Size(); curargnum++ ) {}

	} // void ImportArgCVars( void ) {}


	void ExportArgCVar( int argindex ) {
		if ( !validateArgIndex( argindex ) ) {
			ZCGlobal.UILog( LL_Main, const_ClassName .. "::ExportArgCVar( " .. argindex .. " ) failed." );
			return;
		}

		ZCCommandKeeperArg outputarg = args[ argindex ];

		if ( outputarg.linkedCVar == NULL )
			return;


		String outstr = "";

		for ( int i = 0; i < items.Size(); i++ ) {
			ZCCommandKeeperItem item = items[ i ];

			if ( item.argpos < 0 )
				continue; // Item is not from this command.

			if ( args[ item.argpos ].linkedCVar == outputarg.linkedCVar ) {
				if ( item.value != "" ) {
					outstr.AppendFormat( "%s%s%s%s",
							item.identifier, ZCCommandKeeperArg.CVAR_IDVAL_SEPARATOR,
							item.value, ZCCommandKeeperArg.CVAR_ITEMS_SEPARATOR
						);
				}
			}
		} // of for ( int i = 0; i < items.Size(); i++ ) {}


		// Removing excess separators:
		if ( outstr.Length() > 0 ) {
			int separatorlen = ZCCommandKeeperArg.CVAR_ITEMS_SEPARATOR.Length();

			outstr = outstr.Left( outstr.Length() - separatorlen );
		}


		ZCGlobal.UILog( LL_Debug, String.Format(
				"%s::ExportArgCVar(). #%-2i CVar \"%s%s = %s%s\".", const_ClassName,
				argindex, TEXTCOLOR_DARKBROWN, outputarg.linkedCVarName, outstr, LLCOLOR_DEBUG
			) );

		int limitCVarLength = 254 - outputarg.linkedCVarName.Length();

		if ( outstr.Length() > limitCVarLength ) {
			ZCGlobal.ClearscopeLog( LL_Emergency, const_ClassName .. "::ExportArgCVar(). Too long user CVar value, got " .. outstr.Length() .. " characters (ZDoom limit for this variable is " .. TEXTCOLOR_RED .. limitCVarLength .. LLCOLOR_EMERGENCY .. "). Value not changed." );
			ZCGlobal.ClearscopeLog( LL_Main, "CVar \"" .. LLCOLOR_WARNING .. outputarg.linkedCVarName .. " = " .. outstr .. LLCOLOR_MAIN .. "\"." );
		} else {
			outputarg.linkedCVar.SetString( outstr );
		}
	} // of void ExportArgCVar( int argindex ) {}


	void SetString( int argindex, String identifier, String value ) {
		if ( !validateArgIndex( argindex ) ) {
			ZCGlobal.UILog( LL_Avary, String.Format( "%s::SetString( %i, \"%s\", \"%s\" ) failed.", const_ClassName, argindex, identifier, value ) );
			return;
		}

		if ( args[ argindex ].isstatic ) {
			ZCGlobal.UILog( LL_Main, const_ClassName .. "::SetString(). Cannot set value to static arg " .. argindex .. " (\"" .. args[ argindex ].defaultval .. "\")." );
			return;
		}

		ZCCommandKeeperItem item = FindItem( identifier, argindex );

		if ( item ) {
			// Use previously defined item:
			item.value = value;
			ZCGlobal.UILog( LL_Debug, String.Format( "%s::SetString(). Set pair \"%s:%s\"", const_ClassName, identifier, value ) );

		} else {
			// Create new item:
			items.Push( ZCCommandKeeperItem.Create( identifier, value, argindex ) );
			ZCGlobal.UILog( LL_Debug, String.Format( "%s::SetString(). New pair \"%s:%s\"", const_ClassName, identifier, value ) );

			//ZCGlobal.UILog( LL_Main, const_ClassName .. "::SetString(). Identifier \"" .. identifier .. "\" for index " .. argindex .. " not found; passed value \"" .. value .. "\" dropped." );
		}

		ExportArgCVar( argindex );
		UpdateVisual();
	} // of void SetString( int arg, String identifier, String value ) {}

	String GetString( int argindex, String identifier ) {
		if ( !validateArgIndex( argindex ) ) {
			ZCGlobal.UILog( LL_Avary, String.Format( "%s::GetString( %i, \"%s\" ) failed.", const_ClassName, argindex, identifier ) );
			return "";
		}

		ZCCommandKeeperItem item = FindItem( identifier, argindex );

		if ( item )
			ZCGlobal.UILog( LL_Debug, String.Format( "%s::GetString(). Got pair \"%s:%s\"", const_ClassName, identifier, item.value ) );

		/*
		ZCGlobal.UILog( LL_Debug, ( item
				? String.Format( "%s::GetString(). Got pair \"%s:%s\"", const_ClassName, identifier, item.value )
				: String.Format( "%s::GetString(). Got empty \"%s\"", const_ClassName, identifier )
			) );
		*/

		return ( item? item.value: "" );
	} // of String GetString( int argindex, String identifier ) {}


	void SetFloat( int argindex, String identifier, double value ) {
		SetString( argindex, identifier, "" .. value );
	}

	double GetFloat( int argindex, String identifier ) {
		return GetString( argindex, identifier ).ToDouble();
	}



	virtual protected void UpdateVisual( void ) {
		if ( !visual && !( visual = OptionMenuItemZCCommandVisual.Get() ) ) {
			ZCGlobal.UILog( LL_Emergency, const_ClassName .. "::UpdateVisual(). Cannot find \"OptionMenuItemZCCommandVisual\" class." );
			return;
		}

		visual.Update( GetVisualCommand() );
	}


	// Returns a final command to execute.
	// By default forms a string from "args[]" and "items[]".
	virtual String GetExecCommand() {
		Array<String> argsstr;
		argsstr.Clear();

		if ( args.Size() < 0 )
			return "";

		// Init:
		for ( int i = 0; i < args.Size(); i++ ) {
			if ( args[ i ].isstatic )
				argsstr.Push( args[ i ].defaultval );
			else
				argsstr.Push( args[ i ].prefix );
		}


		// Attach all saved items to appropriate args:
		for ( int i = 0; i < items.Size(); i++ ) {
			ZCCommandKeeperItem item = items[ i ];
			int argpos = item.argpos;

			if ( argpos < 0 )
				continue; // Item is not from this command.


			ZCCommandKeeperArg arg = args[ argpos ];

			if ( argsstr[ argpos ] != "" )
				argsstr[ argpos ].AppendFormat( arg.delimiter );

			argsstr[ argpos ].AppendFormat( "%s%s", item.prefix, item.value );
		}


		// Concatenate all args into one large string:
		String outstr = argsstr[ 0 ];

		for ( int i = 1; i < argsstr.Size(); i++ ) {
			if ( argsstr[ i ] != "" )
				outstr.AppendFormat( " %s", argsstr[ i ] );
		}

		return outstr;
	} // of virtual String GetExecCommand() {}

	virtual String GetVisualCommand() {
		return GetExecCommand();
	}

} // of class OptionMenuItemZCCommandKeeper: OptionMenuItem {}



class OptionMenuItemZCCommandVisual: OptionMenuItemStaticText {
	bool firsttic;

	static OptionMenuItemZCCommandVisual Get( void ) {
		OptionMenu m = OptionMenu( Menu.GetCurrentMenu() );

		if ( m == NULL )
			return NULL;

		for ( int i = 0; i < m.mDesc.mItems.Size(); i++ ) {
			if ( m.mDesc.mItems[ i ].GetClass() == "OptionMenuItemZCCommandVisual" )
				return OptionMenuItemZCCommandVisual( m.mDesc.mItems[ i ] );
		}

		return NULL;
	} // of static OptionMenuItemZCCommandVisual Get( void ) {}

	OptionMenuItemZCCommandVisual Init( String label ) {
		Super.Init( "\x1E" ); // At least LZDoom 3.87 and next versions wipes out empty OptionMenuItemStaticText.
		return self;
	}

	void Update( String newtext ) {
		mLabel = newtext;
	}


	// Compelled methods overriding, force updating on the first draw tic:
	override void OnMenuCreated() {
		firsttic = true;
	}

	override int Draw( OptionMenuDescriptor desc, int y, int indent, bool selected ) {
		if ( firsttic ) {
			Update( OptionMenuItemZCCommandKeeper.Get().GetVisualCommand() );
			firsttic = false;
		}

		return Super.Draw( desc, y, indent, selected );
	}
} // of class OptionMenuItemZCCommandVisual: OptionMenuItemStaticText {}



class OptionMenuItemZCCommandExecute: OptionMenuItemCommand {
	OptionMenuItemZCCommandKeeper keeper;

	OptionMenuItemZCCommandExecute Init( String label, String command ) {
		let newitem = OptionMenuItemZCCommandExecute( Super.Init( label, command ) );

		return newitem;
	}

	override bool Activate() {
		if ( !keeper )
			keeper = OptionMenuItemZCCommandKeeper.Get();


		Init( mLabel, keeper.GetExecCommand() );

		return Super.Activate();
	}
} // of class OptionMenuItemZCCommandExecute: OptionMenuItemCommand {}



class OptionMenuItemZCCommandOption: OptionMenuItemOptionBase {
	OptionMenuItemZCCommandKeeper keeper;

	int mArgIndex;
	String mIdentifier;			// Default "mAction" automatically converts empty String to the Name 'None'.
	String mPrefix;				// What to add before a value.
	//String mRemovingValue;		// Treat this value as an empty parameter.

	private bool updateSelection;
	private int prevSelection;

	OptionMenuItemZCCommandOption Init( String label, int argindex, String identifier, Name values, String prefix = "" ) {
		updateSelection = true;
		prevSelection = -1;

		if ( identifier == "" ) {
			// Automatic index:
			identifier = "#" .. argindex;

		} else if ( ZCGlobal.StringIndexOfAny( identifier, ZCCommandKeeperArg.CVAR_IDVAL_SEPARATOR .. ZCCommandKeeperArg.CVAR_ITEMS_SEPARATOR ) != -1 ) {
			// Replace danger name:
			ZCGlobal.UILog( LL_Main,
					String.Format( "%s::Init(). Identifier \"%s\" has forbidden control characters (\"%s\" and \"%s\"). They has been removed from the string.",
							GetClassName(), identifier,
							ZCCommandKeeperArg.CVAR_IDVAL_SEPARATOR, ZCCommandKeeperArg.CVAR_ITEMS_SEPARATOR
					)
			);

			identifier.Replace( ZCCommandKeeperArg.CVAR_IDVAL_SEPARATOR, "" );
			identifier.Replace( ZCCommandKeeperArg.CVAR_ITEMS_SEPARATOR, "" );
		}


		mPrefix = prefix;
		mArgIndex = argindex;
		mIdentifier = identifier;

		// Examples: "",  "rel",  "rel:",  "rel:2",  "rel:s",  "rel:linetarget".


		Super.Init( label, identifier, values, NULL, 0 );

		return self;
	} // of OptionMenuItemZCCommandOption Init( String label, int argindex, String identifier, Name values, String prefix = "" ) {}

	override bool MenuEvent( int mkey, bool fromcontroller ) {
		if ( mkey == Menu.MKEY_Left || mkey == Menu.MKEY_Right || mkey == Menu.MKEY_Enter )
			updateSelection = true;

		return Super.MenuEvent( mkey, fromcontroller );
	}

	override void OnMenuCreated() {
		updateSelection = true;
	}


	// Copied and modified from "class OptionMenuItemOption".
	override int GetSelection() {
		int Selection = -1;
		int cnt = OptionValues.GetCount( mValues );

		if ( !keeper )
			keeper = OptionMenuItemZCCommandKeeper.Get();

		if ( !updateSelection )
			return prevSelection; // Return a "cached" selection.


		updateSelection = false;

		if ( cnt > 0 ) {
			// The keeper can contain only string values.
			String cv = keeper.GetString( mArgIndex, mIdentifier );

			bool success = false;

			for ( int i = 0; i < cnt; i++ ) {
				if ( cv ~== OptionValues.GetTextValue( mValues, i ) ) {
					prevSelection = selection = i;
					success = true;
					break;
				}
			}

			// TODO: might be a normal situation, by the way.
			if ( !success )
				ZCGlobal.UILog( LL_Main, GetClassName() .. "::GetSelection(). Unknown value \"" .. LLCOLOR_WARNING .. cv .. LLCOLOR_NORMAL .. "\"." );
		} // of if ( cnt > 0 ) {}

		return selection;
	}

	override void SetSelection( int Selection ) {
		if ( !keeper )
			keeper = OptionMenuItemZCCommandKeeper.Get();

		if ( OptionValues.GetCount( mValues ) > 0 ) {
			// Must be transferred:
			//	Arg index and item identifier;
			//	Value.
			keeper.SetString( mArgIndex, mIdentifier, OptionValues.GetTextValue( mValues, Selection ) );
			updateSelection = true;
		}
	}
} // of class OptionMenuItemZCCommandOption: OptionMenuItemOptionBase {}


