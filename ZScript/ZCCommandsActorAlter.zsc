class ZCSetStateCommand: ZCConsoleCommand {
	int zcPos;
	String newState;

	override String GetCommand() {
		return "zc_setState";
	}

	override String GetHelpNameString() {
		return "zcsets [<pos>] <state label>;zcsetstate [<pos>] <state label>";
	}

	override String GetHelpDescString() {
		return "set a testee in <pos> (or actor on line of sight if omitted) state to <state label>. Info: because of asynchronous ZScript/ACS execution result will be delayed for one tick.";
	}

	override bool HandleArguments( ZCheckerCCMDInfo initCCMD ) {
		ccmd = initCCMD;
		zcPos = -1;
		bool outValue = false;

		if ( ccmd.args.Size() == 1 ) {
			newState = ccmd.args[ 0 ];
			outValue = true;
		} else if ( ccmd.args.Size() == 2 && str2int_Ptr( ccmd.args[ 0 ], +zcPos ) ) {
			newState = ccmd.args[ 1 ];
			outValue = checkTesteePlace( --zcPos );
		}

		return outValue;
	}

	// I have no idea how to convert String to StateLabel less crooked...
	override void DoCommand( void ) {
		// Linetarget if position is omitted or testee[pos] otherwise:
		Actor testee = ( zcPos == -1 )? LinetraceActor( players[ ccmd.e.Player ].mo ) : ccmd.handler.Testee[ zcPos ].mo;

		if ( testee ) {
			// Cannot get ACS asynchronous "SetResultValue()" here.
			testee.ACS_NamedExecute( "ZChecker_CCMD_SetState", 0 );
		}
	}

	static String ACS_GetStateName( Actor activator ) {
		ZCSetStateCommand it = ZCSetStateCommand( ThinkerIterator.Create( "ZCSetStateCommand", STAT_STATIC ).Next() );

		return ( it )? it.newState : "";
	}
} // of class ZCSetStateCommand: ZCConsoleCommand {


class ZCBuddhaCommand: ZCConsoleCommand {
	int zcPos;
	int flagSetType;

	override String GetCommand() {
		return "zc_buddha";
	}

	override String GetHelpNameString() {
		return "zcbuddha <pos> [<set>];zcbud <pos> [<set>]";
	}

	override String GetHelpDescString() {
		return "operates on the BUDDHA flag at <pos> or linetarget, if omitted. If <set> is omitted, toggles it, or sets/resets ('0'/'1') otherwise.";
	}

	override bool HandleArguments( ZCheckerCCMDInfo initCCMD ) {
		ccmd = initCCMD;
		zcPos = -1;
		flagSetType = -1;
		int ccmdArgsSize = ccmd.args.Size();
		bool outValue = ( ccmdArgsSize == 0 );

		if ( !outValue && str2int_Ptr( ccmd.args[ 0 ], +zcPos ) ) {
			if ( ccmdArgsSize == 1 )
				outValue = checkTesteePlace( --zcPos );
			else if ( ccmdArgsSize == 2 && ( (flagSetType = getBoolArg( 1 )) != -1 ) )
				outValue = checkTesteePlace( --zcPos );
		}

		// One arg is a position (flag will be toggled), two args are a 
		//position and a flag value:
		//if ( ccmdArgsSize > 0 && ccmdArgsSize < 3 && str2int_Ptr( ccmd.args[ 0 ], +zcPos ) && ( ( ccmdArgsSize != 2 ) || str2int_Ptr( ccmd.args[ 1 ], +flagValue ) ) )
		//	outValue = checkTesteePlace( --zcPos );

		return outValue;
	}

	override void DoCommand( void ) {
		// Linetarget if position is omitted or testee[pos] otherwise:
		Actor testee = ( zcPos == -1 )? LinetraceActor( players[ ccmd.e.Player ].mo ) : ccmd.handler.Testee[ zcPos ].mo;

		if ( testee ) {
			if ( flagSetType == -1 )
				testee.bBuddha ^= true;
			else
				testee.bBuddha = flagSetType;
		}
	}
} // of class ZCBudCommand: ZCConsoleCommand {

class ZCToggleFlagCommand: ZCConsoleCommand {
	int zcPos;
	String flagName;
	int flagSetType;

	override String GetCommand() {
		return "zc_toggleFlag";
	}

	override String GetHelpNameString() {
		return "zctf [<pos>] <flag name> [<value: 0/false/reset or 1/true/set>];zctoggleflag [<pos>] <flag name> [<value>]";
	}

	override String GetHelpDescString() {
		return "toggle or set/reset a flag for the testee in <pos> (or actor on line of sight if omitted). Info: because of asynchronous ZScript/ACS execution result will be delayed for one tick.";
	}

	override bool HandleArguments( ZCheckerCCMDInfo initCCMD ) {
		ccmd = initCCMD;
		zcPos = -1;
		flagSetType = -1;
		bool outValue = false;

		if ( ccmd.args.Size() == 2 || ccmd.args.Size() == 3 )
			flagSetType = getBoolArg( ccmd.args.Size() - 1 );

		if ( ccmd.args.Size() == 1 ) {
			flagName = ccmd.args[ 0 ];
			outValue = true;
		} else if ( ccmd.args.Size() == 2 ) {
			if ( flagSetType != -1 ) {
				flagName = ccmd.args[ 0 ];
				outValue = true;
			} else if ( str2int_Ptr( ccmd.args[ 0 ], +zcPos ) ) {
				outValue = checkTesteePlace( --zcPos );
				flagName = ccmd.args[ 1 ];
			}
		} else if ( ( ccmd.args.Size() == 3 ) && str2int_Ptr( ccmd.args[ 0 ], +zcPos ) ) {
			flagName = ccmd.args[ 1 ];
			outValue = checkTesteePlace( --zcPos ) && ( flagSetType != -1 );
		}

		//console.printf( "zcPos: " .. zcPos .. ", flagName: " .. flagName .. ", flagSetType: " .. flagSetType .. ".  outValue: " .. outValue );

		return outValue;
	}

	// I have no idea how to convert String to flag name less crooked, too...
	override void DoCommand( void ) {
		// Linetarget if position is omitted or testee[pos] otherwise:
		Actor testee = ( zcPos == -1 )? LinetraceActor( players[ ccmd.e.Player ].mo ) : ccmd.handler.Testee[ zcPos ].mo;

		if ( testee ) {
			// Cannot get ACS asynchronous "SetResultValue()" here.
			testee.ACS_NamedExecute( "ZChecker_CCMD_SetFlag", 0, flagSetType );
		}
	}

	static String ACS_GetFlagName( Actor activator ) {
		ZCToggleFlagCommand it = ZCToggleFlagCommand( ThinkerIterator.Create( "ZCToggleFlagCommand", STAT_STATIC ).Next() );

		return ( it )? it.flagName : "";
	}
} // of class ZCSetStateCommand: ZCConsoleCommand {

class ZCGiveCommand: ZCConsoleCommand {
	int zcPos;
	String itemName;
	int itemAmount;

	override String GetCommand() {
		return "zc_give";
	}

	override String GetHelpNameString() {
		return "zcgive [<pos>] <item> [<amount=1>]";
	}

	override String GetHelpDescString() {
		return "give <amount> <item>s to the testee <pos> (or linetarget if omitted)";
	}

	override bool HandleArguments( ZCheckerCCMDInfo initCCMD ) {
		ccmd = initCCMD;
		zcPos = -1;
		itemAmount = 1;
		itemName = "";
		bool outValue = false;

		if ( ccmd.args.Size() == 2 || ccmd.args.Size() == 3 )
			if ( !str2int_Ptr( ccmd.args[ ccmd.args.Size() - 1 ], +itemAmount ) )
				itemAmount = -1;

		if ( ccmd.args.Size() == 1 ) {
			itemName = ccmd.args[ 0 ];
			outValue = true;
		} else if ( ccmd.args.Size() == 2 ) {
			if ( itemAmount != -1 ) {
				itemName = ccmd.args[ 0 ];
				outValue = true;
			} else if ( str2int_Ptr( ccmd.args[ 0 ], +zcPos ) ) {
				itemAmount = 1;
				outValue = checkTesteePlace( --zcPos );
				itemName = ccmd.args[ 1 ];
			}
		} else if ( ( ccmd.args.Size() == 3 ) && str2int_Ptr( ccmd.args[ 0 ], +zcPos ) ) {
			itemName = ccmd.args[ 1 ];
			outValue = checkTesteePlace( --zcPos );
		}

		return outValue && ( itemAmount != -1 );
	}

	override void DoCommand( void ) {
		// Linetarget if position is omitted or testee[pos] otherwise:
		Actor testee = ( zcPos == -1 )? LinetraceActor( players[ ccmd.e.Player ].mo ) : ccmd.handler.Testee[ zcPos ].mo;

		if ( testee ) {
			class<Actor> itemClass = itemName;

			if ( itemClass is 'Inventory' ) {
				if ( testee.A_GiveInventory( itemName, itemAmount ) )
					ZCGlobal.Log( LL_Detailed, "Item \"" .. itemClass.GetClassName() .. "\" given to the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
				else
					ZCGlobal.Log( LL_Main, "Actor " .. testee.GetClassName() .. " cannot receive item." );
			} else {
				ZCGlobal.Log( LL_Main, "\"" .. itemName .. "\" isn't an inventory actor." );
			}
		} // of if ( testee ) {

	}
} // of class ZCGiveCommand: ZCConsoleCommand {

class ZCTakeCommand: ZCGiveCommand {
	override String GetCommand() {
		return "zc_take";
	}

	override String GetHelpNameString() {
		return "zctake [<pos>] <item> [<amount=1>]";
	}

	override String GetHelpDescString() {
		return "take <amount> <item>s from the testee <pos> (or linetarget if omitted)";
	}

	override void DoCommand( void ) {
		// Linetarget if position is omitted or testee[pos] otherwise:
		Actor testee = ( zcPos == -1 )? LinetraceActor( players[ ccmd.e.Player ].mo ) : ccmd.handler.Testee[ zcPos ].mo;

		if ( testee ) {
			class<Actor> itemClass = itemName;

			if ( itemClass is 'Inventory' ) {
				if ( testee.A_TakeInventory( itemName, itemAmount ) ) {
					/*if ( !GetDefaultByType( itemClass ).bKEEPDEPLETED ) {
						ZCGlobal.Log( LL_Detailed, "DESTROY Item \"" .. itemClass.GetClassName() .. "\" taken from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
						Inventory inv = testee.FindInventory( itemName );
						inv.Destroy();
					}*/
					Inventory inv = testee.FindInventory( itemName );

					if ( inv && inv.amount == 0 )
						inv.Destroy();

					ZCGlobal.Log( LL_Detailed, "Item \"" .. itemClass.GetClassName() .. "\" taken from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );

					/*if ( inv && !inv.bKEEPDEPLETED ) {
						ZCGlobal.Log( LL_Detailed, "Item \"" .. itemClass.GetClassName() .. "\" destroyed from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
						inv.Destroy();
					} else if ( inv ) {
						ZCGlobal.Log( LL_Detailed, "Item \"" .. itemClass.GetClassName() .. "\" taken from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
					}*/
				} else {
					ZCGlobal.Log( LL_Main, "Cannot take item from actor " .. testee.GetClassName() .. "." );
				}
			} else {
				ZCGlobal.Log( LL_Main, "\"" .. itemName .. "\" isn't an inventory actor." );
			}
		} // of if ( testee ) {

	}
} // of class ZCTakeCommand: ZCGiveCommand {

class ZCActorActionCommand: ZCConsoleCommand {
	enum EActorActions {
		AC_Wrong = 0,
		AC_Revive,
		AC_Kill,
		AC_Destroy
	};

	int zcPos;
	EActorActions actoraction;

	override String GetCommand() {
		return "zc_actoraction";
	}

	override String GetHelpNameString() {
		return "zcact [<pos>] <action>";
	}

	override String GetHelpDescString() {
		return "Does something with actor on <pos> (or linetarget if omitted). Possible values: \"revive\"|\"resurrect\", \"kill\", \"destroy\"|\"remove\"";
	}

	override bool HandleArguments( ZCheckerCCMDInfo initCCMD ) {
		ccmd = initCCMD;
		zcPos = -1;
		bool outValue = false;

		if ( ccmd.args.Size() == 1 || ccmd.args.Size() == 2 ) {
			outValue = true;
			String what = ccmd.args[ ccmd.args.Size() - 1 ];

			if ( what == "resurrect" || what == "revive" )
				actoraction = AC_Revive;
			else if ( what == "kill" )
				actoraction = AC_Kill;
			else if ( what == "destroy" || what == "remove" )
				actoraction = AC_Destroy;
			else
				outValue = false;

			if ( outValue ) {
				outValue = false;

				if ( ccmd.args.Size() == 1 )
					outValue = true;
				else if ( str2int_Ptr( ccmd.args[ 0 ], +zcPos ) )
					outValue = checkTesteePlace( --zcPos );
			} // of if ( outValue ) {}

		}

		return outValue;
	}

	protected void TryRevive( Actor testee ) {
		bool reviveBlocked = false;
		readonly<Actor> defactor = GetDefaultByType( testee.GetClass() );

		if ( defactor.bSOLID || defactor.bBLOCKEDBYSOLIDACTORS ) {
			BlockThingsIterator it = BlockThingsIterator.CreateFromPos( testee.pos.x, testee.pos.y, testee.pos.z, testee.height, testee.radius, false );

			while ( it.Next() && !reviveBlocked ) {
				if ( it.thing != testee && testee.Distance2D( it.thing ) < testee.radius && it.thing.bSOLID )
					reviveBlocked = true;
			}
		}


		if ( !reviveBlocked ) {
			ZCGlobal.Log( LL_Detailed, "Revived actor " .. testee.GetClassName() );

			// Compatibility with older versions.
			Actor prevMaster = testee.master;
			testee.master = testee;
			testee.A_RaiseMaster();
			testee.master = prevMaster;
		} else {
			ZCGlobal.Log( LL_Detailed, "Actor " .. testee.GetClassName() .. " reviving " .. TEXTCOLOR_RED .. "blocked\c-." );
		}
	}

	override void DoCommand( void ) {
		// Linetarget if position is omitted or testee[ pos ] otherwise:
		Actor testee = ( ( zcPos == -1 )? LinetraceActor( players[ ccmd.e.Player ].mo ) : ccmd.handler.Testee[ zcPos ].mo );

		if ( testee ) {
			switch ( actoraction ) {
			case AC_Revive:
				TryRevive( testee );
				break;
			case AC_Kill:
				ZCGlobal.Log( LL_Detailed, "Killed actor " .. testee.GetClassName() );
				testee.A_Die();
				break;
			case AC_Destroy:
				ZCGlobal.Log( LL_Detailed, "Destroyed actor " .. testee.GetClassName() );
				testee.Destroy();
				break;
			default:
				ZCGlobal.Log( LL_Emergency, "Unknown action id \"" .. actoraction .. "\" for testee " .. testee.GetClassName() );
				break;
			}
		} // of if ( testee ) {

	}
} // of class ZCActorActionCommand: ZCConsoleCommand {}
