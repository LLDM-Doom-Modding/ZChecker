//
// All CCMDs which alters or creates an actor.
//

class ZCGiveCommand: ZCConsoleCommand {
	Actor testee;
	EPositionParseStatus testeeStatus;
	String itemName;
	int itemAmount;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_give",
			"$ZCGIVE_HELP_TITLE",
			"$ZCGIVE_HELP_DESC",
			'ZCTooltipGiveCommand'
		);
	}

	override bool HandleArguments() {
		testeeStatus = PPS_Error;
		itemAmount = 1;
		itemName = "";

		bool outValue = false;
		int ccmdArgsSize = ccmd.args.Size();

		if ( ccmdArgsSize == 2 || ccmdArgsSize == 3 )
			if ( !str2int_Ptr( ccmd.args[ ccmdArgsSize - 1 ], +itemAmount ) )
				itemAmount = -1;

		if ( ccmdArgsSize == 1 ) {
			itemName = ccmd.args[ 0 ];
			testee = LinetraceActor();
			outValue = true;

		} else if ( ccmdArgsSize == 2 ) {
			if ( itemAmount != -1 ) {
				itemName = ccmd.args[ 0 ];
				outValue = true;
				testee = LinetraceActor();
			} else if ( PPS_Error != ( testeeStatus = ParsePositionString( testee ) ) ) {
				itemAmount = 1;
				itemName = ccmd.args[ 1 ];
				outValue = true;
			}

		} else if ( ( ccmd.args.Size() == 3 ) && PPS_Error != ( testeeStatus = ParsePositionString( testee ) ) ) {
			itemName = ccmd.args[ 1 ];
			outValue = true;
		}

		if ( outValue )
			itemName = ParseSpecialActorName( itemName, "Inventory" );

		return outValue && ( itemAmount != -1 );
	}

	override void DoCommand( void ) {
		if ( classnameParseStatus == CPS_RegexFailed )
			return;

		if ( testee ) {
			class<Actor> itemClass = itemName;

			if ( itemClass is 'Inventory' ) {
				if ( testee.A_GiveInventory( itemName, itemAmount ) )
					ZCGlobal.Log( LL_Detailed, String.Format( ZCGlobal.Locz( "ZCGIVE_SUCCESS" ), itemClass.GetClassName(), testee.GetClassName() ) );
				else
					LogLocalize2Str( LL_Main, "ZCGIVE_CANNOTRECEIVE", testee.GetClassName() );
			} else {
				LogLocalize2Str( LL_Main, "ZCGIVE_NOTINVCLASS", itemName );
			}
		} // of if ( testee ) {}

	}
} // of class ZCGiveCommand: ZCConsoleCommand {}

class ZCTakeCommand: ZCGiveCommand {
	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_take",
			"$ZCTAKE_HELP_TITLE",
			"$ZCTAKE_HELP_DESC",
			'ZCTooltipTakeCommand'
		);
	}

	override void DoCommand( void ) {
		if ( classnameParseStatus == CPS_RegexFailed )
			return;

		if ( testee ) {
			class<Actor> itemClass = itemName;

			if ( itemClass is 'Inventory' ) {
				if ( testee.A_TakeInventory( itemName, itemAmount ) ) {
					/*if ( !GetDefaultByType( itemClass ).bKEEPDEPLETED ) {
						ZCGlobal.Log( LL_Detailed, "DESTROY Item \"" .. itemClass.GetClassName() .. "\" taken from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
						Inventory inv = testee.FindInventory( itemName );
						inv.Destroy();
					}*/

					Inventory inv = testee.FindInventory( itemName );

					if ( inv && inv.amount == 0 && !inv.bKEEPDEPLETED )
						inv.Destroy();

					ZCGlobal.Log( LL_Detailed, String.Format( ZCGlobal.Locz( "ZCTAKE_SUCCESS" ), itemClass.GetClassName(), testee.GetClassName() ) );

					/*if ( inv && !inv.bKEEPDEPLETED ) {
						ZCGlobal.Log( LL_Detailed, "Item \"" .. itemClass.GetClassName() .. "\" destroyed from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
						inv.Destroy();
					} else if ( inv ) {
						ZCGlobal.Log( LL_Detailed, "Item \"" .. itemClass.GetClassName() .. "\" taken from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
					}*/
				} else {
					LogLocalize2Str( LL_Main, "ZCTAKE_CANNOTRECEIVE", testee.GetClassName() );
				}

			} else {
				LogLocalize2Str( LL_Main, "ZCTAKE_NOTINVCLASS", itemName );
			}
		} // of if ( testee ) {}
	} // of override void DoCommand( void ) {}

} // of class ZCTakeCommand: ZCGiveCommand {}

class ZCActorActionCommand: ZCConsoleCommand {
	enum EActorActions {
		AC_Error = 0,
		AC_Revive,
		AC_Kill,
		AC_Destroy,
		AC_XKill,
		AC_Stop,		// "vel = (0, 0, 0);"
		AC_TicsFreeze,	// "tics = -1;"
		AC_TicsSkip,	// "tics = 0;"
		AC_TicsRevert,	// "tics = CurState.tics;"
	};

	Actor thing;
	EPositionParseStatus testeeStatus;
	EActorActions actoraction;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_actoraction",
			"$ZCACT_HELP_TITLE",
			"$ZCACT_HELP_DESC",
			'ZCTooltipActorActionCommand',
			"act; action"
		);
	}

	override bool HandleArguments() {
		testeeStatus = PPS_Error;
		bool outValue = false;

		int ccmdArgsSize = ccmd.args.Size();

		if ( ccmdArgsSize == 1 || ccmdArgsSize == 2 ) {
			outValue = true;
			String what = ccmd.args[ ccmdArgsSize - 1 ];

			what.ToLower();
			String whatLeft3 = what.Left( 3 );

			if ( whatLeft3 == "rem" || what == "rm" || whatLeft3 == "del" || ZCGlobal.StrStartsWith( what, "destr" ) )
				actoraction = AC_Destroy;
			else if ( what == "kill" || what == "k" || what == "die" )
				actoraction = AC_Kill;
			else if ( what == "xk" || what == "xkill" || what == "mdk" )
				actoraction = AC_XKill;
			else if ( ZCGlobal.StrEndsWith( what, "revert" ) || ZCGlobal.StrStartsWith( what, "revert" ) )
				actoraction = AC_TicsRevert;
			else if ( whatLeft3 == "res" || whatLeft3 == "rev" )
				actoraction = AC_Revive;
			else if ( what == "stop" )
				actoraction = AC_Stop;
			else if ( ZCGlobal.StrEndsWith( what, "freeze" ) || ZCGlobal.StrStartsWith( what, "freeze" ) || ZCGlobal.StrEndsWith( what, "frz" ) || ZCGlobal.StrStartsWith( what, "frz" ) )
				actoraction = AC_TicsFreeze;
			else if ( ZCGlobal.StrEndsWith( what, "skip" ) || ZCGlobal.StrStartsWith( what, "skip" ) )
				actoraction = AC_TicsSkip;
			else
				outValue = false;

			if ( outValue ) {
				if ( ccmdArgsSize == 1 ) {
					thing = LinetraceActor();
					outValue = true;
				} else {
					outValue = ( PPS_Error != ( testeeStatus = ParsePositionString( thing ) ) );
				}
			}
		} // of if ( ccmdArgsSize == 1 || ccmdArgsSize == 2 ) {}

		return outValue;
	} // of override bool HandleArguments() {}


	protected void TryRevive( Actor thing ) {
		bool reviveBlocked = false;
		readonly<Actor> defactor = GetDefaultByType( thing.GetClass() );

		if ( defactor.bSOLID || defactor.bBLOCKEDBYSOLIDACTORS ) {
			BlockThingsIterator it = BlockThingsIterator.CreateFromPos( thing.pos.x, thing.pos.y, thing.pos.z, thing.height, thing.radius, false );

			while ( it.Next() && !reviveBlocked ) {
				if ( it.thing != thing && thing.Distance2D( it.thing ) < thing.radius && it.thing.bSOLID )
					reviveBlocked = true;
			}
		}

		String thingClassName = thing.GetClassName();

		if ( !reviveBlocked ) {
			// Compatibility with older versions.
			Actor prevMaster = thing.master;
			thing.master = thing;
			thing.A_RaiseMaster();

			if ( thing ) {
				thing.master = prevMaster;

				if ( thing.bCORPSE )
					LogLocalize2Str( LL_Main, "ZCACT_CANNOTREVIVE", thingClassName );
				else
					LogLocalize2Str( LL_Detailed, "ZCACT_REVIVED", thingClassName );
			} else {
				LogLocalize2Str( LL_Main, "ZCACT_REVIVEVANISH", thingClassName );
			}
		} else {
			LogLocalize2Str( LL_Main, "ZCACT_REVIVEBLOCKED", thingClassName );
		}
	}

	override void DoCommand( void ) {
		if ( !thing )
			return;

		String thingname = thing.GetClassName();

		switch ( actoraction ) {
			case AC_Revive:
				TryRevive( thing );
				break;
			case AC_Kill:
				thing.A_Die();

				// Some actors are immediately destroyed after reaching the "Death:" state sequence.
				if ( thing && thing.health > 0 )
					LogLocalize2Str( LL_Main, "ZCACT_CANNOTKILL", thingname );
				else
					LogLocalize2Str( LL_Detailed, "ZCACT_KILLED", thingname );
				break;
			case AC_XKill:
				thing.DamageMobj( thing, thing, 0x7FFFFFF, 'None', DMSS_FOILINVUL | DMSS_NOFACTOR | DMSS_NOPROTECT );

				if ( thing && thing.health > 0 )
					LogLocalize2Str( LL_Main, "ZCACT_CANNOTXKILL", thingname );
				else
					LogLocalize2Str( LL_Detailed, "ZCACT_XKILLED", thingname );
				break;
			case AC_Destroy:
				if ( RemoveWorldThinker( thing ) )
					LogLocalize2Str( LL_Detailed, "ZCACT_DESTROYED", thingname );
				break;
			case AC_Stop:
				thing.vel = (0, 0, 0);

				PlayerPawn pl = PlayerPawn( thing );

				if ( pl != NULL ) {
					pl.player.cheats &= ~CF_INTERPVIEW;
					pl.player.vel = (0.0, 0.0);
				}

				LogLocalize2Str( LL_Detailed, "ZCACT_VELSTOPPED", thingname );
				break;
			case AC_TicsFreeze:
				thing.tics = -1;
				LogLocalize2Str( LL_Detailed, "ZCACT_STATEFROZEN", thingname );
				break;
			case AC_TicsSkip:
				thing.tics = 0;
				LogLocalize2Str( LL_Detailed, "ZCACT_STATESKIPPED", thingname );
				break;
			case AC_TicsRevert:
				thing.tics = thing.CurState.tics;
				LogLocalize2Str( LL_Detailed, "ZCACT_STATETICSRESET", thingname );
				break;
			default:
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::DoCommand(). Unknown action id \"" .. actoraction .. "\" for thing " .. thingname );
				break;
		}

	} // of override void DoCommand( void ) {}

} // of class ZCActorActionCommand: ZCConsoleCommand {}


struct ZCSummonExtraParameters play {
	// Will be reworked to the struct like ZCSetPropertyExtraParameters.

	const SPECARGS_MAX = 5;
	const INFOPANEL_IGNORE = -2;
	const INFOPANEL_NOFREE = -1;

	int infopanelPos;

	double faceangle;
	bool isAngled;
	bool isFaceangleRelative;

	double facepitch;
	bool isFacepitchRelative;

	double zofs, forwardofs;

	int tid;
	int special;
	int specargs[ SPECARGS_MAX ];

	int spawnhp;
	int aggresiveness;

	bool isSpeedSet, isFloatSpeedSet;
	double speed, floatspeed; // [McM] By ika707's request.

	// Flags:
	bool notProjectileRules;
	bool dormant;
	bool noGravity;

	bool isFriend;		// Mutual exclusive with the next flag.
	bool isFoe;

	bool forceInfight;	// Mutual exclusive with the next flag.
	bool cannotInfight;


	void Clear( void ) {
		infopanelPos = INFOPANEL_IGNORE;

		isAngled = isSpeedSet = isFloatSpeedSet = false;
		isFaceangleRelative = isFacepitchRelative = false;
		faceangle = 0.0;
		facepitch = 0.0;
		zofs = forwardofs = 0.0;
		speed = floatspeed = 0.0;

		tid = special = 0;
		aggresiveness = -1;
		spawnhp = 0;

		for ( int i = 0; i < SPECARGS_MAX; i++ )
			specargs[ i ] = 0;

		isFriend = isFoe = notProjectileRules = dormant = noGravity = forceInfight = cannotInfight = false;
	}

	void clampfloat( out double value, String valuedesc, double minlimit, double maxlimit ) {
		double tmpfloat = clamp( value, minlimit, maxlimit );

		if ( value != tmpfloat ) {
			ZCGlobal.Log( LL_Main, String.Format( ZCGlobal.Locz( "ZCSUMMON_CLAMPFLOAT" ), valuedesc, value, minlimit, maxlimit, tmpfloat ) );
			value = tmpfloat;
		}
	}

	void clampint( out int value, String valuedesc, int minlimit, int maxlimit ) {
		int tmpint = clamp( value, minlimit, maxlimit );

		if ( value != tmpint ) {
			ZCGlobal.Log( LL_Main, String.Format( ZCGlobal.Locz( "ZCSUMMON_CLAMPINT" ), valuedesc, value, minlimit, maxlimit, tmpint ) );
			value = tmpint;
		}
	}

	void AdjustValues( void ) {
		faceangle %= 360.0;
		clampfloat( facepitch, "Pitch", -90.0, 90.0 );

		clampfloat( zofs, "Z offset", -32768.0, 32768.0 );
		clampfloat( forwardofs, "Forward offset", -32768.0, 32768.0 );

		if ( isSpeedSet )
			clampfloat( speed, "Speed", 0.0, 32768.0 );

		if ( isFloatSpeedSet )
			clampfloat( floatspeed, "Float speed", 0.0, 32768.0 );

		clampint( special, "Actor action special", 0, 65535 );
		clampint( spawnhp, "Spawn health", 0, 0x7FFFFFFF );

		if ( aggresiveness != -1 )
			clampint( aggresiveness, "Aggresiveness", 0, 255 );

		for ( int i = 0; i < SPECARGS_MAX; i++ )
			clampint( specargs[ i ], "Arg[ " .. i .. " ]", 0, 255 );
	}
}; // of struct ZCSummonExtraParameters play {}

class ZCSummonCommand: ZCConsoleCommand {
	String summonee;
	int summoneeAmount;
	ZCSummonExtraParameters params;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_summon",
			"$ZCSUMMON_HELP_TITLE",
			"$ZCSUMMON_HELP_DESC",
			'ZCTooltipSummonCommand'
		);
	}

	override bool HandleArguments() {
		summoneeAmount = 1;
		summonee = "";
		params.Clear();

		bool outValue = false;
		int ccmdArgsSize = ccmd.args.Size();
		String paramstr = "";

		if ( ccmdArgsSize > 0 && ccmdArgsSize < 4 ) {
			summonee = ccmd.args[ 0 ];

			if ( ccmdArgsSize > 1 ) {
				if ( str2int_Ptr( ccmd.args[ 1 ], +summoneeAmount ) ) {
					if ( ccmdArgsSize == 3 )
						paramstr = ccmd.args[ 2 ];
				} else {
					paramstr = ccmd.args[ 1 ];
				}
			}

			outValue = true;

			if ( paramstr != "" ) {
				Array<String> paramlist;
				paramstr.ToLower();
				paramstr.Split( paramlist, ",", TOK_SKIPEMPTY );

				for ( int i = 0; i < paramlist.Size(); i++ ) {
					String curparam = paramlist[ i ];
					int colonIndex = -1;

					// Flags:
					if ( curparam == "f" || curparam.Left( 2 ) == "fr" ) {
						params.isFriend = true;
						params.isFoe = false;
					} else if ( curparam == "foe" || curparam == "enemy" ) {
						params.isFriend = false;
						params.isFoe = true;
					} else if ( curparam == "notprj" || curparam.Left( 7 ) == "notproj" ) {
						params.notProjectileRules = true;
					} else if ( curparam == "dormant" ) {
						params.dormant = true;
					} else if ( ZCGlobal.StrStartsWith( curparam, "nograv" ) ) {
						params.noGravity = true;
					} else if ( curparam.Left( 4 ) == "infi" ) {
						params.forceInfight = true;
						params.cannotInfight = false;
					} else if ( curparam.Left( 6 ) == "noinfi" ) {
						params.forceInfight = false;
						params.cannotInfight = true;

					// Arguments:
					} else if ( curparam.Left( 3 ) == "add" || curparam.Left( 5 ) == "panel" ) {
						if ( -1 != ( colonIndex = curparam.IndexOf( ":" ) ) || -1 != ( colonIndex = curparam.IndexOf( "=" ) ) ) {
							String panelposStr = curparam.Mid( colonIndex + 1, curparam.Length() - colonIndex - 1 );

							if ( panelposStr == "" || panelposStr == "free" || panelposStr == "-" ) {
								params.infopanelPos = ZCAddCommand.FindFreeTesteePlace( ccmd );
							} else {
								int panelposNum;

								if ( str2int_Ptr( panelposStr, +panelposNum ) && checkTesteePlace( --panelposNum ) )
									params.infopanelPos = panelposNum;
								else
									LogLocalize2Str( LL_Main, "ZCSUMMON_WRONGPANEL", panelposStr );
							}
						} else {
							params.infopanelPos = ZCAddCommand.FindFreeTesteePlace( ccmd );
						}

					} else if ( -1 != ( colonIndex = curparam.IndexOf( ":" ) ) || -1 != ( colonIndex = curparam.IndexOf( "=" ) ) ) {
						if ( colonIndex < curparam.Length() ) {
							String paramdiv[ 2 ];
							paramdiv[ 0 ] = curparam.Left( colonIndex );
							paramdiv[ 1 ] = curparam.Mid( colonIndex + 1, curparam.Length() - colonIndex - 1 );

							int paramvalue;
							int paramnamelen = paramdiv[ 0 ].Length();

							if ( str2int_Ptr( paramdiv[ 1 ], +paramvalue, true ) ) {
								if ( paramdiv[ 0 ] == "ang" || paramdiv[ 0 ] == "angle" ) {
									params.faceangle = paramvalue;
									params.isFaceangleRelative = false;
									params.isAngled = true;
								} else if ( ZCGlobal.StrStartsWith( paramdiv[ 0 ], "rela" ) || paramdiv[ 0 ] == "ra" || ZCGlobal.StrStartsWith( paramdiv[ 0 ], "relativea" ) || ZCGlobal.StrStartsWith( paramdiv[ 0 ], "rang" ) ) {
									params.faceangle = paramvalue;
									params.isFaceangleRelative = true;
									params.isAngled = true;

								} else if ( paramdiv[ 0 ] == "pitch" ) {
									params.facepitch = paramvalue;
									params.isFacepitchRelative = false;
								} else if ( paramdiv[ 0 ] == "rp" || ZCGlobal.StrStartsWith( paramdiv[ 0 ], "relp" ) || ZCGlobal.StrStartsWith( paramdiv[ 0 ], "relativep" ) ) {
									params.facepitch = paramvalue;
									params.isFacepitchRelative = true;

								} else if ( paramdiv[ 0 ] == "speed" || paramdiv[ 0 ] == "spd" ) {
									params.speed = paramvalue;
									params.isSpeedSet = true;
								} else if ( paramdiv[ 0 ] == "fspeed" || ZCGlobal.StrStartsWith( paramdiv[ 0 ], "floatsp" ) ) {
									params.floatspeed = paramvalue;
									params.isFloatSpeedSet = true;

								} else if ( paramdiv[ 0 ] == "tid" ) {
									params.tid = paramvalue;
								} else if ( paramdiv[ 0 ] == "hp" || paramdiv[ 0 ] == "health" ) {
									params.spawnhp = paramvalue;
								} else if ( paramdiv[ 0 ] == "spec" || paramdiv[ 0 ] == "special" ) {
									params.special = paramvalue;

								} else if ( paramdiv[ 0 ] == "z" || paramdiv[ 0 ] == "zofs" || paramdiv[ 0 ] == "zoffset" ) {
									params.zofs = paramvalue;
								} else if ( paramdiv[ 0 ] == "fwd" || paramdiv[ 0 ] == "fofs" || paramdiv[ 0 ] == "foffset" || paramdiv[ 0 ] == "fwdofs" || paramdiv[ 0 ] == "fwdoffset" || paramdiv[ 0 ] == "forwardofs" || paramdiv[ 0 ] == "forwardoffset" ) {
									params.forwardofs = paramvalue;
								} else if ( paramdiv[ 0 ].Left( 4 ) == "aggr" ) {
									params.aggresiveness = paramvalue;

								} else if ( ( paramnamelen == 2 && paramdiv[ 0 ].Left( 1 ) == "a" ) || ( paramnamelen == 4 && paramdiv[ 0 ].Left( 3 ) == "arg" ) ) {
									int argnum = paramdiv[ 0 ].Mid( paramnamelen - 1, 1 ).CharCodeAt( 0 ) - 0x30;

									if ( argnum >= 0 && argnum < params.SPECARGS_MAX )
										params.specargs[ argnum ] = paramvalue;
									else
										LogLocalize2Str( LL_Main, "ZCSUMMON_WRONGARG", paramdiv[ 0 ] );

								} else {
									LogLocalize2Str( LL_Main, "ZCSUMMON_UNKNOWNPARAM", curparam );
								}
							} else {
								ZCGlobal.Log( LL_Main, String.Format( ZCGlobal.Locz( "ZCSUMMON_WRONGDIGIT" ), paramdiv[ 1 ], paramdiv[ 0 ] ) );
							} // of else of if ( str2int_Ptr( paramdiv[ 1 ], +paramvalue, true ) ) {}

						} else {
							LogLocalize2Str( LL_Main, "ZCSUMMON_EMPTYVALUE", curparam );
						} // of else of if ( colonIndex < curparam.Length() ) {}

					} else {
						LogLocalize2Str( LL_Main, "ZCSUMMON_UNKNOWNFLAG", curparam );
					}

				} // of for ( int i = 0; i < paramlist.Size(); i++ ) {}
			} // of if ( paramstr != "" ) {}

		} // of if ( ccmdArgsSize > 0 && ccmdArgsSize < 4 ) {}


		if ( outValue ) {
			summonee = ParseSpecialActorName( ccmd.args[ 0 ] );
			params.AdjustValues();
		}

		return outValue;
	}

	protected virtual void PostActorSummon( Actor summoned, Actor splayer ) {
		if ( !summoned )
			return;

		if ( params.isAngled )
			summoned.angle = ( ( params.isFaceangleRelative? summoned.AngleTo( splayer ) + 180.0 : 0.0 ) + params.faceangle ) % 360.0;


		double newpitch = params.facepitch;

		if ( params.isFacepitchRelative ) {
			newpitch += splayer.pitch;
			params.clampfloat( newpitch, "Relative pitch", -90.0, 90.0 );
		}

		summoned.pitch = newpitch;


		if ( params.isFriend )
			summoned.bFRIENDLY = true;
		else if ( params.isFoe )
			summoned.bFRIENDLY = false;

		if ( params.isSpeedSet )
			summoned.speed = params.speed;
		if ( params.isFloatSpeedSet )
			summoned.floatspeed = params.floatspeed;

		if ( params.dormant )
			summoned.Deactivate( NULL );

		if ( params.noGravity )
			summoned.bNOGRAVITY = true;

		if ( params.forceInfight ) {
			summoned.bFORCEINFIGHTING = true;
			summoned.bNOINFIGHTING = false;
		} else if ( params.cannotInfight ) {
			summoned.bFORCEINFIGHTING = false;
			summoned.bNOINFIGHTING = true;
		}

		if ( params.aggresiveness != -1 )
			summoned.MinMissileChance = 255 - params.aggresiveness;

		if ( params.spawnhp != 0 )
			summoned.health = params.spawnhp;

		if ( params.tid )
			summoned.ChangeTid( params.tid );
		if ( params.special )
			summoned.special = params.special;

		for ( int i = 0; i < params.SPECARGS_MAX; i++ )
			if ( params.specargs[ i ] != 0 )
				summoned.args[ i ] = params.specargs[ i ];
	}

	override void DoCommand( void ) {
		if ( classnameParseStatus == CPS_RegexFailed )
			return;

		if ( summoneeAmount > 256 && !ZCGlobal.DangerousCCMDsAllowed( ZCGlobal.Locz( "ZCSUMMON_LIMITWARNING" ) ) ) {
			ZCGlobal.Log( LL_Main, ZCGlobal.Locz( "ZCSUMMON_LIMITPREVENT" ) );
			return;
		}

		class<Actor> summoneeClass = summonee;

		if ( summoneeClass ) {
			// See GZDoom source code -> "src/d_net.cpp" -> "Net_DoCommand()".
			Actor player = players[ ccmd.e.Player ].mo;

			if ( player ) {
				readonly<Actor> summoneeDef = GetDefaultByType( summoneeClass );
				Actor summoned = NULL;

				if ( !params.notProjectileRules && summoneeDef.bMISSILE ) {
					vector3 spawnpos = player.Vec3Angle( summoneeDef.radius * 2 + player.radius + params.forwardofs, player.angle, 8.0 + params.zofs );

					for ( int i = 0; i < summoneeAmount; i++ ) {
						summoned = player.SpawnPlayerMissile( summoneeClass );

						if ( summoned ) {
							vector2 dirFromPlayer = player.Vec2To( summoned );
							summoned.SetOrigin( summoned.pos + ( dirFromPlayer / dirFromPlayer.Length() * params.forwardofs, params.zofs ), false );

							PostActorSummon( summoned, player );
						}
					}
				} else {
					vector3 spawnpos = player.Vec3Angle( summoneeDef.radius * 2 + player.radius + params.forwardofs, player.angle, 8.0 + params.zofs );

					for ( int i = 0; i < summoneeAmount; i++ )
						PostActorSummon( summoned = Actor.Spawn( summoneeClass, spawnpos, ALLOW_REPLACE ), player );
				} // of else of if ( GetDefaultByType( summoneeClass ).bMISSILE ) {}

				if ( summoned ) {
					ZCGlobal.Log( LL_Detailed, String.Format( ZCGlobal.Locz( "ZCSUMMON_SUCCESS" ), summoneeAmount, ( summoneeAmount > 1? ZCGlobal.Locz( "ZCSUMMON_SUCCESS_ACTORS" ) : ZCGlobal.Locz( "ZCSUMMON_SUCCESS_1ACTOR" ) ), summoneeClass.GetClassName() ) );

					if ( params.infopanelPos == params.INFOPANEL_NOFREE ) {
						ZCGlobal.Log( LL_Main, String.Format( ZCGlobal.Locz( "ZCSUMMON_ADDINSUFFPLACE" ), MaxTestee ) );

					} else if ( params.infopanelPos != params.INFOPANEL_IGNORE ) {
						// No duplicate fields check when summoning new actors, of course.

						ZCheckerField field = ccmd.handler.Testee[ params.infopanelPos ];

						field.mo = summoned;
						field.UpdateActorMetainformation( ccmd );

						if ( summoneeAmount > 1 )
							ZCGlobal.Log( LL_Main, ZCGlobal.Locz( "ZCSUMMON_ADDONLYLAST" ) );
					}

				} else {
					// If an actor cannot be summoned or destroyed right after its spawn:
					LogLocalize2Str( LL_Main, "ZCSUMMON_CANNOTSUMMON", summonee );
				}

			} // of if ( player ) {}

		} else {
			LogLocalize2Str( LL_Main, "ZCSUMMON_NOTACTOR", summonee );
		}
	}
} // of class ZCSummonCommand: ZCConsoleCommand {}


class ZCCopyPasteClass_dummy: ZCConsoleCommand {
	override void InitCCMD() {
		SetupCCMDInterface(
			"",
			"$ZCCOPYPASTE_HELP_TITLE",
			"$ZCCOPYPASTE_HELP_DESC",
			helpaliases: "copy, copyclass, copysummon, paste, pasteclass"
		);
	}
}


class ZCSetFlagCommand: ZCConsoleCommand {
	Actor testee;
	EPositionParseStatus testeeStatus;
	String flagName;
	int flagSetType;
	bool skipKnownFlags;
	bool callACSSetFlag;
 
	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_setflag",
			"$ZCSETFLAG_HELP_TITLE",
			"$ZCSETFLAG_HELP_DESC",
			'ZCTooltipSetFlagCommand'
		);
	}

	override bool HandleArguments() {
		flagSetType = -1;
		skipKnownFlags = false;

		//zcsetflag [<pos>] <flagname> [<type>][,nospec[ecial]|raw|acs]
		bool outValue = false;

		int ccmdArgsSize = ccmd.args.Size();

		if ( ccmdArgsSize == 2 || ccmdArgsSize == 3 ) {
			String optionstr[ 2 ];
			optionstr[ 0 ] = ccmd.args[ ccmdArgsSize - 1 ];
			optionstr[ 0 ].ToLower();

			int delimIndex = ZCGlobal.StrIndexOfAny( optionstr[ 0 ], ",:" );

			if ( delimIndex != -1 ) {
				optionstr[ 1 ] = optionstr[ 0 ].Mid( delimIndex + 1, optionstr[ 0 ].Length() - delimIndex - 1 );
				optionstr[ 0 ].Truncate( delimIndex );
			} else {
				optionstr[ 1 ] = "";
			}

			for ( int i = 0; i < 2; i++ ) {
				if ( optionstr[ i ] == "" )
					continue;

				if ( optionstr[ i ] == "raw" || optionstr[ i ].Left( 6 ) == "nospec" || optionstr[ i ] == "acs" )
					skipKnownFlags = true;
				else
					flagSetType = getBoolFromStr( optionstr[ i ] );
			}
		} // of if ( ccmdArgsSize == 2 || ccmdArgsSize == 3 ) {}

		if ( ccmdArgsSize == 1 ) {
			flagName = ccmd.args[ 0 ];
			outValue = true;
			testee = LinetraceActor();

		} else if ( ccmdArgsSize == 2 ) {
			if ( flagSetType != -1 || skipKnownFlags ) {
				flagName = ccmd.args[ 0 ];
				outValue = true;
				testee = LinetraceActor();
			} else if ( PPS_Error != ( testeeStatus = ParsePositionString( testee ) ) ) {
				flagName = ccmd.args[ 1 ];
				outValue = true;
			}

		} else if ( ( ccmdArgsSize == 3 ) && ( PPS_Error != ( testeeStatus = ParsePositionString( testee ) ) ) ) {
			flagName = ccmd.args[ 1 ];
			outValue = ( flagSetType != -1 ) || skipKnownFlags;
		}

		//console.printf( TEXTCOLOR_DARKGRAY .. GetClassName() .. "HandleArguments(). zcStatus: " .. testeeStatus .. " (actor " .. ZCGlobal.ObjectName( testee ) .. "), flagName: " .. flagName .. ", flagSetType: " .. flagSetType .. ".  outValue: " .. outValue .. "." );

		return outValue;
	}

	private bool setFlag( bool origflag ) {
		callACSSetFlag = false;

		if ( flagSetType == -1 )
			flagSetType = !origflag;

		return flagSetType;
	}

	// I have no idea how to convert a sequence of Strings to flag names less crooked...
	override void DoCommand( void ) {
		if ( !testee )
			return;

		callACSSetFlag = true;

		if ( !skipKnownFlags ) {
			flagName.ToUpper();

			if ( flagName == "BUDDHA" )
				testee.bBUDDHA = setFlag( testee.bBUDDHA );
			else if ( flagName == "NODAMAGE" )
				testee.bNODAMAGE = setFlag( testee.bNODAMAGE );
			else if ( flagName == "NOINTERACTION" )
				testee.bNOINTERACTION = setFlag( testee.bNOINTERACTION );
			else if ( flagName == "SOLID" )
				testee.bSOLID = setFlag( testee.bSOLID );
			else if ( flagName == "SHOOTABLE" )
				testee.bSHOOTABLE = setFlag( testee.bSHOOTABLE );
			else if ( flagName == "FLOAT" )
				testee.bFLOAT = setFlag( testee.bFLOAT );
			else if ( flagName == "NOGRAVITY" )
				testee.bNOGRAVITY = setFlag( testee.bNOGRAVITY );
			else if ( flagName == "FRIENDLY" )
				testee.bFRIENDLY = setFlag( testee.bFRIENDLY );
			else if ( flagName == "DORMANT" )
				testee.bDORMANT = setFlag( testee.bDORMANT );
			else if ( flagName == "NOTARGET" )
				testee.bNOTARGET = setFlag( testee.bNOTARGET );
			else if ( flagName == "FORCEINFIGHTING" )
				testee.bFORCEINFIGHTING = setFlag( testee.bFORCEINFIGHTING );
			else if ( flagName == "NOINFIGHTING" )
				testee.bNOINFIGHTING = setFlag( testee.bNOINFIGHTING );
			else if ( flagName == "INVULNERABLE" )
				testee.bINVULNERABLE = setFlag( testee.bINVULNERABLE );
			else if ( flagName == "BRIGHT" )
				testee.bBRIGHT = setFlag( testee.bBRIGHT );
			else if ( flagName == "NONSHOOTABLE" )
				testee.bNONSHOOTABLE = setFlag( testee.bNONSHOOTABLE );
			else if ( flagName == "NOBLOCKMAP" )
				testee.A_ChangeLinkFlags( blockmap: setFlag( testee.bNOBLOCKMAP ) );
			else if ( flagName == "NOSECTOR" )
				testee.A_ChangeLinkFlags( sector: setFlag( testee.bNOSECTOR ) );

			if ( !callACSSetFlag )
				ZCGlobal.Log( LL_Detailed, String.Format( ZCGlobal.Locz( "ZCSETFLAG_SUCCESS" ), flagName, testee.GetClassName(), flagSetType ) );
		} // of if ( !skipKnownFlags ) {}


		if ( callACSSetFlag ) {
			let storage = ZCZScriptACSStringsAPI.Get();
			storage.AddString( storage.APIST_Flags, flagName );

			// Cannot get ACS asynchronous "SetResultValue()" here.
			testee.ACS_NamedExecuteAlways( "ZChecker_CCMD_SetFlag", 0, flagSetType );
		}
	} // of override void DoCommand( void ) {}

	static String ACS_GetFlagName( Actor activator ) {
		return ZCZScriptACSStringsAPI.PopStringStatic( ZCZScriptACSStringsAPI.APIST_Flags );
	}
} // of class ZCSetFlagCommand: ZCConsoleCommand {}

class ZCSetStateCommand: ZCConsoleCommand {
	EPositionParseStatus testeeStatus;
	Actor testee;
	String newState;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_setstate",
			"$ZCSETSTATE_HELP_TITLE",
			"$ZCSETSTATE_HELP_DESC",
			'ZCTooltipSetStateCommand'
		);
	}

	override bool HandleArguments() {
		testeeStatus = PPS_Error;
		bool outValue = false;

		if ( ccmd.args.Size() == 1 ) {
			newState = ccmd.args[ 0 ];
			outValue = true;
			testee = LinetraceActor();
		} else if ( ccmd.args.Size() == 2 && PPS_Error != ( testeeStatus = ParsePositionString( testee ) ) ) {
			newState = ccmd.args[ 1 ];
			outValue = true;
		}

		return outValue;
	}

	// I have no idea how to convert a sequence of Strings to StateLabel less crooked, too...
	override void DoCommand( void ) {
		if ( testee ) {
			let storage = ZCZScriptACSStringsAPI.Get();
			storage.AddString( storage.APIST_States, newState );

			// Cannot get ACS asynchronous "SetResultValue()" here.
			testee.ACS_NamedExecuteAlways( "ZChecker_CCMD_SetState", 0 );
		}
	}

	static String ACS_GetStateName( Actor activator ) {
		return ZCZScriptACSStringsAPI.PopStringStatic( ZCZScriptACSStringsAPI.APIST_States );
	}
} // of class ZCSetStateCommand: ZCConsoleCommand {}




struct ZCSetPropertyParameterDouble {
	double value;
	bool changed;

	double valclamp( String valuedesc, double minlimit, double maxlimit ) {
		if ( !changed )
			return value;

		double tmpfloat = clamp( value, minlimit, maxlimit );

		if ( value != tmpfloat ) {
			ZCGlobal.ClearscopeLog( LL_Main, String.Format( ZCGlobal.Locz( "ZCSUMMON_CLAMPFLOAT" ), valuedesc, value, minlimit, maxlimit, tmpfloat ) );
			value = tmpfloat;
		}

		return value;
	}

	void set( in double newval ) {
		value = newval;
		changed = true;
	}

	void setfor( out double what ) {
		if ( changed )
			what = value;
	}
} // of struct ZCSetPropertyParameterDouble {}

struct ZCSetPropertyParameterInteger {
	int value;
	bool changed;

	int valclamp( String valuedesc, int minlimit, int maxlimit ) {
		if ( !changed )
			return value;

		int tmpint = clamp( value, minlimit, maxlimit );

		if ( value != tmpint ) {
			ZCGlobal.ClearscopeLog( LL_Main, String.Format( ZCGlobal.Locz( "ZCSUMMON_CLAMPINT" ), valuedesc, value, minlimit, maxlimit, tmpint ) );
			value = tmpint;
		}

		return value;
	}

	void set( in int newval ) {
		value = newval;
		changed = true;
	}

	void setfor( out int what ) {
		if ( changed )
			what = value;
	}

	void directcopy( String valuedesc, in int newval ) {
		if ( changed ) {
			ZCGlobal.DataLog( LL_Detailed, String.Format( ZCGlobal.Localize( "ZCSETP_NONRELATIVEPROP" ), valuedesc ) );
			value = newval;
		}
	}
} // of struct ZCSetPropertyParameterInteger {}

struct ZCSetPropertyParameterPointer {
	Actor value;
	bool changed;

	void set( in Actor newval ) {
		value = newval;
		changed = true;
	}

	void setfor( out Actor what ) {
		if ( changed )
			what = value;
	}

	void directcopy( String valuedesc, in Actor newval ) {
		if ( changed ) {
			ZCGlobal.DataLog( LL_Detailed, String.Format( ZCGlobal.Localize( "ZCSETP_NONRELATIVEPROP" ), valuedesc ) );
			value = newval;
		}
	}
} // of struct ZCSetPropertyParameterPointer {}


struct ZCSetPropertyExtraParameters play {
	enum EPropertyFieldsDoubles {
		PFD_X = 0,	// Coordinates.
		PFD_Y,
		PFD_Z,
		PFD_VelX,	// Current velocity.
		PFD_VelY,
		PFD_VelZ,
		PFD_Angle,	// Tilts.
		PFD_Pitch,
		PFD_Roll,
		PFD_Radius,	// Interactions.
		PFD_Height,
		PFD_Speed,
		PFD_FloatSpeed,
		PFD_Gravity,
		PFD_ScaleX,	// Visual.
		PFD_ScaleY,
		PFD_Alpha,

		PFD_Quantity
	}

	enum EPropertyFieldsIntegers {
		PFI_Health = 0,
		PFI_Mass,
		PFI_Arg0,
		PFI_Arg1,
		PFI_Arg2,
		PFI_Arg3,
		PFI_Arg4,
		PFI_Special,
		PFI_TID,
		PFI_RenderStyle,

		PFI_Quantity,

		PFI_Args_Start		= PFI_Arg0,
		PFI_Args_End 		= PFI_Arg4 + 1,
	}

	enum EPropertyFieldsPointers {
		PFP_Target = 0,
		PFP_Master,
		PFP_Tracer,

		PFP_Quantity
	}

	ZCSetPropertyParameterDouble[ PFD_Quantity ] doubles;
	ZCSetPropertyParameterInteger[ PFI_Quantity ] integers;
	ZCSetPropertyParameterPointer[ PFP_Quantity ] pointers;

	bool rawhealth;


	void Clear( void ) {
		for ( int i = 0; i < PFD_Quantity; i++ )
			doubles[ i ].changed = false;

		for ( int i = 0; i < PFI_Quantity; i++ )
			integers[ i ].changed = false;

		for ( int i = 0; i < PFP_Quantity; i++ )
			pointers[ i ].changed = false;

		rawhealth = false;
	}

	void AdjustValues( void ) {
		static const double PFD_Data_MinLimits[] = {
			-9999999999.9, -9999999999.9, -9999999999.9,
			-32767.0, -32767.0, -32767.0,
			-36000.0, -90.0, -36000.0,
			0.0, 0.0, 0.0, 0.0, 0.0,
			-32767.0, -32767.0, 0.0
		};
		static const double PFD_Data_MaxLimits[] = {
			9999999999.9, 9999999999.9, 9999999999.9,
			32767.0, 32767.0, 32767.0,
			36000.0, 90.0, 36000.0,
			32767.0, 32767.0, 32767.0, 32767.0, 32767.0,
			32767.0, 32767.0, 1.0
		};
		static const String PFD_Data_LimitsDescriptions[] = {
			"X", "Y", "Z",
			"velX", "velY", "velZ",
			"angle", "pitch", "roll",
			"radius", "height", "speed", "float speed", "gravity",
			"scaleX", "scaleY", "alpha"
		};
		static const String PFP_Data_PtrDescriptions[] = {
			"target", "master", "tracer"
		};


		for ( int i = 0; i < PFD_Quantity; i++ )
			doubles[ i ].valclamp( PFD_Data_LimitsDescriptions[ i ], PFD_Data_MinLimits[ i ], PFD_Data_MaxLimits[ i ] );

		doubles[ PFD_Angle ].value %= 360.0;
		doubles[ PFD_Roll ].value %= 360.0;

		integers[ PFI_Health ].valclamp( "Health", -0x7FFFFFFF, 0x7FFFFFFF );
		integers[ PFI_Special ].valclamp( "Special/action", 0, 65535 );
		integers[ PFI_TID ].valclamp( "TID", 0, 0x7FFFFFFF );

		for ( int i = PFI_Args_Start; i < PFI_Args_End; i++ )
			integers[ i ].valclamp( "Args[ " .. ( i - PFI_Args_Start ) .. " ]", 0, 255 );

		if ( integers[ PFI_RenderStyle ].value != STYLE_None )
			integers[ PFI_RenderStyle ].valclamp( "Render style", STYLE_Normal, ZCSpritesInfoPanel.STYLE_Quantity - 1 );
	} // of void AdjustValues( void ) {}

}; // of struct ZCSetPropertyExtraParameters play {}

class ZCSetPropertyCommand: ZCConsoleCommand {
	enum EPropertySetMode {
		PSM_Error = -1,
		PSM_Raw = 0,
		PSM_Add,
		PSM_Relative,
	};

	Actor alteree;
	Actor relativeTo; // May be an alteree actor itself.

	EPropertySetMode setmode;
	ZCSetPropertyExtraParameters params;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_setproperty",
			"$ZCSETP_HELP_TITLE",
			"$ZCSETP_HELP_DESC",
			'ZCTooltipSetPropertyCommand'
		);
	}

	protected void handlePointer( int pointer_id, String propvalue ) {
		if ( setmode == PSM_Relative ) {
			params.pointers[ pointer_id ].changed = true;

		} else if ( propvalue != "" ) {
			Actor newptr;

			if ( propvalue == "null" || propvalue == "none" || propvalue == "-" || propvalue == "rm" ) {
				params.pointers[ pointer_id ].set( NULL );
			} else {
				ParsePositionString( newptr, 0, propvalue );

				if ( newptr ) 
					params.pointers[ pointer_id ].set( newptr );
			}

		} else {
			params.pointers[ pointer_id ].set( players[ ccmd.e.Player ].mo );
		}
	} // of protected void handlePointer( int pointer_id, String propvalue ) {}

	protected bool parseSetArgProperty( String prop, int pvalueint, bool setpvalue = true ) {
		int propnamelen = prop.Length();
		bool outval = false;

		if ( ( propnamelen == 2 && prop.Left( 1 ) == "a" ) || ( propnamelen == 4 && prop.Left( 3 ) == "arg" ) ) {
			int argnum = prop.Mid( propnamelen - 1, 1 ).CharCodeAt( 0 ) - 0x30;

			if ( argnum >= 0 && argnum < ZCSummonExtraParameters.SPECARGS_MAX ) {
				if ( setpvalue )
					params.integers[ argnum + params.PFI_Arg0 ].set( pvalueint );

				outval = true;
			} else {
				LogLocalize2Str( LL_Main, "ZCSETP_WRONGARG", prop );
			}
		}

		return outval;
	} // of protected bool parseSetArgProperty( String prop, int pvalueint ) {}


	override bool HandleArguments() {
		bool outValue = false;
		int ccmdArgsSize = ccmd.args.Size();
		alteree = relativeTo = NULL;
		setmode = PSM_Raw;

		if ( ccmdArgsSize == 1 ) {
			// Set properties for the linetarget.
			alteree = LinetraceActor();
			outValue = true;

		} else if ( ccmdArgsSize > 1 && ccmdArgsSize < 4 ) {
			String modeargstr = ccmd.args[ ccmdArgsSize - 2 ];
			modeargstr.ToLower();

			String modeargstrLeft3 = modeargstr.Left( 3 );

			// Set mode parsing:
			if ( modeargstr == "add" || modeargstr == "a" || modeargstr == "+" ) {
				setmode = PSM_Add;

			} else if ( modeargstrLeft3 == "rel" || modeargstr == "r" /* Dangerous but convenient. */ ) {
				setmode = PSM_Relative;

				int delimIndex = ZCGlobal.StrIndexOfAny( modeargstr, ":,=" );

				if ( delimIndex == -1 || ( modeargstr.Length() == delimIndex + 1 ) ) {
					relativeTo = players[ ccmd.e.Player ].mo;
					ZCGlobal.Log( LL_Detailed, "$ZCSETP_RELPLAYER" );

				} else {
					String relactorstr = modeargstr.Mid( delimIndex + 1, modeargstr.Length() - delimIndex - 1 );

					if ( ParsePositionString( relativeTo, specialstring: relactorstr ) == PPS_Error )
						setmode = PSM_Error;
					else if ( !relativeTo )
						ZCGlobal.Log( LL_Main, "$ZCSETP_RELNOTFOUND" );
				}


			} else if ( modeargstr == "raw" || modeargstrLeft3 == "dir" ) {
				setmode = PSM_Raw;

			} else {
				setmode = PSM_Error;
			}


			// In general an alteree actor place parsing.
			if ( setmode == PSM_Relative && !relativeTo ) {
				// If relative actor not found:
				alteree = NULL;
				outValue = true;

			} else if ( ccmdArgsSize != 2 || setmode == PSM_Error ) {
				// If something is unclear:

				if ( ccmdArgsSize == 3 && setmode == PSM_Error ) {
					// 3 args [pos, wrong_mode, props]:
					LogLocalize2Str( LL_Main, "ZCSETP_UNKNOWNMODE", modeargstr );

				} else if ( PPS_Error != ParsePositionString( alteree, 0 ) ) {
					// 2 args [pos, props]; or
					// 3 args [pos, mode, props]:
					outValue = true;
				}

			} else {
				// If linetarget as 2 args [mode, props].
				alteree = LinetraceActor();
				outValue = true;
			}
		} // of else if ( ccmdArgsSize > 1 ) {}


		// Parse properties/parameters string:
		if ( outValue && alteree ) {
			params.Clear();

			Array<String> paramlist;
			ccmd.args[ ccmdArgsSize - 1 ].ToLower();
			ccmd.args[ ccmdArgsSize - 1 ].Split( paramlist, ",", TOK_SKIPEMPTY );

			for ( int i = 0; i < paramlist.Size(); i++ ) {
				String curparam = paramlist[ i ];
				curparam.ToLower();

				int delimIndex = ZCGlobal.StrIndexOfAny( curparam, "=:" );

				if ( delimIndex == -1 && setmode != PSM_Relative ) {
					LogLocalize2Str( LL_Main, "ZCSETP_NODELIMCHARS", curparam );
					continue;
				}

				String prop = curparam.Left( delimIndex );
				String pvalue = "";

				if ( delimIndex != -1 )
					pvalue = curparam.Mid( delimIndex + 1, curparam.Length() - delimIndex - 1 );


				if ( prop == "target" || prop == "targ" || prop == "tp" ) {
					handlePointer( params.PFP_Target, pvalue );

				} else if ( prop == "master" || prop == "mp" ) {
					handlePointer( params.PFP_Master, pvalue );

				} else if ( prop == "tracer" || prop == "trp" || prop == "rp" ) {
					handlePointer( params.PFP_Tracer, pvalue );

				} else {
					double paramdouble;

					// Some parameters has special keywords and must be parsed differently (see below).
					if ( str2double_Ptr( pvalue, +paramdouble ) ) {
						int paramint;

						if ( prop == "angle" || prop == "ang" ) {
							params.doubles[ params.PFD_Angle ].set( paramdouble );
						} else if ( prop == "pitch" ) {
							params.doubles[ params.PFD_Pitch ].set( paramdouble );
						} else if ( prop == "roll" ) {
							params.doubles[ params.PFD_Roll ].set( paramdouble );
						} else if ( prop == "x" || prop == "posx" || prop == "xpos" ) {
							params.doubles[ params.PFD_X ].set( paramdouble );
						} else if ( prop == "y" || prop == "posy" || prop == "ypos" ) {
							params.doubles[ params.PFD_Y ].set( paramdouble );
						} else if ( prop == "z" || prop == "posz" || prop == "zpos" ) {
							params.doubles[ params.PFD_Z ].set( paramdouble );
						} else if ( prop == "vx" || prop == "velx" || prop == "xvel" ) {
							params.doubles[ params.PFD_VelX ].set( paramdouble );
						} else if ( prop == "vy" || prop == "vely" || prop == "yvel" ) {
							params.doubles[ params.PFD_VelY ].set( paramdouble );
						} else if ( prop == "vz" || prop == "velz" || prop == "zvel" ) {
							params.doubles[ params.PFD_VelZ ].set( paramdouble );
						} else if ( prop == "radius" || prop == "rad" ) {
							params.doubles[ params.PFD_Radius ].set( paramdouble );
						} else if ( prop == "height" ) {
							params.doubles[ params.PFD_Height ].set( paramdouble );
						} else if ( prop == "speed" ) {
							params.doubles[ params.PFD_Speed ].set( paramdouble );
						} else if ( prop == "floatspeed" || prop == "flspeed" || prop == "fspeed" ) {
							params.doubles[ params.PFD_FloatSpeed ].set( paramdouble );
						} else if ( prop == "gravity" || prop == "grav" ) {
							params.doubles[ params.PFD_Gravity ].set( paramdouble );
						} else if ( prop == "scale" ) {
							params.doubles[ params.PFD_ScaleX ].set( paramdouble );
							params.doubles[ params.PFD_ScaleY ].set( paramdouble );
						} else if ( prop == "scalex" || prop == "xscale" ) {
							params.doubles[ params.PFD_ScaleX ].set( paramdouble );
						} else if ( prop == "scaley" || prop == "yscale" ) {
							params.doubles[ params.PFD_ScaleY ].set( paramdouble );
						} else if ( prop == "alpha" ) {
							params.doubles[ params.PFD_Alpha ].set( paramdouble );

						// Integer properties:
						} else if ( str2int_Ptr( pvalue, +paramint, true ) ) {

							if ( prop == "health" || prop == "hp" || prop == "h" ) {
								params.rawhealth = false;
								params.integers[ params.PFI_Health ].set( paramint );
							} else if ( prop.Left( 4 ) == "rawh" ) {
								params.rawhealth = true;
								params.integers[ params.PFI_Health ].set( paramint );
							} else if ( prop == "mass" ) {
								params.integers[ params.PFI_Mass ].set( paramint );
							} else if ( prop == "tid" ) {
								params.integers[ params.PFI_TID ].set( paramint );
							} else if ( prop == "action" || prop == "special" || prop == "spec" ) {
								params.integers[ params.PFI_Special ].set( paramint );
							} else if ( prop.Left( 6 ) == "render" || prop == "rstyle" || prop == "rst" ) {
								params.integers[ params.PFI_RenderStyle ].set( paramint );
							} else if ( !parseSetArgProperty( prop, paramint ) ) {
								LogLocalize2Str( LL_Main, "ZCSETP_WRONGINTPROP", prop );
							}

						} else {
							LogLocalize2Str( LL_Main, "ZCSETP_WRONGFLOATPROP", prop );
						}

					} else {
						// Special and empty keywords (like "zcsp z:ceil" or "zcsp rel:1 target"):
						Actor baseactor = ( relativeTo? relativeTo : alteree );

						if ( prop.Left( 6 ) == "render" || prop == "rstyle" || prop == "rst" ) {
							if ( setmode == PSM_Relative || pvalue == "none" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_None );
							else if ( pvalue.Left( 4 ) == "norm" || pvalue == "x" || pvalue == "n" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_Normal );
							else if ( pvalue == "fuzzy" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_Fuzzy );
							else if ( pvalue == "optfuzzy" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_OptFuzzy );
							else if ( pvalue == "stencil" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_Stencil );
							else if ( pvalue == "translucentstencil" || ZCGlobal.StrStartsWith( pvalue, "transst" ) )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_TranslucentStencil );
							else if ( pvalue.Left( 5 ) == "trans" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_Translucent );
							else if ( pvalue == "add" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_Add );
							else if ( pvalue == "shaded" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_Shaded );
							else if ( pvalue == "shadow" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_Shadow );
							else if ( pvalue == "subtract" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_Subtract );
							else if ( pvalue == "addstencil" || pvalue == "addstc" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_AddStencil );
							else if ( pvalue == "addshaded" || pvalue == "addshd" )
								params.integers[ params.PFI_RenderStyle ].set( STYLE_AddShaded );
							else if ( pvalue.Left( 3 ) == "mul" )
								params.integers[ params.PFI_RenderStyle ].set( ZCSpritesInfoPanel.STYLE_Multiply );
							else if ( ZCGlobal.StrStartsWith( pvalue, "inversemul" ) || pvalue.Left( 6 ) == "invmul" )
								params.integers[ params.PFI_RenderStyle ].set( ZCSpritesInfoPanel.STYLE_InverseMultiply );
							else if ( pvalue.Left( 7 ) == "colorbl" )
								params.integers[ params.PFI_RenderStyle ].set( ZCSpritesInfoPanel.STYLE_ColorBlend );
							else if ( pvalue == "source" ) // Engine internal value, actually.
								params.integers[ params.PFI_RenderStyle ].set( ZCSpritesInfoPanel.STYLE_Source );
							else if ( pvalue == "coloradd" )
								params.integers[ params.PFI_RenderStyle ].set( ZCSpritesInfoPanel.STYLE_ColorAdd );
							else // Integer input is processed above.
								LogLocalize2Str( LL_Main, "ZCSETP_WRONGKEYWORDRENDERSTYLE", pvalue );

						} else if ( prop == "tid" ) {
							if ( setmode == PSM_Relative )
								params.integers[ params.PFI_TID ].changed = true;
							else if ( pvalue.Left( 1 ) == "u" || pvalue == "new" )
								params.integers[ params.PFI_TID ].set( Actor.FindUniqueTid() );

						} else if ( pvalue == "" ) {
							// Skip empty pvalue warning for some non-relative properties.
							if ( !( setmode == PSM_Relative && (
									( prop == "action" || prop == "special" || prop == "spec" )
								||	!parseSetArgProperty( prop, 0, false )
								) ) )
							{
								LogLocalize2Str( LL_Main, "ZCSETP_EMPTYPROP", prop );
							}

						} else if ( prop == "z" || prop == "posz" ) {
							String pvalueLeft1 = pvalue.Left( 1 );

							if ( pvalueLeft1 == "f" )
								params.doubles[ params.PFD_Z ].set( baseactor.floorz );
							else if ( pvalueLeft1 == "c" )
								params.doubles[ params.PFD_Z ].set( baseactor.ceilingz - alteree.height );
							else if ( pvalue.Left( 4 ) == "rawc" || pvalue.Left( 2 ) == "hc" )
								params.doubles[ params.PFD_Z ].set( baseactor.ceilingz );
							else
								LogLocalize2Str( LL_Main, "ZCSETP_WRONGKEYWORDZ", pvalue ); 

						} else if ( prop == "health" || prop == "hp" || prop == "h" ) {
							if ( pvalue.Left( 1 ) == "s" )
								params.integers[ params.PFI_Health ].set( baseactor.GetSpawnHealth() );
							else if ( pvalue == "max" )
								params.integers[ params.PFI_Health ].set( 0x7FFFFFFF );
							else
								LogLocalize2Str( LL_Main, "ZCSETP_WRONGKEYWORDHP", pvalue ); 


						} else {
							// In fact, this line is a last frontier when no input matches found at all.
							ZCGlobal.Log( LL_Main, String.Format( ZCGlobal.Locz( "ZCSETP_UNKNOWNPROP" ), prop, pvalue ) );
						}
					} // of else of if ( str2double_Ptr( paramdiv[ 1 ], +paramdouble ) ) {}

				} // of else of {} else if ( prop == "tracer" || prop == "trp" || prop == "rp" ) {}

			} // of for ( int i = 0; i < paramlist.Size(); i++ ) {}

		} // of if ( outValue && alteree ) {}


		if ( setmode == PSM_Add )
			relativeTo = alteree;

		return outValue;
	}

	override void DoCommand( void ) {
		if ( !alteree )
			return;

		// Pointer is valid in "PSM_Add" and "PSM_Relative" set modes.
		if ( relativeTo ) {
			params.integers[ params.PFI_Health ].value += relativeTo.health;
			params.integers[ params.PFI_Mass ].value += relativeTo.mass;

			params.doubles[ params.PFD_X ].value += relativeTo.pos.x;
			params.doubles[ params.PFD_Y ].value += relativeTo.pos.y;
			params.doubles[ params.PFD_Z ].value += relativeTo.pos.z;
			params.doubles[ params.PFD_VelX ].value += relativeTo.vel.x;
			params.doubles[ params.PFD_VelY ].value += relativeTo.vel.y;
			params.doubles[ params.PFD_VelZ ].value += relativeTo.vel.z;

			params.doubles[ params.PFD_Angle ].value += relativeTo.angle;
			params.doubles[ params.PFD_Pitch ].value += relativeTo.pitch;
			params.doubles[ params.PFD_Roll ].value += relativeTo.roll;
			params.doubles[ params.PFD_Radius ].value += relativeTo.radius;
			params.doubles[ params.PFD_Height ].value += relativeTo.height;
			params.doubles[ params.PFD_Speed ].value += relativeTo.speed;
			params.doubles[ params.PFD_FloatSpeed ].value += relativeTo.floatspeed;
			params.doubles[ params.PFD_Gravity ].value += relativeTo.gravity;
			params.doubles[ params.PFD_ScaleX ].value += relativeTo.scale.x;
			params.doubles[ params.PFD_ScaleY ].value += relativeTo.scale.y;
			params.doubles[ params.PFD_Alpha ].value += relativeTo.alpha;

			// Note about properties that do not make sense to alter relative to something:
			params.integers[ params.PFI_Special ].directcopy( "Special", relativeTo.special );
			params.integers[ params.PFI_TID ].directcopy( "TID", relativeTo.TID );
			params.integers[ params.PFI_RenderStyle ].directcopy( "RenderStyle", relativeTo.GetRenderStyle() );

			for ( int i = 0; i < ZCSummonExtraParameters.SPECARGS_MAX; i++ )
				params.integers[ params.PFI_Args_Start + i ].directcopy( "arg" .. i, relativeTo.args[ i ] );

			params.pointers[ params.PFP_Target ].directcopy( "target", relativeTo.target );
			params.pointers[ params.PFP_Master ].directcopy( "master", relativeTo.master );
			params.pointers[ params.PFP_Tracer ].directcopy( "tracer", relativeTo.tracer );

			/*if ( params.integers[ params.PFI_Special ].changed )
				LogLocalize2Str( LL_Main, "ZCSETP_NONRELATIVEPROP", "Special" );

			if ( params.integers[ params.PFI_TID ].changed )
				LogLocalize2Str( LL_Main, "ZCSETP_NONRELATIVEPROP", "TID" );

			for ( int i = 0; i < ZCSummonExtraParameters.SPECARGS_MAX; i++ )
				if ( params.integers[ params.PFI_Args_Start + i ].changed )
					LogLocalize2Str( LL_Main, "ZCSETP_NONRELATIVEPROP", "arg" .. i );

			if ( params.pointers[ params.PFP_Target ].changed )
				LogLocalize2Str( LL_Detailed, "ZCSETP_NONRELATIVEPROP", "target" );
			if ( params.pointers[ params.PFP_Master ].changed )
				LogLocalize2Str( LL_Detailed, "ZCSETP_NONRELATIVEPROP", "master" );
			if ( params.pointers[ params.PFP_Tracer ].changed )
				LogLocalize2Str( LL_Detailed, "ZCSETP_NONRELATIVEPROP", "tracer" );

			if ( params.integers[ params.PFI_RenderStyle ].changed )
				LogLocalize2Str( LL_Detailed, "ZCSETP_NONRELATIVEPROP", "RenderStyle" );*/
		}


		// Clamping etc.:
		params.AdjustValues();


		// Changing:
		params.pointers[ params.PFP_Target ].setfor( alteree.target );
		params.pointers[ params.PFP_Master ].setfor( alteree.master );
		params.pointers[ params.PFP_Tracer ].setfor( alteree.tracer );

		// Health must be handled in special way to properly kill an actor.
		if ( params.integers[ params.PFI_Health ].changed ) {
			int newhp = params.integers[ params.PFI_Health ].value;

			if ( !params.rawhealth ) {

				if ( !alteree.player ) {
					if ( newhp <= 0 )
						alteree.A_Die();

					alteree.health = newhp;

				} else {
					PlayerPawn pawn = PlayerPawn( alteree );

					if ( newhp <= 0 && pawn ) {
						// See "/src/m_cheat.cpp", class with disgusting name "DSuicider".
						// Strangely, but "pawn.CheatSuicide()" doesn't work properly.
						pawn.bSHOOTABLE = true;
						pawn.bINVULNERABLE = false;

						double savedDamageFactor = pawn.DamageFactor;
						pawn.DamageFactor = 1.0;
						pawn.DamageMobj( pawn, pawn, pawn.health, 'Suicide' );
						pawn.DamageFactor = savedDamageFactor;

						if ( pawn.health <= 0 )
							pawn.bSHOOTABLE = false;
					}

					alteree.player.health = alteree.health = newhp;
				}

			} else {
				alteree.health = newhp;
			} // of else of if ( !params.rawhealth ) {}

		} // of if ( params.integers[ params.PFI_Health ].changed ) {}

		params.integers[ params.PFI_Mass ].setfor( alteree.mass );
		params.integers[ params.PFI_Special ].setfor( alteree.special );

		if ( params.integers[ params.PFI_TID ].changed )
			alteree.ChangeTid( params.integers[ params.PFI_TID ].value );

		for ( int i = 0; i < ZCSummonExtraParameters.SPECARGS_MAX; i++ )
			params.integers[ params.PFI_Args_Start + i ].setfor( alteree.args[ i ] );

		bool changedX = params.doubles[ params.PFD_X ].changed;
		bool changedY = params.doubles[ params.PFD_Y ].changed;
		bool changedZ = params.doubles[ params.PFD_Z ].changed;
		vector3 altereeNewPos = (
					changedX? params.doubles[ params.PFD_X ].value : alteree.pos.x,
					changedY? params.doubles[ params.PFD_Y ].value : alteree.pos.y,
					changedZ? params.doubles[ params.PFD_Z ].value : alteree.pos.z
				);

		if ( changedX || changedY )
			alteree.SetOrigin( altereeNewPos, false );
		else if ( changedZ )
			alteree.SetZ( altereeNewPos.z );

		params.doubles[ params.PFD_VelX ].setfor( alteree.vel.x );
		params.doubles[ params.PFD_VelY ].setfor( alteree.vel.y );
		params.doubles[ params.PFD_VelZ ].setfor( alteree.vel.z );

		params.doubles[ params.PFD_Angle ].setfor( alteree.angle );
		params.doubles[ params.PFD_Pitch ].setfor( alteree.pitch );
		params.doubles[ params.PFD_Roll ].setfor( alteree.roll );
		alteree.A_SetSize( 	params.doubles[ params.PFD_Radius ].changed? params.doubles[ params.PFD_Radius ].value : -1,
							params.doubles[ params.PFD_Height ].changed? params.doubles[ params.PFD_Height ].value : -1, false );
		params.doubles[ params.PFD_Speed ].setfor( alteree.speed );
		params.doubles[ params.PFD_FloatSpeed ].setfor( alteree.floatspeed );
		params.doubles[ params.PFD_Gravity ].setfor( alteree.gravity );

		params.doubles[ params.PFD_Alpha ].setfor( alteree.alpha );

		if ( params.integers[ params.PFI_RenderStyle ].changed )
			alteree.A_SetRenderStyle( alteree.alpha, params.integers[ params.PFI_RenderStyle ].value );

		// Compatibility. GZDoom 4.9.0 cannot set "scale.x" and "scale.y" directly:
		vector2 newscale = (params.doubles[ params.PFD_ScaleX ].changed? params.doubles[ params.PFD_ScaleX ].value : alteree.scale.x,
							params.doubles[ params.PFD_ScaleY ].changed? params.doubles[ params.PFD_ScaleY ].value : alteree.scale.y);

		alteree.A_SetScale( newscale.x, newscale.y, usezero: true );


		//LogLocalize2Str( LL_Detailed, "ZCSETP_SUCCESS", "" .. alteree.GetClassName() );
	}
} // of class ZCSetPropertyCommand: ZCConsoleCommand {}
