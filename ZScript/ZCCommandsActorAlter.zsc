//
// All CCMDs which alters or creates an actor.
//

class ZCGiveCommand: ZCConsoleCommand {
	Actor testee;
	EPositionParseStatus testeeStatus;
	String itemName;
	int itemAmount;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_give",
			"zcgive [<pos>] <item> [<amount=1>]",
			"Give <amount> <item>s to the testee <pos> (or linetarget if omitted)",
			'ZCTooltipGiveCommand'
		);
	}

	override bool HandleArguments() {
		testeeStatus = PPS_Error;
		itemAmount = 1;
		itemName = "";

		bool outValue = false;

		if ( ccmd.args.Size() == 2 || ccmd.args.Size() == 3 )
			if ( !str2int_Ptr( ccmd.args[ ccmd.args.Size() - 1 ], +itemAmount ) )
				itemAmount = -1;

		if ( ccmd.args.Size() == 1 ) {
			itemName = ccmd.args[ 0 ];
			testee = LinetraceActor();
			outValue = true;
		} else if ( ccmd.args.Size() == 2 ) {
			if ( itemAmount != -1 ) {
				itemName = ccmd.args[ 0 ];
				outValue = true;
				testee = LinetraceActor();
			} else if ( PPS_Error != ( testeeStatus = getPlaceTestee( testee ) ) ) {
				itemAmount = 1;
				itemName = ccmd.args[ 1 ];
				outValue = true;
			}
		} else if ( ( ccmd.args.Size() == 3 ) && PPS_Error != ( testeeStatus = getPlaceTestee( testee ) ) ) {
			itemName = ccmd.args[ 1 ];
			outValue = true;
		}

		if ( outValue )
			itemName = ParseSpecialActorName( itemName, "Inventory" );

		return outValue && ( itemAmount != -1 );
	}

	override void DoCommand( void ) {
		if ( classnameParseStatus == CPS_RegexFailed )
			return;

		if ( testee ) {
			class<Actor> itemClass = itemName;

			if ( itemClass is 'Inventory' ) {
				if ( testee.A_GiveInventory( itemName, itemAmount ) )
					ZCGlobal.Log( LL_Detailed, "Item \"" .. itemClass.GetClassName() .. "\" is given to the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
				else
					ZCGlobal.Log( LL_Main, "Actor " .. testee.GetClassName() .. " cannot receive item." );
			} else {
				ZCGlobal.Log( LL_Main, "\"" .. itemName .. "\" isn't an inventory actor." );
			}
		} // of if ( testee ) {}

	}
} // of class ZCGiveCommand: ZCConsoleCommand {}

class ZCTakeCommand: ZCGiveCommand {
	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_take",
			"zctake [<pos>] <item> [<amount=1>]",
			"Take <amount> <item>s from the testee <pos> (or linetarget if omitted)",
			'ZCTooltipTakeCommand'
		);
	}

	override void DoCommand( void ) {
		if ( classnameParseStatus == CPS_RegexFailed )
			return;

		if ( testee ) {
			class<Actor> itemClass = itemName;

			if ( itemClass is 'Inventory' ) {
				if ( testee.A_TakeInventory( itemName, itemAmount ) ) {
					/*if ( !GetDefaultByType( itemClass ).bKEEPDEPLETED ) {
						ZCGlobal.Log( LL_Detailed, "DESTROY Item \"" .. itemClass.GetClassName() .. "\" taken from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
						Inventory inv = testee.FindInventory( itemName );
						inv.Destroy();
					}*/
					Inventory inv = testee.FindInventory( itemName );

					if ( inv && inv.amount == 0 )
						inv.Destroy();

					ZCGlobal.Log( LL_Detailed, "Item \"" .. itemClass.GetClassName() .. "\" is taken from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );

					/*if ( inv && !inv.bKEEPDEPLETED ) {
						ZCGlobal.Log( LL_Detailed, "Item \"" .. itemClass.GetClassName() .. "\" destroyed from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
						inv.Destroy();
					} else if ( inv ) {
						ZCGlobal.Log( LL_Detailed, "Item \"" .. itemClass.GetClassName() .. "\" taken from the actor " .. testee.GetClassName() .. " <" .. testee .. ">." );
					}*/
				} else {
					ZCGlobal.Log( LL_Main, "Cannot take item from actor " .. testee.GetClassName() .. "." );
				}
			} else {
				ZCGlobal.Log( LL_Main, "\"" .. itemName .. "\" isn't an inventory actor." );
			}
		} // of if ( testee ) {}
	} // of override void DoCommand( void ) {}

} // of class ZCTakeCommand: ZCGiveCommand {}

class ZCActorActionCommand: ZCConsoleCommand {
	enum EActorActions {
		AC_Error = 0,
		AC_Revive,
		AC_Kill,
		AC_Destroy,
		AC_XKill,
	};

	Actor thing;
	EPositionParseStatus testeeStatus;
	EActorActions actoraction;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_actoraction",
			"zcact [<pos>] <action>",
			"Do special complex action with actor on <pos> (or linetarget if omitted). Possible <action>s: \"rev[ive]\"|\"res[urrect]\", \"k[ill]\", \"xk[ill]\"|\"mdk\", \"destroy\"|\"rem[ove]\"|\"rm\"|\"del[ete]\""
		);
	}

	override bool HandleArguments() {
		testeeStatus = -1;
		bool outValue = false;

		if ( ccmd.args.Size() == 1 || ccmd.args.Size() == 2 ) {
			outValue = true;
			String what = ccmd.args[ ccmd.args.Size() - 1 ];
			what.ToLower();
			String what3chars = what.Left( 3 );

			if ( what3chars == "res" || what3chars == "rev" )
				actoraction = AC_Revive;
			else if ( what == "kill" || what == "k" || what == "die" )
				actoraction = AC_Kill;
			else if ( what == "xk" || what == "xkill" || what == "mdk" )
				actoraction = AC_XKill;
			else if ( what == "destroy" || what3chars == "rem" || what == "rm" || what3chars == "del" )
				actoraction = AC_Destroy;
			else
				outValue = false;

			if ( outValue ) {
				if ( ccmd.args.Size() == 1 ) {
					thing = LinetraceActor();
					outValue = true;
				} else {
					outValue = ( PPS_Error != ( testeeStatus = getPlaceTestee( thing ) ) );
				}
			}
		} // of if ( ccmd.args.Size() == 1 || ccmd.args.Size() == 2 ) {}

		return outValue;
	}

	protected void TryRevive( Actor thing ) {
		bool reviveBlocked = false;
		readonly<Actor> defactor = GetDefaultByType( thing.GetClass() );

		if ( defactor.bSOLID || defactor.bBLOCKEDBYSOLIDACTORS ) {
			BlockThingsIterator it = BlockThingsIterator.CreateFromPos( thing.pos.x, thing.pos.y, thing.pos.z, thing.height, thing.radius, false );

			while ( it.Next() && !reviveBlocked ) {
				if ( it.thing != thing && thing.Distance2D( it.thing ) < thing.radius && it.thing.bSOLID )
					reviveBlocked = true;
			}
		}


		if ( !reviveBlocked ) {
			// Compatibility with older versions.
			Actor prevMaster = thing.master;
			thing.master = thing;
			thing.A_RaiseMaster();

			if ( thing ) {
				thing.master = prevMaster;

				if ( thing.bCORPSE )
					ZCGlobal.Log( LL_Main, "Cannot revive actor " .. thing.GetClassName() );
				else
					ZCGlobal.Log( LL_Detailed, "Revived actor " .. thing.GetClassName() );
			} else {
				ZCGlobal.Log( LL_Main, "Actor " .. thing.GetClassName() .. " revived, but vanished." );
			}
		} else {
			ZCGlobal.Log( LL_Main, "Actor " .. thing.GetClassName() .. " reviving " .. TEXTCOLOR_BRICK .. "blocked\c-." );
		}
	}

	override void DoCommand( void ) {
		if ( !thing )
			return;

		Name thingname = thing.GetClassName();

		switch ( actoraction ) {
			case AC_Revive:
				TryRevive( thing );
				break;
			case AC_Kill:
				thing.A_Die();

				// Some actors are instantly destroyed in the "Death:" state sequence.
				if ( thing && thing.health > 0 )
					ZCGlobal.Log( LL_Main, "Cannot kill actor " .. thingname );
				else
					ZCGlobal.Log( LL_Detailed, "Killed actor " .. thingname );
				break;
			case AC_XKill:
				thing.DamageMobj( thing, thing, 0x7FFFFFF, 'None', DMSS_FOILINVUL | DMSS_NOFACTOR | DMSS_NOPROTECT );

				if ( thing && thing.health > 0 )
					ZCGlobal.Log( LL_Main, "Cannot extremely kill actor " .. thingname );
				else
					ZCGlobal.Log( LL_Detailed, "Extremely killed actor " .. thingname );
				break;
			case AC_Destroy:
				if ( RemoveWorldThinker( thing ) )
					ZCGlobal.Log( LL_Detailed, "Destroyed actor " .. thingname );
				break;
			default:
				ZCGlobal.Log( LL_Emergency, "Unknown action id \"" .. actoraction .. "\" for thing " .. thingname );
				break;
		}
	}
} // of class ZCActorActionCommand: ZCConsoleCommand {}


struct ZCSummonExtraParameters play {
	const SPECARGS_MAX = 5;

	double faceangle;
	bool isAngled;
	bool isFaceangleRelative;
	double zofs, forwardofs;

	int tid;
	int special;
	int specargs[ SPECARGS_MAX ];

	bool isFriend;
	bool isFoe;
	bool notProjectileRules;
	int spawnhp;
	int aggresiveness;
	bool forceInfight;
	bool cannotInfight;

	void Clear( void ) {
		isAngled = false;
		isFaceangleRelative = false;
		faceangle = 0.0;
		zofs = forwardofs = 0.0;

		tid = special = 0;
		aggresiveness = -1;
		spawnhp = 0;

		for ( int i = 0; i < SPECARGS_MAX; i++ )
			specargs[ i ] = 0;

		isFriend = isFoe = notProjectileRules = forceInfight = cannotInfight = false;
	}

	private void clampfloat( out double value, String valuedesc, double minlimit, double maxlimit ) {
		double tmpfloat = clamp( value, minlimit, maxlimit );

		if ( value != tmpfloat ) {
			ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. valuedesc .. " (" .. value .. ") isn't in range [" .. minlimit .. "; " .. maxlimit .. "]. " .. LLCOLOR_MAIN .. "Clamped to " .. tmpfloat );
			value = tmpfloat;
		}
	}

	private void clampint( out int value, String valuedesc, int minlimit, int maxlimit ) {
		int tmpint = clamp( value, minlimit, maxlimit );

		if ( value != tmpint ) {
			ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. valuedesc .. " (" .. value .. ") isn't in range [" .. minlimit .. "; " .. maxlimit .. "]. " .. LLCOLOR_MAIN .. "Clamped to " .. tmpint );
			value = tmpint;
		}
	}

	void AdjustValues( void ) {
		faceangle %= 360.0;

		clampfloat( zofs, "Z offset", -32767.0, 32768.0 );
		clampfloat( forwardofs, "Forward offset", -32767.0, 32768.0 );

		clampint( special, "Actor special", 0, 255 );
		clampint( spawnhp, "Spawn health", 0, 0x7FFFFFFF );

		if ( aggresiveness != -1 )
			clampint( aggresiveness, "Aggresiveness", 0, 255 );

		for ( int i = 0; i < SPECARGS_MAX; i++ )
			clampint( specargs[ i ], "Arg[ " .. i .. " ]", 0, 255 );
	}
}; // of struct ZCSummonExtraParameters play {}

class ZCSummonCommand: ZCConsoleCommand {
	String summonee;
	int summoneeAmount;
	ZCSummonExtraParameters params;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_summon",
			"zcsummon <class> [<amount=1>] [<comma-separated: [rel]ang,tid,spec,arg0-4,zofs,fofs,hp,aggr (...:<value>),notproj,friend|foe,[no]infi>]",
			"Summon <amount> of <class>es on position by rules of build-in eponymous command. Extended info (<extras>) may be provided by comma-separated (\",\") list. Possible parameters are:\n   f[riend]|foe, [r[el]]a[ngle]:<[relative]faceangle>, tid:<TID>, zofs:<mappixels>, f[wd]ofs:<mappixels>, hp|health:<hp>, notproj[ectile], spec:<special>, a[rg]0:<arg0>,...,a[rg]4:<arg4>, aggr[essiveness]:<dflt55>, [no]infi[ght].",
			'ZCTooltipSummonCommand'
		);
	}

	override bool HandleArguments() {
		summoneeAmount = 1;
		summonee = "";
		params.Clear();

		bool outValue = false;
		int argsSize = ccmd.args.Size();
		String paramstr = "";

		if ( argsSize > 0 ) {
			summonee = ccmd.args[ 0 ];

			if ( argsSize > 1 ) {
				if ( str2int_Ptr( ccmd.args[ 1 ], +summoneeAmount ) ) {
					if ( argsSize == 3 )
						paramstr = ccmd.args[ 2 ];
				} else {
					paramstr = ccmd.args[ 1 ];
				}
			}

			outValue = true;

			if ( paramstr != "" ) {
				Array<String> paramlist;
				paramstr.ToLower();
				paramstr.Split( paramlist, ",", TOK_SKIPEMPTY );

				for ( int i = 0; i < paramlist.Size(); i++ ) {
					String curparam = paramlist[ i ];
					int colonIndex = -1;

					// Flags:
					if ( curparam == "f" || curparam.Left( 2 ) == "fr" ) {
						params.isFriend = true;
						params.isFoe = false;
					} else if ( curparam == "foe" || curparam == "enemy" ) {
						params.isFriend = false;
						params.isFoe = true;
					} else if ( curparam == "notprj" || curparam.Left( 7 ) == "notproj" ) {
						params.notProjectileRules = true;
					} else if ( curparam.Left( 4 ) == "infi" ) {
						params.forceInfight = true;
						params.cannotInfight = false;
					} else if ( curparam.Left( 6 ) == "noinfi" ) {
						params.forceInfight = false;
						params.cannotInfight = true;

					} else if ( -1 != ( colonIndex = curparam.IndexOf( ":" ) ) || -1 != ( colonIndex = curparam.IndexOf( "=" ) ) ) {
						if ( colonIndex < curparam.Length() ) {
							String paramdiv[ 2 ];
							paramdiv[ 0 ] = curparam.Left( colonIndex );
							paramdiv[ 1 ] = curparam.Mid( colonIndex + 1, curparam.Length() - colonIndex - 1 );

							int paramvalue;
							int paramnamelen = paramdiv[ 0 ].Length();

							if ( str2int_Ptr( paramdiv[ 1 ], +paramvalue, true ) ) {
								if ( paramdiv[ 0 ] == "ang" || paramdiv[ 0 ] == "angle" ) {
									params.faceangle = paramvalue;
									params.isFaceangleRelative = false;
									params.isAngled = true;
								} else if ( paramdiv[ 0 ] == "relang" || paramdiv[ 0 ] == "relangle" || paramdiv[ 0 ] == "relativeang" || paramdiv[ 0 ] == "relativeangle" || paramdiv[ 0 ] == "rang" || paramdiv[ 0 ] == "rangle" ) {
									params.faceangle = paramvalue;
									params.isFaceangleRelative = true;
									params.isAngled = true;
								} else if ( paramdiv[ 0 ] == "tid" ) {
									params.tid = paramvalue;
								} else if ( paramdiv[ 0 ] == "hp" || paramdiv[ 0 ] == "health" ) {
									params.spawnhp = paramvalue;
								} else if ( paramdiv[ 0 ] == "spec" || paramdiv[ 0 ] == "special" ) {
									params.special = paramvalue;
								} else if ( paramdiv[ 0 ] == "z" || paramdiv[ 0 ] == "zofs" || paramdiv[ 0 ] == "zoffset" ) {
									params.zofs = paramvalue;
								} else if ( paramdiv[ 0 ] == "fwd" || paramdiv[ 0 ] == "fofs" || paramdiv[ 0 ] == "foffset" || paramdiv[ 0 ] == "fwdofs" || paramdiv[ 0 ] == "fwdoffset" || paramdiv[ 0 ] == "forwardofs" || paramdiv[ 0 ] == "forwardoffset" ) {
									params.forwardofs = paramvalue;
								} else if ( paramdiv[ 0 ].Left( 4 ) == "aggr" ) {
									params.aggresiveness = paramvalue;
								} else if ( ( paramnamelen == 2 && paramdiv[ 0 ].Left( 1 ) == "a" ) || ( paramnamelen == 4 && paramdiv[ 0 ].Left( 3 ) == "arg" ) ) {
									int argnum = paramdiv[ 0 ].Mid( paramnamelen - 1, 1 ).CharCodeAt( 0 ) - 0x30;

									if ( argnum >= 0 && argnum < params.SPECARGS_MAX )
										params.specargs[ argnum ] = paramvalue;
									else
										ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Wrong argument number for parameter \"" .. paramdiv[ 0 ] .. "\"." );
								} else {
									ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Unknown parameter \"" .. curparam .. "\"." );
								}
							} else {
								ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Value \"" .. paramdiv[ 1 ] .. "\" for parameter \"" .. paramdiv[ 0 ] .. "\" isn't a digit." );
							} // of else of if ( str2int_Ptr( paramdiv[ 1 ], +paramvalue ) ) {}

						} else {
							ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "No value " .. LLCOLOR_MAIN .. "for parameter \"" .. curparam .. "\"." );
						} // of else of if ( colonIndex < curparam.Length() ) {}

					} else {
						ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Unknown flag \"" .. curparam .. "\"." );
					}

				} // of for ( int i = 0; i < paramlist.Size(); i++ ) {}
			} // of if ( paramstr != "" ) {}

		} // of if ( argsSize > 0 ) {}


		if ( outValue ) {
			summonee = ParseSpecialActorName( ccmd.args[ 0 ] );
			params.AdjustValues();
		}

		return outValue;
	}

	protected virtual void PostActorSummon( Actor summoned, Actor splayer ) {
		if ( !summoned )
			return;

		if ( params.isAngled )
			summoned.angle = ( params.isFaceangleRelative? summoned.AngleTo( splayer ) : 0.0 ) + params.faceangle;

		if ( params.isFriend )
			summoned.bFRIENDLY = true;
		else if ( params.isFoe )
			summoned.bFRIENDLY = false;

		if ( params.forceInfight ) {
			summoned.bFORCEINFIGHTING = true;
			summoned.bNOINFIGHTING = false;
		} else if ( params.cannotInfight ) {
			summoned.bFORCEINFIGHTING = false;
			summoned.bNOINFIGHTING = true;
		}

		if ( params.aggresiveness != -1 )
			summoned.MinMissileChance = 255 - params.aggresiveness;

		if ( params.spawnhp != 0 )
			summoned.health = params.spawnhp;

		if ( params.tid )
			summoned.ChangeTid( params.tid );
		if ( params.special )
			summoned.special = params.special;

		for ( int i = 0; i < params.SPECARGS_MAX; i++ )
			if ( params.specargs[ i ] != 0 )
				summoned.args[ i ] = params.specargs[ i ];
	}

	override void DoCommand( void ) {
		if ( classnameParseStatus == CPS_RegexFailed )
			return;

		if ( summoneeAmount > 200 && !ZCGlobal.DangerousCCMDsAllowed( "summoning more than 200 actors" ) ) {
			ZCGlobal.Log( LL_Main, "Trying to summon more than 200 actors in once. " .. TEXTCOLOR_DARKGRAY .. "You may disable this limiting switching the \"Allow dangerous actions\" option." );
			return;
		}

		class<Actor> summoneeClass = summonee;

		if ( summoneeClass is 'Actor' ) {
			// See GZDoom source code -> "src/d_net.cpp" -> "Net_DoCommand()".
			Actor player = players[ ccmd.e.Player ].mo;

			if ( player ) {
				readonly<Actor> summoneeDef = GetDefaultByType( summoneeClass );
				Actor summoned = NULL;

				if ( !params.notProjectileRules && summoneeDef.bMISSILE ) {
					vector3 spawnpos = player.Vec3Angle( summoneeDef.radius * 2 + player.radius + params.forwardofs, player.angle, 8.0 + params.zofs );

					for ( int i = 0; i < summoneeAmount; i++ ) {
						summoned = player.SpawnPlayerMissile( summoneeClass );

						if ( summoned ) {
							vector2 dirFromPlayer = player.Vec2To( summoned );
							summoned.SetOrigin( summoned.pos + ( dirFromPlayer / dirFromPlayer.Length() * params.forwardofs, params.zofs ), false );

							PostActorSummon( summoned, player );
						}
					}
				} else {
					vector3 spawnpos = player.Vec3Angle( summoneeDef.radius * 2 + player.radius + params.forwardofs, player.angle, 8.0 + params.zofs );

					for ( int i = 0; i < summoneeAmount; i++ )
						PostActorSummon( summoned = Actor.Spawn( summoneeClass, spawnpos, ALLOW_REPLACE ), player );
				} // of else of if ( GetDefaultByType( summoneeClass ).bMISSILE ) {}

				if ( summoned )
					ZCGlobal.Log( LL_Detailed, "Summoned " .. summoneeAmount .. " actor" .. ( summoneeAmount > 1? "s " : " " ) .. TEXTCOLOR_DARKGRAY .. "of class \"" .. TEXTCOLOR_GREEN .. summoneeClass.GetClassName() .. TEXTCOLOR_DARKGRAY .. "\"" );
				else
					ZCGlobal.Log( LL_Main, TEXTCOLOR_BRICK .. "Cannot summon actor class" .. ( summoneeAmount > 1? "es " : " " ) .. TEXTCOLOR_DARKGRAY .. "\"" .. TEXTCOLOR_GRAY .. summoneeClass.GetClassName() .. TEXTCOLOR_DARKGRAY .. "\". It may be abstract or immediately destroyed in the BeginPlay() override." );
			} // of if ( player ) {}

		} else {
			ZCGlobal.Log( LL_Main, "\"" .. summonee .. "\" isn't an actor class." );
		}
	}
} // of class ZCSummonCommand: ZCConsoleCommand {}

class ZCCopyPasteClass_dummy: ZCConsoleCommand {
	override void InitCCMD() {
		SetupCCMDInterface(
			"",
			"zccopyclass;zccopysummon [<amount=1>] [<comma-separated list as in \"zcsummon\">]",
			"A paired commands. \"zccopyclass\" saves a linetarget actor class into $savedclass internal variable; \"zccopysummon\" summons a $savedclass actor(s)."
		);
	}
}


class ZCSetFlagCommand: ZCConsoleCommand {
	Actor testee;
	EPositionParseStatus testeeStatus;
	String flagName;
	int flagSetType;
	bool skipKnownFlags;
	bool callACSSetFlag;
 
	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_setflag",
			"zcsetflag [<pos>] <flag name> [<value: 0/f[alse]/reset or 1/t[rue]/set>[,nospec]];zcsetf [<pos>] <flag name> [<value>[,nospec]];zcsf [<pos>] <flag name> [<value>[,nospec]];zcbud [<pos>] [<value>]",
			"Set/reset a <flag> for the testee in <pos> (or linetarget actor if omitted). If no <value> provided, toggles a <flag>. Note: because of asynchronous ZScript netevent and ACS machine execution result in singleplayer for the most of the flags will be delayed for one tic.",
			'ZCTooltipSetFlagCommand'
		);
	}

	override bool HandleArguments() {
		flagSetType = -1;
		skipKnownFlags = false;
//zcsetflag [<pos>] <flagname> [<type>][,nospec[ecial]|raw]
		bool outValue = false;

		int ccmdArgsSize = ccmd.args.Size();

		if ( ccmdArgsSize == 2 || ccmdArgsSize == 3 ) {
			String optionstr[ 2 ];
			optionstr[ 0 ] = ccmd.args[ ccmdArgsSize - 1 ];
			optionstr[ 0 ].ToLower();

			int delimIndex = optionstr[ 0 ].IndexOf( "," );

			if ( delimIndex == -1 )
				delimIndex = optionstr[ 0 ].IndexOf( "=" );

			if ( delimIndex == -1 )
				delimIndex = optionstr[ 0 ].IndexOf( ":" );

			if ( delimIndex != -1 ) {
				optionstr[ 1 ] = optionstr[ 0 ].Mid( delimIndex + 1, optionstr[ 0 ].Length() - delimIndex - 1 );
				optionstr[ 0 ].Truncate( delimIndex );
			} else {
				optionstr[ 1 ] = "";
			}

			for ( int i = 0; i < 2; i++ ) {
				if ( optionstr[ i ] == "" )
					continue;

				if ( optionstr[ i ] == "raw" || optionstr[ i ] == "ns" || optionstr[ i ].Left( 6 ) == "nospec" || optionstr[ i ] == "acs" )
					skipKnownFlags = true;
				else
					flagSetType = getBoolFromStr( optionstr[ i ] );
			}
		} // of if ( ccmdArgsSize == 2 || ccmdArgsSize == 3 ) {}

		if ( ccmdArgsSize == 1 ) {
			flagName = ccmd.args[ 0 ];
			outValue = true;
			testee = LinetraceActor();

		} else if ( ccmdArgsSize == 2 ) {
			if ( flagSetType != -1 || skipKnownFlags ) {
				flagName = ccmd.args[ 0 ];
				outValue = true;
				testee = LinetraceActor();
			} else if ( PPS_Error != ( testeeStatus = getPlaceTestee( testee ) ) ) {
				flagName = ccmd.args[ 1 ];
				outValue = true;
			}

		} else if ( ( ccmdArgsSize == 3 ) && ( PPS_Error != ( testeeStatus = getPlaceTestee( testee ) ) ) ) {
			flagName = ccmd.args[ 1 ];
			outValue = ( flagSetType != -1 ) || skipKnownFlags;
		}

		//console.printf( TEXTCOLOR_DARKGRAY .. GetClassName() .. "HandleArguments(). zcStatus: " .. testeeStatus .. " (actor " .. ZCGlobal.ObjectName( testee ) .. "), flagName: " .. flagName .. ", flagSetType: " .. flagSetType .. ".  outValue: " .. outValue .. "." );

		return outValue;
	}

	private bool setFlag( bool origflag ) {
		callACSSetFlag = false;

		if ( flagSetType == -1 )
			flagSetType = !origflag;

		return flagSetType;
	}

	// I have no idea how to convert a sequence of Strings to flag names less crooked...
	override void DoCommand( void ) {
		if ( !testee )
			return;

		callACSSetFlag = true;

		if ( !skipKnownFlags ) {
			flagName.ToUpper();

			if ( flagName == "BUDDHA" )
				testee.bBUDDHA = setFlag( testee.bBUDDHA );
			else if ( flagName == "NODAMAGE" )
				testee.bNODAMAGE = setFlag( testee.bNODAMAGE );
			else if ( flagName == "NOINTERACTION" )
				testee.bNOINTERACTION = setFlag( testee.bNOINTERACTION );
			else if ( flagName == "SOLID" )
				testee.bSOLID = setFlag( testee.bSOLID );
			else if ( flagName == "SHOOTABLE" )
				testee.bSHOOTABLE = setFlag( testee.bSHOOTABLE );
			else if ( flagName == "FLOAT" )
				testee.bFLOAT = setFlag( testee.bFLOAT );
			else if ( flagName == "NOGRAVITY" )
				testee.bNOGRAVITY = setFlag( testee.bNOGRAVITY );
			else if ( flagName == "FRIENDLY" )
				testee.bFRIENDLY = setFlag( testee.bFRIENDLY );
			else if ( flagName == "DORMANT" )
				testee.bDORMANT = setFlag( testee.bDORMANT );
			else if ( flagName == "NOTARGET" )
				testee.bNOTARGET = setFlag( testee.bNOTARGET );
			else if ( flagName == "FORCEINFIGHTING" )
				testee.bFORCEINFIGHTING = setFlag( testee.bFORCEINFIGHTING );
			else if ( flagName == "NOINFIGHTING" )
				testee.bNOINFIGHTING = setFlag( testee.bNOINFIGHTING );
			else if ( flagName == "INVULNERABLE" )
				testee.bINVULNERABLE = setFlag( testee.bINVULNERABLE );
			else if ( flagName == "BRIGHT" )
				testee.bBRIGHT = setFlag( testee.bBRIGHT );
			else if ( flagName == "NONSHOOTABLE" )
				testee.bNONSHOOTABLE = setFlag( testee.bNONSHOOTABLE );
			else if ( flagName == "NOBLOCKMAP" )
				testee.A_ChangeLinkFlags( blockmap: setFlag( testee.bNOBLOCKMAP ) );
			else if ( flagName == "NOSECTOR" )
				testee.A_ChangeLinkFlags( sector: setFlag( testee.bNOSECTOR ) );

			if ( !callACSSetFlag )
				ZCGlobal.Log( LL_Detailed, "Flag \"" .. flagName .. "\" for actor " .. testee.GetClassName() .. " is succesfully set to " .. flagSetType );
		} // of if ( !skipKnownFlags ) {}


		if ( callACSSetFlag ) {
			let storage = ZCZScriptACSStringsAPI.Get();
			storage.AddString( storage.APIST_Flags, flagName );

			// Cannot get ACS asynchronous "SetResultValue()" here.
			testee.ACS_NamedExecuteAlways( "ZChecker_CCMD_SetFlag", 0, flagSetType );
		}
	} // of override void DoCommand( void ) {}

	static String ACS_GetFlagName( Actor activator ) {
		return ZCZScriptACSStringsAPI.PopStringStatic( ZCZScriptACSStringsAPI.APIST_Flags );
	}
} // of class ZCSetFlagCommand: ZCConsoleCommand {}

class ZCSetStateCommand: ZCConsoleCommand {
	EPositionParseStatus testeeStatus;
	Actor testee;
	String newState;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_setstate",
			"zcsetstate [<pos>] <state label>;zcsets [<pos>] <state label>;zcst [<pos>] <state label>",
			"Set a state to <state label> for the testee in <pos> (or actor on line of sight if omitted). Note: because of asynchronous ZScript/ACS execution result in singleplayer will be delayed for one tic."
		);
	}

	override bool HandleArguments() {
		testeeStatus = PPS_Error;
		bool outValue = false;

		if ( ccmd.args.Size() == 1 ) {
			newState = ccmd.args[ 0 ];
			outValue = true;
			testee = LinetraceActor();
		} else if ( ccmd.args.Size() == 2 && PPS_Error != ( testeeStatus = getPlaceTestee( testee ) ) ) {
			newState = ccmd.args[ 1 ];
			outValue = true;
		}

		return outValue;
	}

	// I have no idea how to convert a sequence of Strings to StateLabel less crooked, too...
	override void DoCommand( void ) {
		if ( testee ) {
			let storage = ZCZScriptACSStringsAPI.Get();
			storage.AddString( storage.APIST_States, newState );

			// Cannot get ACS asynchronous "SetResultValue()" here.
			testee.ACS_NamedExecuteAlways( "ZChecker_CCMD_SetState", 0 );
		}
	}

	static String ACS_GetStateName( Actor activator ) {
		return ZCZScriptACSStringsAPI.PopStringStatic( ZCZScriptACSStringsAPI.APIST_States );
	}
} // of class ZCSetStateCommand: ZCConsoleCommand {}


class ZCSetPropertyCommand: ZCConsoleCommand {
	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_setproperty",
			"zcsetprop[erty] [<pos>] <property> <value>;zcsetp [<pos>] <property> <value>;zcwrite [<pos>] <property> <value>;zcw [<pos>] <property> <value>",

			"Sets a <property> to <value> for the actor in position <pos> (or for the linetarget). By default all properties will be simply overwritten, but some of them may has a prefix \"a[dd]\"|\"+\" for adding to current value, or \"r[el[ative]]]\" for setting it relative to caller (player). Possible properties are:\n"
				.. "  [a|r](pos|warp) <x>,<y>[,<z>]; [a](h[ealth]|hp) <val>; [a]speed <val>; [a|r]ang[le] <val>; [a|r]pitch <val>; [a|r]roll <val>; [a]scale (<both>|<x>,<y>); [a]alpha <val>; [a]radius <val>; [a]height <val>; target|pt <pos>; master|pm <pos>; tracer|pr <pos>; [a]a[rg]0..[a]a[rg]4 <val>; special|action <val>; [a]mass <val>; tid <val>; tidtohate <val>; [a|r]grav[ity] <val>"
		);

		zcFlags = CCF_Unreleased;
	}

	override bool HandleArguments() {
		ZCGlobal.Log( LL_Main, LLCOLOR_EMERGENCY .. "[Work-in-progress, not released yet]." );
		return false;
	}

	override void DoCommand( void ) {
		ZCGlobal.Log( LL_Main, "Impossible inscription, actually. Despite the fact it is a dummy." );
	}
} // of class ZCSetPropertyCommand: ZCConsoleCommand {}
