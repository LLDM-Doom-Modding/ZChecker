class ZCMainInfoPanel: ZCBaseInfoPanelPart {
	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_main";
		optionLabel = "General info (name, pointer, ...)";
		optionSubmenuName = "mcm_ZCheckerSubmenu_main";
	}

	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String info = ( thingfield.fieldPos + 1 ) .. ". ";

		if ( thingfield.actorType == IAT_Normal )
			info = info .. GREEN .. thing.GetClassName();
		else if ( thingfield.actorType == IAT_StateProvider )
			info = info .. DARKGREEN .. "Inv\c-: " .. GREEN .. thing.GetClassName();

		int displayTagsMode = CVar.GetCVar( "mcm_zchecker_infovar_maintags", players[ consoleplayer ] ).GetInt();
		bool displaySelfPointerMode = CVar.GetCVar( "mcm_zchecker_infovar_mainselfptr", players[ consoleplayer ] ).GetBool();

		if ( displayTagsMode == 2 || ( displayTagsMode == 1 && thing.GetTag() != thing.GetClassName() ) )
			info = info .. "\n" .. ORANGE .. "Tag" .. " \"" .. YELLOW .. thing.GetTag() .. ORANGE .. "\"";
		if ( displaySelfPointerMode )
			info = info .. "\n" .. BLACK .. "&self: " .. DARKGRAY .. thing;

		return info;
	}
} // of class ZCMainInfoPanel: ZCBaseInfoPanelPart {}

class ZCWorldPositionInfoPanel: ZCBaseInfoPanelPart {
	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_worldpos";
		optionLabel = "World positioning";
		optionSubmenuName = "mcm_ZCheckerSubmenu_worldpos";
	}

	enum EAlternativeButtonNames {
		FIRE = BT_ATTACK,
		ALTF = BT_ALTATTACK,
		RELD = BT_RELOAD,
		ZOOM = BT_ZOOM,
		USR1 = BT_USER1,
		USR2 = BT_USER2,
		USR3 = BT_USER3,
		USR4 = BT_USER4,

		USE  = BT_USE,
        JUMP = BT_JUMP,
        CRCH = BT_CROUCH,
		SPD  = BT_SPEED,
		STRF = BT_STRAFE,

		MOVR = BT_MOVERIGHT,
		MOVL = BT_MOVELEFT,
		MOVB = BT_BACK,
		MOVF = BT_FORWARD,
		MOVU = BT_MOVEUP,
		MOVD = BT_MOVEDOWN,
		TRNR = BT_RIGHT,
		TRNL = BT_LEFT,
		TRNU = BT_LOOKUP,
		TRND = BT_LOOKDOWN,

		T180 = BT_TURN180,
		SCOR = BT_SHOWSCORES,
	};

	int curPlayerButtons;

	private ui String Col( int testbutton ) {
		return ( curPlayerButtons & testbutton )? GREEN : BLACK;
	}

	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String outStr = "";

		outStr = "Tilt: (\cUa\c-" .. int( thing.angle ) .. ", \cUp\c-" ..
							int( thing.pitch ) .. ", \cUr\c-" ..
							int( thing.roll ) .. ");\n" .. TEAL ..
				"Pos: " .. ZCGlobal.squeezeVector3( thing.pos ) .. ";\n\c-" ..
				String.Format( "Vel: (%.2f, %.2f, %.2f)", thing.vel.x, thing.vel.y, thing.vel.z ) .. ";\n  (len " .. thing.vel.length() .. ");\n" .. TEAL ..
				String.Format( "Size: " .. N .. "r" .. TEAL .. "%.3f" .. N .. "/h" .. TEAL .. "%.3f" .. N .. ".\n", thing.radius, thing.height );


		bool showPlayerButtons = CVar.GetCVar( "mcm_zchecker_infovar_wposplayerbuttons", players[ consoleplayer ] ).GetBool();

		if ( thing is "PlayerPawn" && thing.player && showPlayerButtons ) {
			outStr.AppendFormat( DARKGRAY .. "Keys 0x" .. GRAY .. "%08x\n", thing.player.cmd.buttons );
			curPlayerButtons = thing.player.cmd.buttons;

/*
use.t..^...u..fr.af
jmp.b.<v>.ldr.rl.zm
crh...........u1234
spd.strf..t180.scor
*/

			outStr = outStr .. String.Format(
				"%suse %st   %s^    %su   %sfr %saf\n" ..
				"%sjmp %sb %s<%sv%s> %sl%sd%sr %srl %szm\n" ..
				"%scrh                  " .. TEXTCOLOR_DARKGRAY .. "u%s1%s2%s3%s4\n" ..
				"%sspd %sstrf  %st180 %sscor",
				Col( USE ) , Col( MOVU ), Col( MOVF ), Col( TRNU ), Col( FIRE ), Col( ALTF ),
				Col( JUMP ), Col( MOVD ), Col( MOVL ), Col( MOVB ), Col( MOVR ), Col( TRNL ), Col( TRND ), Col( TRNR ), Col( RELD ), Col( ZOOM ),
				Col( CRCH ), Col( USR1 ), Col( USR2 ), Col( USR3 ), Col( USR4 ),
				Col( SPD ) , Col( STRF ), Col( T180 ), Col( SCOR )
			) .. "\n";
		}

		return outStr;
	}
} // of class ZCWorldPositionInfoPanel: ZCBaseInfoPanelPart {}


// Not really done yet...

class ZCInvFieldNode {
	ZCInvFieldNode next, prev;

	Inventory inv;
	int visualTicks;		// Positive: green (inv. added); negative: red (inv. taken).
}

class ZCInvFieldData {
	ZCInvFieldNode head, tail;
	ZCInvFieldNode firstvisible;

	ZCInvFieldNode AddNode( Inventory inv ) {
		ZCInvFieldNode newnode = new( 'ZCInvFieldNode' );

		if ( !head ) {
			head = tail = newnode;
		} else {
			tail.next = newnode;
			newnode.prev = tail;
			tail = newnode;
		}

		newnode.inv = inv;
		newnode.visualTicks = 5;

		return newnode;
	}

	void UpdateByActorInventory( Actor owner ) {
		Inventory aitem = owner.inv;
		Inventory sitem = head.inv;

		while ( aitem ) {
			if ( aitem != sitem ) {
				// <...>
			}

			aitem = aitem.inv;
		}
	}
} // of class ZCInvFieldData {}

class ZCInventoryInfoPanel: ZCBaseInfoPanelPart {
	Array<ZCInvFieldData> prevInvs;

	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_inventory";
		optionLabel = "Inventory";

		for ( int i = 0; i < MaxTestee; i++ )
			prevInvs.Push( new( 'ZCInvFieldData' ) );
	}

	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String outStr = DARKGRAY .. "Inventory\c-: " .. GRAY;

		if ( thing is "Inventory" )
			return outStr .. "(Inventory itself).\n";

		Inventory item = thing.Inv;
		//ZCInvFieldData previnv = prevInvs[ thingfield.fieldPos ];

		uint cellsAmount = CVar.GetCVar( "mcm_zchecker_infovar_invamount", players[ consoleplayer ] ).GetInt();
		uint curAmount = 0;

		if ( item ) {
			//ZCheckerInvField cmpItem = Testee[ i ].inv;
			//ZCheckerInvField nextItem = cmpItem.Next;

			while ( item && curAmount < cellsAmount ) {
				//if ( nextItem && nextItem.type != item.Inv.GetClassName() ) {
				/*	ZCheckerInvField cmpNextItem = nextItem;
					bool found = false;
					while ( ( cmpNextItem = cmpNextItem.Next ) && !found ) {
						if ( cmpNextItem.type == item.Inv.GetClassName() )
							found = true;
					}
					if ( !found ) {}
				}
                */
				outStr = outStr .. "\n* " .. item.GetClassName() .. ( item.Amount - 1? " x" .. item.Amount : "" ) .. "\c[Gray];";
				item = item.Inv;

				/*if ( cmpItem.visualTicks > 0 )
					--cmpItem.visualTicks;
				else if ( cmpItem.visualTicks < 0 )
					++cmpItem.visualTicks;

				outStr = outStr .. "\n* " .. "\c[" .. ( cmpItem.visualTicks > 0? "Green" : ( cmpItem.visualTicks < 0? "Red" : "Gray" ) ) .. "]"
						.. item.GetClassName() .. ( item.Amount - 1? " x" .. item.Amount : "" ) .. "\c[Gray];";

				item = item.Inv;
				cmpItem = nextItem;
				nextItem = nextItem.Next;*/

				curAmount++;
			} // of while ( item && curAmount < cellsAmount ) {}

			if ( item && curAmount >= cellsAmount )
				outStr = outStr .. TEXTCOLOR_DARKGRAY .. " (...more)";

		} else {
			outStr = outStr .. "none";
		}

		return outStr .. ".\n";
	}
} // of class ZCInventoryInfoPanel: ZCBaseInfoPanelPart {}


class ZCStatesInfoData {
	State st;
}

class ZCStatesInfoPanel: ZCBaseInfoPanelPart {
	Array<ZCStatesInfoData> prevLogStates;
	int prevLogStateTics;

	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_states";
		optionLabel = "States";
		optionSubmenuName = "mcm_ZCheckerSubmenu_states";

		for ( int i = 0; i < MaxTestee; i++ )
			prevLogStates.Push( new( 'ZCStatesInfoData' ) );
	}

	protected String DecoratedState( State st ) {
		return
			String.Format( SAPPHIRE .. SpriteID( st.sprite ) .. LIGHTBLUE .. " %c " .. SAPPHIRE .. "%i\c-",
						st.Frame + 65, st.Tics );
	}

	protected void DoStatesLogging( Actor thing, ZCheckerField thingfield ) {
		State curState = thing.CurState;
		State st = curState;

		if ( thingfield.actorType == IAT_StateProvider ) {
			Actor weapOwner = getItemPlayerOwner( Inventory( thing ) );

			if ( weapOwner.player.psprites )
				curState = st = weapOwner.player.psprites.CurState;
		}

		State prevlogst = prevLogStates[ thingfield.fieldPos ].st;

		if ( prevlogst && prevlogst != st ) {
			String logstr = ( thingfield.fieldPos + 1 ) .. ". " .. DecoratedState( st );

			/*String logstr = String.Format( "%i. \c-" .. SAPPHIRE .. "%s " .. LIGHTBLUE .. "%c " .. SAPPHIRE .. "%i\c-",
							( thingfield.fieldPos + 1 ),
							( isWeapon? "" .. weapOwner.player.psprites.sprite : "" .. thing.Sprite ),
							st.Frame + 65, st.Tics );*/

			State nextlogst = prevlogst.NextState;
			bool zeroSkipped = ( nextlogst && nextlogst.tics == 0 );

			while ( nextlogst && nextlogst.tics == 0 )
				nextlogst = nextlogst.NextState;

			bool stateForced = ( nextlogst != st );

			if ( zeroSkipped || stateForced ) {
				logstr = logstr .. DARKGRAY .. " (";

				if ( zeroSkipped )
					logstr = logstr .. GRAY .. "zero frames" .. DARKGRAY .. " skipped" .. ( stateForced? "; " : "" );

				if ( stateForced ) {
					State prevnextst = prevlogst;

					if ( prevlogst.Tics == prevLogStateTics && prevlogst.NextState )
						prevnextst = prevlogst.NextState;

					logstr = logstr .. "forced from " .. prevLogStateTics .. "/" .. prevlogst.tics .. " tics, should have been \"" .. DecoratedState( prevnextst ) .. DARKGRAY .. "\"";
				}

				logstr = logstr .. ")";
			}

			ZCGlobal.ClearscopeLog( LL_Main | LL_NoDot, logstr );
		}

		prevLogStates[ thingfield.fieldPos ].st = st;
		prevLogStateTics = thing.Tics;
	} // of protected void DoStatesLogging( Actor thing, ZCheckerField thingfield ) {}


	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String outStr = "";
		State curState = thing.CurState;
		State st = curState;

		bool isWeapon = ( thingfield.actorType == IAT_StateProvider );
		PlayerPawn weapOwner = NULL;

		Array<State> prevstates;
		Array<String> prevstatesstr;
		uint statesAmount = CVar.GetCVar( "mcm_zchecker_infovar_statesamount", players[ consoleplayer ] ).GetInt();
		bool statesLogging = CVar.GetCVar( "mcm_zchecker_infovar_stateslogging", players[ consoleplayer ] ).GetBool();

		if ( isWeapon ) {
			weapOwner = getItemPlayerOwner( Inventory( thing ) );

			if ( weapOwner.player.psprites )
				curState = st = weapOwner.player.psprites.CurState;
		}

		if ( statesAmount == 0 )
			statesAmount = 0xFFFF;

		prevstates.Clear();
		prevstatesstr.Clear();
		outStr = outStr .. ( isWeapon? "PSprite states" : "States" );

		if ( statesLogging ) {
			outStr = outStr .. DARKGRAY .. " [" .. LIGHTBLUE .. "logging" .. DARKGRAY .. "]";
			DoStatesLogging( thing, thingfield );
		}

		outStr = outStr .. NORMAL .. ":\n";

		bool loopFound = false;
		int statesCnt = 0;

		do {
			prevstates.Push( st );
			prevstatesstr.Push( DecoratedState( st ) );

			st = st.NextState;

			int backloopStateIndex = prevstates.Find( st );

			if ( loopFound = ( backloopStateIndex != prevstates.Size() ) ) {
				// Difference the one-state loop (waiting) and the normal loop:
				if ( backloopStateIndex == statesCnt ) {
					prevstatesstr[ statesCnt ] = prevstatesstr[ statesCnt ] .. TEXTCOLOR_WHITE .. " (loop here)";
				} else {
					prevstatesstr[ backloopStateIndex ] = prevstatesstr[ backloopStateIndex ] .. TEXTCOLOR_WHITE .. " <<loop";
					prevstatesstr[ statesCnt ] = prevstatesstr[ statesCnt ] .. TEXTCOLOR_WHITE .. " ^ loop";
				}
			}

			statesCnt++;
		} while ( st && st != curState && statesCnt < statesAmount && !loopFound );


		st = curState;

		for ( int i = 0; i < prevstatesstr.Size(); i++ )
			outStr = outStr .. prevstatesstr[ i ] .. "\n";

		if ( statesAmount != 0xFFFF ) {
			while ( statesCnt < statesAmount ) {
				outStr = outStr .. "\n";
				statesCnt++;
			}
		}


		bool curstateExtraInfo = CVar.GetCVar( "mcm_zchecker_infovar_statecurinfo", players[ consoleplayer ] ).GetBool();

		if ( !curstateExtraInfo )
			return outStr;


		if ( st.Tics < 0 ) {
			outStr = outStr .. DARKGREEN .. "===== static =====";
		} else {
			int ticsbarLeft = 1;

			int curtics = ( isWeapon? weapOwner.player.psprites.Tics : thing.tics );

			if ( curtics > 1 )
				ticsbarLeft = int( 20 * ( curtics - 1 ) / ( st.Tics? st.Tics : 1 ) );

			if ( ticsbarLeft > 20 ) {
				outStr = outStr .. LIGHTBLUE .. "<<<" .. GRAY;
			} else {
				String ticbar = DARKGREEN;

				for ( int i = 0; i < 20 - ticsbarLeft; i++ )
					ticbar = ticbar .. "=";

				ticbar = ticbar .. ">" .. BLACK;

				for ( int i = 0; i < ticsbarLeft - 1; i++ )
					ticbar = ticbar .. "+";

				outStr = outStr .. ticbar .. DARKGRAY;
			}
		}

		if ( !isWeapon ) {
			outStr = outStr .. " (" .. thing.tics .. ")\c-\n" ..
				"  Flags: " ..
					( st.bFast? "\c[Fire]Fst\c- " : "" ) ..
					( st.bSlow? "\c[Fire]Slw\c- " : "" ) ..
					( st.bFullbright? "\c[Yellow]Lit\c- " : "" ) ..
					( st.bNoDelay? "\c[Sapphire]NoDelay\c- " : "" ) .. "\n"
				"  Flags 2:" ..
					( st.bSameFrame? "\c[Sapphire]SameFrm\c- " : "" ) ..
					( st.bCanRaise? "\c[Green]CanRaise\c- " : "" ) ..
					( st.bDehacked? "\c[Red]Deh\c- " : "" ) .. "\n" ..
				"  UseFlags: " .. st.UseFlags .. ", TicRange: " .. st.TicRange .. "; \n" ..
				"  Misc: " .. st.Misc1 .. "/" .. st.Misc2 .. "\n";

		} else if ( weapOwner.player.psprites ) { // Thanks to Il Str for crash reporting.
			PSprite pst = weapOwner.player.psprites;

			outStr = outStr .. " (" .. pst.tics .. ")\c-\n" ..
				"  Pos: " .. pst.x .. "/" .. pst.y .. "\n" ..
				"  Flags: " .. 
					( pst.bCVarFast? "\c[Green]Fast\c- " : "" ) ..
					( pst.processPending? "\c[Gray]Pend\c- " : "" ) .. "\n" ..
				"  Flags 2: " ..
					( pst.bFlip? "\c[Red]Flip\c- " : "" ) ..
					( pst.firstTic? "\c[Fire]1stTic\c- " : "" ) ..
					( pst.bAddWeapon? "\c[Yellow]AddWeap\c- " : "" ) ..
					( pst.bAddBob? "\c[Sapphire]AddBob\c- " : "" ) ..
					( pst.bPowDouble? "\c[Yellow]Pow2x\c- " : "" ) .. "\c-\n";
		}

		return outStr;
	}
} // of class ZCStatesInfoPanel: ZCBaseInfoPanelPart {}


class ZCSpritesInfoPanel: ZCBaseInfoPanelPart {
	// For the compatibility with older versions:
	enum EExtraRenderStyles {
		STYLE_Multiply = STYLE_AddShaded + 1,
		STYLE_InverseMultiply,
		STYLE_ColorBlend,
		STYLE_Source,
		STYLE_ColorAdd
	};

	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_visual";
		optionLabel = "Visual";
	}

	protected String GetRenderStyleStr( int style ) {
		String str = "";

		switch ( style ) {
			case STYLE_None: str = "None"; break;
			case STYLE_Normal: str = "Normal"; break;
			case STYLE_Fuzzy: str = "Fuzzy"; break;
			case STYLE_SoulTrans: str = "SoulTrans"; break;
			case STYLE_OptFuzzy: str = "OptFuzzy"; break;
			case STYLE_Stencil: str = "Stencil"; break;
			case STYLE_Translucent: str = "Translucent"; break;
			case STYLE_Add: str = "Add"; break;
			case STYLE_Shaded: str = "Shaded"; break;
			case STYLE_TranslucentStencil: str = "TranslucentStencil"; break;
			case STYLE_Shadow: str = "Shadow"; break;
			case STYLE_Subtract: str = "Subtract"; break;
			case STYLE_AddStencil: str = "AddStencil"; break;
			case STYLE_AddShaded: str = "AddShaded"; break;
			case STYLE_Multiply: str = "Multiply"; break;
			case STYLE_InverseMultiply: str = "InverseMultiply"; break;
			case STYLE_ColorBlend: str = "ColorBlend"; break;
			case STYLE_Source: str = BLACK .. "(Source)"; break;
			case STYLE_ColorAdd: str = "ColorAdd"; break;
			default: str = BLACK .. "(Unknown)"; break;
		}

		return str;
	}

	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String outStr = "";

		TextureID texture;
		bool textureBool;
		vector2 textureVec2;

		[ texture, textureBool, textureVec2 ] = thing.curstate.GetSpriteTexture( 1 );

		String textureName = TexMan.GetName( texture );

		int textureRealSizeX, textureRealSizeY;
		[ textureRealSizeX, textureRealSizeY ] = TexMan.GetSize( texture );

		vector2 textureSize = TexMan.GetScaledSize( texture );
		vector2 textureOffset = TexMan.GetScaledOffset( texture );

		outStr.AppendFormat( DARKGRAY .. "Alpha " .. LIGHTBLUE .. "%.3f" .. DARKGRAY .. ", render " .. GRAY .. "%s" .. DARKGRAY .. ".\n", thing.alpha, GetRenderStyleStr( thing.GetRenderStyle() ) );
		outStr.AppendFormat( DARKGRAY .. "Scale " .. DARKGREEN .. "(%+2.3f, %+2.3f)\n" .. DARKGRAY, thing.scale.x, thing.scale.y );
		outStr.AppendFormat( DARKGRAY .. "Size (" .. GRAY .. "%2.3f" .. BLUE .. "x" .. GRAY .. "%2.3f" .. DARKGRAY .. "); \nReal " .. textureRealSizeX .. BLUE .. "x" .. DARKGRAY .. textureRealSizeY .. " pixels.\n", textureSize.x, textureSize.y );
		outStr.AppendFormat( GRAY .. ( textureName.Mid( 5, 1 ) == "0"? "Faced" : "Rotor" ) .. DARKGRAY .. " ID %i, TranslID %i;\n", int( thing.sprite ), thing.Translation );
		outStr.AppendFormat( DARKGRAY .. "Txtr ofs " .. ZCGlobal.squeezeVector2dec2( textureOffset ) .. ";\nbool %i vec2 " .. ZCGlobal.squeezeVector2dec2( textureVec2 ) .. ".", textureBool );

		return outStr .. "\n";
	}
} // of class ZCSpritesInfoPanel: ZCBaseInfoPanelPart {}

class ZCMainInteractionInfoPanel: ZCBaseInfoPanelPart {
	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_maininteract";
		optionLabel = "Interaction properties";
	}

	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String info = "";

		if ( thingfield.actorType == IAT_Normal ) {
			info.AppendFormat( DARKRED .. "Health " .. RED .. "%i" .. DARKGRAY .. "/" .. RED .. "%i\n" .. DARKRED .. "(" .. RED .. "%.2f%%",
					thing.health, thing.GetSpawnHealth(), ( thing.GetSpawnHealth()? 100.0 * thing.health / double( thing.GetSpawnHealth() ) : 0.0 ) );

			if ( thing.bNODAMAGE )
				info = info .. " nodmg";
			if ( thing.bBUDDHA )
				info = info .. " buddha";
			if ( thing.bINVULNERABLE )
				info = info .. " invul";

			info.AppendFormat( DARKRED .. ")" .. DARKGRAY .. ".\n" .. DARKRED .. "Mass " .. thing.mass .. DARKGRAY .. ", " .. DARKRED .. "Grav %.3f" .. DARKGRAY .. "." , thing.gravity );
		}

		return info .. "\n";
	}
} // of class ZCMainInteractionInfoPanel: ZCBaseInfoPanelPart {}
