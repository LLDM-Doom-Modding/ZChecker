class ZCMainInfoPanel: ZCBaseInfoPanelPart {
	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_main";
		optionLabel = "General info (name, pointer, ...)";
		optionSubmenuName = "mcm_ZCheckerSubmenu_main";
	}

	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String info = ( thingfield.fieldPos + 1 ) .. ". ";

		if ( thingfield.actorType == IAT_Normal )
			info = info .. GREEN .. thing.GetClassName();
		else if ( thingfield.actorType == IAT_StateProvider )
			info = info .. DARKGREEN .. "Inv\c-: " .. GREEN .. thing.GetClassName();

		int displayTagsMode = CVar.GetCVar( "mcm_zchecker_infovar_maintags", players[ consoleplayer ] ).GetInt();
		bool displaySelfPointerMode = CVar.GetCVar( "mcm_zchecker_infovar_mainselfptr", players[ consoleplayer ] ).GetBool();

		if ( displayTagsMode == 2 || ( displayTagsMode == 1 && thing.GetTag() != thing.GetClassName() ) )
			info = info .. "\n" .. ORANGE .. "Tag" .. " \"" .. YELLOW .. thing.GetTag() .. ORANGE .. "\"";
		if ( displaySelfPointerMode )
			info = info .. "\n" .. BLACK .. "&self: " .. DARKGRAY .. thing;

		return info;
	}
} // of class ZCMainInfoPanel: ZCBaseInfoPanelPart {}

class ZCWorldPositionInfoPanel: ZCBaseInfoPanelPart {
	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_worldpos";
		optionLabel = "World positioning";
		optionSubmenuName = "mcm_ZCheckerSubmenu_worldpos";
	}

	enum EAlternativeButtonNames {
		FIRE = BT_ATTACK,
		ALTF = BT_ALTATTACK,
		RELD = BT_RELOAD,
		ZOOM = BT_ZOOM,
		USR1 = BT_USER1,
		USR2 = BT_USER2,
		USR3 = BT_USER3,
		USR4 = BT_USER4,

		USE  = BT_USE,
        JUMP = BT_JUMP,
        CRCH = BT_CROUCH,
		SPD  = BT_SPEED,
		STRF = BT_STRAFE,

		MOVR = BT_MOVERIGHT,
		MOVL = BT_MOVELEFT,
		MOVB = BT_BACK,
		MOVF = BT_FORWARD,
		MOVU = BT_MOVEUP,
		MOVD = BT_MOVEDOWN,
		TRNR = BT_RIGHT,
		TRNL = BT_LEFT,
		TRNU = BT_LOOKUP,
		TRND = BT_LOOKDOWN,

		T180 = BT_TURN180,
		SCOR = BT_SHOWSCORES,
	};

	int curPlayerButtons;

	private ui String Col( int testbutton ) {
		return ( curPlayerButtons & testbutton )? GREEN : BLACK;
	}

	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String outStr = "";

		outStr = "Tilt: (\cUa\c-" .. int( thing.angle ) .. ", \cUp\c-" ..
							int( thing.pitch ) .. ", \cUr\c-" ..
							int( thing.roll ) .. ");\n" .. TEAL ..
				"Pos: " .. ZCGlobal.squeezeVector3( thing.pos ) .. ";\n\c-" ..
				String.Format( "Vel: (%.2f, %.2f, %.2f)", thing.vel.x, thing.vel.y, thing.vel.z ) .. ";\n  (len " .. thing.vel.length() .. ");\n" .. TEAL ..
				String.Format( "Size: " .. N .. "r" .. TEAL .. "%.3f" .. N .. "/h" .. TEAL .. "%.3f" .. N .. ".\n", thing.radius, thing.height );


		bool showPlayerButtons = CVar.GetCVar( "mcm_zchecker_infovar_wposplayerbuttons", players[ consoleplayer ] ).GetBool();

		if ( thing is "PlayerPawn" && thing.player && showPlayerButtons ) {
			outStr.AppendFormat( DARKGRAY .. "Keys 0x" .. GRAY .. "%08x\n", thing.player.cmd.buttons );
			curPlayerButtons = thing.player.cmd.buttons;

/*
use.t..^...u..fr.af
jmp.b.<v>.ldr.rl.zm
crh...........u1234
spd.strf..t180.scor
*/

			outStr = outStr .. String.Format(
				"%suse %st   %s^    %su   %sfr %saf\n" ..
				"%sjmp %sb %s<%sv%s> %sl%sd%sr %srl %szm\n" ..
				"%scrh                  " .. TEXTCOLOR_DARKGRAY .. "u%s1%s2%s3%s4\n" ..
				"%sspd %sstrf  %st180 %sscor",
				Col( USE ) , Col( MOVU ), Col( MOVF ), Col( TRNU ), Col( FIRE ), Col( ALTF ),
				Col( JUMP ), Col( MOVD ), Col( MOVL ), Col( MOVB ), Col( MOVR ), Col( TRNL ), Col( TRND ), Col( TRNR ), Col( RELD ), Col( ZOOM ),
				Col( CRCH ), Col( USR1 ), Col( USR2 ), Col( USR3 ), Col( USR4 ),
				Col( SPD ) , Col( STRF ), Col( T180 ), Col( SCOR )
			) .. "\n";
		}

		return outStr;
	}
} // of class ZCWorldPositionInfoPanel: ZCBaseInfoPanelPart {}


// Not really done yet...

class ZCInvFieldNode {
	ZCInvFieldNode next, prev;

	Inventory inv;
	int visualTicks;		// Positive: green (inv. added); negative: red (inv. taken).
}

class ZCInvFieldData {
	ZCInvFieldNode head, tail;
	ZCInvFieldNode firstvisible;

	ZCInvFieldNode AddNode( Inventory inv ) {
		ZCInvFieldNode newnode = new( 'ZCInvFieldNode' );

		if ( !head ) {
			head = tail = newnode;
		} else {
			tail.next = newnode;
			newnode.prev = tail;
			tail = newnode;
		}

		newnode.inv = inv;
		newnode.visualTicks = 5;

		return newnode;
	}

	void UpdateByActorInventory( Actor owner ) {
		Inventory aitem = owner.inv;
		Inventory sitem = head.inv;

		while ( aitem ) {
			if ( aitem != sitem ) {
				// <...>
			}

			aitem = aitem.inv;
		}
	}
} // of class ZCInvFieldData {}

class ZCInventoryInfoPanel: ZCBaseInfoPanelPart {
	Array<ZCInvFieldData> prevInvs;

	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_inventory";
		optionLabel = "Inventory";

		for ( int i = 0; i < MaxTestee; i++ )
			prevInvs.Push( new( 'ZCInvFieldData' ) );
	}

	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String outStr = DARKGRAY .. "Inventory\c-: " .. GRAY;

		if ( thing is "Inventory" )
			return outStr .. "(Inventory itself).\n";

		Inventory item = thing.Inv;
		//ZCInvFieldData previnv = prevInvs[ thingfield.fieldPos ];

		uint cellsAmount = CVar.GetCVar( "mcm_zchecker_infovar_invamount", players[ consoleplayer ] ).GetInt();
		uint curAmount = 0;

		if ( item ) {
			//ZCheckerInvField cmpItem = Testee[ i ].inv;
			//ZCheckerInvField nextItem = cmpItem.Next;

			while ( item && curAmount < cellsAmount ) {
				//if ( nextItem && nextItem.type != item.Inv.GetClassName() ) {
				/*	ZCheckerInvField cmpNextItem = nextItem;
					bool found = false;
					while ( ( cmpNextItem = cmpNextItem.Next ) && !found ) {
						if ( cmpNextItem.type == item.Inv.GetClassName() )
							found = true;
					}
					if ( !found ) {}
				}
                */
				outStr = outStr .. "\n* " .. item.GetClassName() .. ( item.Amount - 1? " x" .. item.Amount : "" ) .. "\c[Gray];";
				item = item.Inv;

				/*if ( cmpItem.visualTicks > 0 )
					--cmpItem.visualTicks;
				else if ( cmpItem.visualTicks < 0 )
					++cmpItem.visualTicks;

				outStr = outStr .. "\n* " .. "\c[" .. ( cmpItem.visualTicks > 0? "Green" : ( cmpItem.visualTicks < 0? "Red" : "Gray" ) ) .. "]"
						.. item.GetClassName() .. ( item.Amount - 1? " x" .. item.Amount : "" ) .. "\c[Gray];";

				item = item.Inv;
				cmpItem = nextItem;
				nextItem = nextItem.Next;*/

				curAmount++;
			} // of while ( item && curAmount < cellsAmount ) {}

			if ( item && curAmount >= cellsAmount )
				outStr = outStr .. TEXTCOLOR_DARKGRAY .. " (...more)";

		} else {
			outStr = outStr .. "none";
		}

		return outStr .. ".\n";
	}
} // of class ZCInventoryInfoPanel: ZCBaseInfoPanelPart {}


class ZCStatesInfoData {
	State st;
}

class ZCStatesInfoPanel: ZCBaseInfoPanelPart {
	Array<ZCStatesInfoData> prevLogStates;
	int prevLogStateTics;

	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_states";
		optionLabel = "States";
		optionSubmenuName = "mcm_ZCheckerSubmenu_states";

		for ( int i = 0; i < MaxTestee; i++ )
			prevLogStates.Push( new( 'ZCStatesInfoData' ) );
	}

	protected String DecoratedState( State st ) {
		return
			String.Format( SAPPHIRE .. SpriteID( st.sprite ) .. LIGHTBLUE .. " %c " .. SAPPHIRE .. "%i\c-",
						st.Frame + 65, st.Tics );
	}

	protected void DoStatesLogging( Actor thing, ZCheckerField thingfield ) {
		State curState = thing.CurState;
		State st = curState;

		if ( thingfield.actorType == IAT_StateProvider ) {
			Actor weapOwner = getItemPlayerOwner( Inventory( thing ) );

			if ( weapOwner.player.psprites )
				curState = st = weapOwner.player.psprites.CurState;
		}

		State prevlogst = prevLogStates[ thingfield.fieldPos ].st;

		if ( prevlogst && prevlogst != st ) {
			String logstr = ( thingfield.fieldPos + 1 ) .. ". " .. DecoratedState( st );

			/*String logstr = String.Format( "%i. \c-" .. SAPPHIRE .. "%s " .. LIGHTBLUE .. "%c " .. SAPPHIRE .. "%i\c-",
							( thingfield.fieldPos + 1 ),
							( isWeapon? "" .. weapOwner.player.psprites.sprite : "" .. thing.Sprite ),
							st.Frame + 65, st.Tics );*/

			State nextlogst = prevlogst.NextState;
			bool zeroSkipped = ( nextlogst && nextlogst.tics == 0 );

			while ( nextlogst && nextlogst.tics == 0 )
				nextlogst = nextlogst.NextState;

			bool stateForced = ( nextlogst != st );

			if ( zeroSkipped || stateForced ) {
				logstr = logstr .. DARKGRAY .. " (";

				if ( zeroSkipped )
					logstr = logstr .. GRAY .. "zero frames" .. DARKGRAY .. " skipped" .. ( stateForced? "; " : "" );

				if ( stateForced ) {
					State prevnextst = prevlogst;

					if ( prevlogst.Tics == prevLogStateTics && prevlogst.NextState )
						prevnextst = prevlogst.NextState;

					logstr = logstr .. "forced from " .. prevLogStateTics .. "/" .. prevlogst.tics .. " tics, should have been \"" .. DecoratedState( prevnextst ) .. DARKGRAY .. "\"";
				}

				logstr = logstr .. ")";
			}

			ZCGlobal.ClearscopeLog( LL_Main | LL_NoDot, logstr );
		}

		prevLogStates[ thingfield.fieldPos ].st = st;
		prevLogStateTics = thing.Tics;
	} // of protected void DoStatesLogging( Actor thing, ZCheckerField thingfield ) {}


	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String outStr = "";
		State curState = thing.CurState;
		State st = curState;

		bool isWeapon = ( thingfield.actorType == IAT_StateProvider );
		PlayerPawn weapOwner = NULL;

		Array<State> prevstates;
		Array<String> prevstatesstr;
		uint statesAmount = CVar.GetCVar( "mcm_zchecker_infovar_statesamount", players[ consoleplayer ] ).GetInt();
		bool statesLogging = CVar.GetCVar( "mcm_zchecker_infovar_stateslogging", players[ consoleplayer ] ).GetBool();

		if ( isWeapon ) {
			weapOwner = getItemPlayerOwner( Inventory( thing ) );

			if ( weapOwner.player.psprites )
				curState = st = weapOwner.player.psprites.CurState;
		}

		if ( statesAmount == 0 )
			statesAmount = 0xFFFF;

		prevstates.Clear();
		prevstatesstr.Clear();
		outStr = outStr .. ( isWeapon? "PSprite states" : "States" );

		if ( statesLogging ) {
			outStr = outStr .. DARKGRAY .. " [" .. LIGHTBLUE .. "logging" .. DARKGRAY .. "]";
			DoStatesLogging( thing, thingfield );
		}

		outStr = outStr .. NORMAL .. ":\n";

		bool loopFound = false;
		int statesCnt = 0;

		do {
			prevstates.Push( st );
			prevstatesstr.Push( DecoratedState( st ) );

			st = st.NextState;

			int backloopStateIndex = prevstates.Find( st );

			if ( loopFound = ( backloopStateIndex != prevstates.Size() ) ) {
				// Difference the one-state loop (waiting) and the normal loop:
				if ( backloopStateIndex == statesCnt ) {
					prevstatesstr[ statesCnt ] = prevstatesstr[ statesCnt ] .. TEXTCOLOR_WHITE .. " (loop here)";
				} else {
					prevstatesstr[ backloopStateIndex ] = prevstatesstr[ backloopStateIndex ] .. TEXTCOLOR_WHITE .. " <<loop";
					prevstatesstr[ statesCnt ] = prevstatesstr[ statesCnt ] .. TEXTCOLOR_WHITE .. " ^ loop";
				}
			}

			statesCnt++;
		} while ( st && st != curState && statesCnt < statesAmount && !loopFound );


		st = curState;

		for ( int i = 0; i < prevstatesstr.Size(); i++ )
			outStr = outStr .. prevstatesstr[ i ] .. "\n";

		if ( statesAmount != 0xFFFF ) {
			while ( statesCnt < statesAmount ) {
				outStr = outStr .. "\n";
				statesCnt++;
			}
		}


		if ( st.Tics < 0 ) {
			outStr = outStr .. DARKGREEN .. "===== static =====";
		} else {
			int ticsbarLeft = 1;

			int curtics = ( isWeapon? weapOwner.player.psprites.Tics : thing.tics );

			if ( curtics > 1 )
				ticsbarLeft = int( 20 * ( curtics - 1 ) / ( st.Tics? st.Tics : 1 ) );

			if ( ticsbarLeft > 20 ) {
				outStr = outStr .. LIGHTBLUE .. "<<<" .. GRAY;
			} else {
				String ticbar = DARKGREEN;

				for ( int i = 0; i < 20 - ticsbarLeft; i++ )
					ticbar = ticbar .. "=";

				ticbar = ticbar .. ">" .. BLACK;

				for ( int i = 0; i < ticsbarLeft - 1; i++ )
					ticbar = ticbar .. "+";

				outStr = outStr .. ticbar .. DARKGRAY;
			}
		}

		if ( !isWeapon ) {
			outStr = outStr .. " (" .. thing.tics .. ")\c-\n" ..
				"  Flags: " ..
					( st.bFast? "\c[Fire]Fst\c- " : "" ) ..
					( st.bSlow? "\c[Fire]Slw\c- " : "" ) ..
					( st.bFullbright? "\c[Yellow]Lit\c- " : "" ) ..
					( st.bNoDelay? "\c[Sapphire]NoDelay\c- " : "" ) .. "\n"
				"  Flags 2:" ..
					( st.bSameFrame? "\c[Sapphire]SameFrm\c- " : "" ) ..
					( st.bCanRaise? "\c[Green]CanRaise\c- " : "" ) ..
					( st.bDehacked? "\c[Red]Deh\c- " : "" ) .. "\n" ..
				"  UseFlags: " .. st.UseFlags .. ", TicRange: " .. st.TicRange .. "; \n" ..
				"  Misc: " .. st.Misc1 .. "/" .. st.Misc2 .. "\n";

		} else if ( weapOwner.player.psprites ) { // Thanks to Il Str for crash reporting.
			PSprite pst = weapOwner.player.psprites;

			outStr = outStr .. " (" .. pst.tics .. ")\c-\n" ..
				"  Pos: " .. pst.x .. "/" .. pst.y .. "\n" ..
				"  Flags: " .. 
					( pst.bCVarFast? "\c[Green]Fast\c- " : "" ) ..
					( pst.processPending? "\c[Gray]Pend\c- " : "" ) .. "\n" ..
				"  Flags 2: " ..
					( pst.bFlip? "\c[Red]Flip\c- " : "" ) ..
					( pst.firstTic? "\c[Fire]1stTic\c- " : "" ) ..
					( pst.bAddWeapon? "\c[Yellow]AddWeap\c- " : "" ) ..
					( pst.bAddBob? "\c[Sapphire]AddBob\c- " : "" ) ..
					( pst.bPowDouble? "\c[Yellow]Pow2x\c- " : "" ) .. "\c-\n";
		}

		return outStr;
	}
} // of class ZCStatesInfoPanel: ZCBaseInfoPanelPart {}


class ZCSpritesInfoPanel: ZCBaseInfoPanelPart {
	// For the compatibility with older versions:
	enum EExtraRenderStyles {
		STYLE_Multiply = STYLE_AddShaded + 1,
		STYLE_InverseMultiply,
		STYLE_ColorBlend,
		STYLE_Source,
		STYLE_ColorAdd
	};

	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_visual";
		optionLabel = "Visual";
	}

	protected String GetRenderStyleStr( int style ) {
		String str = "";

		switch ( style ) {
			case STYLE_None: str = "None"; break;
			case STYLE_Normal: str = "Normal"; break;
			case STYLE_Fuzzy: str = "Fuzzy"; break;
			case STYLE_SoulTrans: str = "SoulTrans"; break;
			case STYLE_OptFuzzy: str = "OptFuzzy"; break;
			case STYLE_Stencil: str = "Stencil"; break;
			case STYLE_Translucent: str = "Translucent"; break;
			case STYLE_Add: str = "Add"; break;
			case STYLE_Shaded: str = "Shaded"; break;
			case STYLE_TranslucentStencil: str = "TranslucentStencil"; break;
			case STYLE_Shadow: str = "Shadow"; break;
			case STYLE_Subtract: str = "Subtract"; break;
			case STYLE_AddStencil: str = "AddStencil"; break;
			case STYLE_AddShaded: str = "AddShaded"; break;
			case STYLE_Multiply: str = "Multiply"; break;
			case STYLE_InverseMultiply: str = "InverseMultiply"; break;
			case STYLE_ColorBlend: str = "ColorBlend"; break;
			case STYLE_Source: str = BLACK .. "(Source)"; break;
			case STYLE_ColorAdd: str = "ColorAdd"; break;
			default: str = BLACK .. "(Unknown)"; break;
		}

		return str;
	}

	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String outStr = "";

		TextureID texture;
		bool textureBool;
		vector2 textureVec2;

		[ texture, textureBool, textureVec2 ] = thing.curstate.GetSpriteTexture( 1 );

		String textureName = TexMan.GetName( texture );

		int textureRealSizeX, textureRealSizeY;
		[ textureRealSizeX, textureRealSizeY ] = TexMan.GetSize( texture );

		vector2 textureSize = TexMan.GetScaledSize( texture );
		vector2 textureOffset = TexMan.GetScaledOffset( texture );

		outStr.AppendFormat( DARKGRAY .. "Alpha " .. LIGHTBLUE .. "%.3f" .. DARKGRAY .. ", render " .. GRAY .. "%s" .. DARKGRAY .. ".\n", thing.alpha, GetRenderStyleStr( thing.GetRenderStyle() ) );
		outStr.AppendFormat( DARKGRAY .. "Scale " .. DARKGREEN .. "(%+2.3f, %+2.3f)\n" .. DARKGRAY, thing.scale.x, thing.scale.y );
		outStr.AppendFormat( DARKGRAY .. "Size (" .. GRAY .. "%2.3f" .. BLUE .. "x" .. GRAY .. "%2.3f" .. DARKGRAY .. "); \nReal " .. textureRealSizeX .. BLUE .. "x" .. DARKGRAY .. textureRealSizeY .. " pixels.\n", textureSize.x, textureSize.y );
		outStr.AppendFormat( GRAY .. ( textureName.Mid( 5, 1 ) == "0"? "Faced" : "Rotor" ) .. DARKGRAY .. " ID %i, TranslID %i;\n", int( thing.sprite ), thing.Translation );
		outStr.AppendFormat( DARKGRAY .. "Txtr ofs " .. ZCGlobal.squeezeVector2dec2( textureOffset ) .. ";\nbool %i vec2 " .. ZCGlobal.squeezeVector2dec2( textureVec2 ) .. ".", textureBool );

		return outStr .. "\n";
	}
} // of class ZCSpritesInfoPanel: ZCBaseInfoPanelPart {}

class ZCMainInteractionInfoPanel: ZCBaseInfoPanelPart {
	override void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_maininteract";
		optionLabel = "Interaction properties";
	}

	override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		String info = "";

		if ( thingfield.actorType == IAT_Normal ) {
			info.AppendFormat( DARKRED .. "Health " .. RED .. "%i" .. DARKGRAY .. "/" .. RED .. "%i\n" .. DARKRED .. "(" .. RED .. "%.2f%%",
					thing.health, thing.GetSpawnHealth(), ( thing.GetSpawnHealth()? 100.0 * thing.health / double( thing.GetSpawnHealth() ) : 0.0 ) );

			if ( thing.bNODAMAGE )
				info = info .. " nodmg";
			if ( thing.bBUDDHA )
				info = info .. " buddha";
			if ( thing.bINVULNERABLE )
				info = info .. " invul";

			info.AppendFormat( DARKRED .. ")" .. DARKGRAY .. ".\n" .. DARKRED .. "Mass " .. thing.mass .. DARKGRAY .. ", " .. DARKRED .. "Grav %.3f" .. DARKGRAY .. "." , thing.gravity );
		}

		return info .. "\n";
	}
} // of class ZCMainInteractionInfoPanel: ZCBaseInfoPanelPart {}

class ZCSectorsGeometryPanel: ZCBaseInfoPanelPart_PlayScope {
	String outinfo;
	Actor infothing;

	bool printSecLights, printSecTextures, printSecOther, printSecPortal, printSecTerrain;
	int printSecFlagsMode, printSecHeightsMode;

	transient Font flagsfont;

	override void OnCreate_play( void ) {
		optionCVarName = "mcm_zchecker_info_geomsectors";
		optionLabel = "Actor sectors";
		optionSubmenuName = "mcm_ZCheckerSubmenu_geomsectors";

		printSecLights = printSecTextures = printSecOther = printSecPortal = printSecTerrain = false;
		flagsfont = Font.FindFont( "smallfont" );
	}

/*
	native Sector CurSector;
	native Sector floorsector;
	native Sector ceilingsector;

	native double CeilingZ;
	native double FloorZ;
	native TextureID floorpic;
	native TextureID ceilingpic;

	native readonly int WaterLevel;
	native double FloorClip;

	native Line BlockingLine;

	native int floorterrain;
	native TerrainDef GetFloorTerrain();

struct TerrainDef native {
	native Name TerrainName;
	native int Splash;
	native int DamageAmount;
	native Name DamageMOD;
	native int DamageTimeMask;
	native double FootClip;
	native float StepVolume;
	native int WalkStepTics;
	native int RunStepTics;
	native Sound LeftStepSound;
	native Sound RightStepSound;
	native bool IsLiquid;
	native bool AllowProtection;
	native double Friction;
	native double MoveFactor;
};*/

	Sector tempInfoSec;
	String tempFlagsStr;

	protected void addSecFlag( uint flag, String flagname, String setcolor = GREEN ) {
		tempFlagsStr = tempFlagsStr .. ( ( tempInfoSec.flags & flag )? setcolor : BLACK ) .. flagname .. " ";
	}

	protected void addSecFlag2( uint flag2, String flagname, String setcolor = GREEN ) {
		tempFlagsStr = tempFlagsStr .. ( ( tempInfoSec.moreflags & flag2 )? setcolor : BLACK ) .. flagname .. " ";
	}

	protected String getTextureInfo( int texpos ) {
		String outstr = "\"" .. CREAM .. tempInfoSec.GetTexture( texpos ) .. DARKGRAY .. "\"";

		vector2 texofs = ( tempInfoSec.GetXOffset( texpos ), tempInfoSec.GetYOffset( texpos ) );
		vector2 texscale = ( tempInfoSec.GetXScale( texpos ), tempInfoSec.GetYScale( texpos ) );
		double texangle = tempInfoSec.GetAngle( texpos );

		//if ( texofs.Length() != 0.0 || texscale.x != 1.0 || texscale.y != 1.0 || texangle != 0.0 )
			outstr.AppendFormat( "\n    mul (" .. OLIVE .. "%.2f,%.2f" .. DARKGRAY .. ") +(" .. PURPLE .. "%.2f,%.2f" .. DARKGRAY .. ");" ..
								"\n    angle " .. DARKBROWN .. "%.2f" .. DARKGRAY, texscale.x, texscale.y, texofs.x, texofs.y, texangle );

		return outstr;
	}

	protected void addSectorInfo( Sector sec, String sectorName = "" ) {
		if ( !sec ) {
			outinfo.AppendFormat( BLACK .. "(No%s%s sector)\n" .. GRAY, ( sectorName == ""? "" : " " ), sectorName .. BLACK );
			return;
		}

		String info = DARKGRAY .. "Sector " .. GRAY .. sec.Index() .. DARKGRAY .. ( sectorName == ""? ":" : " (" .. sectorName .. DARKGRAY .. "):\n" );
		tempInfoSec = sec;

		switch ( printSecHeightsMode ) {
			case 1:
				info.AppendFormat( "  Flr " .. DARKGREEN .. "%i" .. DARKGRAY .. "/Ceil " .. TAN .. "%i" .. DARKGRAY .. ".\n",
									int( sec.floorplane.d * sec.floorplane.negiC ), int( sec.ceilingplane.d * sec.ceilingplane.negiC ) );
				break;
			case 2:
				double floorz = sec.floorplane.d * sec.floorplane.negiC;
				double ceilingz = sec.ceilingplane.d * sec.ceilingplane.negiC;

				info.AppendFormat( "  Ceil " .. TAN .. "%-4i" .. DARKGRAY .. " (head delta " .. TAN.. "%i" .. DARKGRAY .. ");\n"
								.. "  Flr " .. DARKGREEN .. "%-4i" .. DARKGRAY .. " (feet delta " .. DARKGREEN.. "%i" .. DARKGRAY .. ").\n",
								int( ceilingz ), int( ceilingz - infothing.pos.z - infothing.height ), int( floorz ), int( infothing.pos.z - floorz ) );
				break;
			case 0:
			default:
				break;
		}

		if ( printSecLights ) {
			int floorlight = sec.GetFloorLight();
			int ceillight = sec.GetCeilingLight();

			if ( floorlight == sec.lightlevel && floorlight == ceillight )
				info = info .. "  Light level " .. WHITE .. sec.lightlevel .. DARKGRAY .. ".\n";
			else
				info = info .. "  Light " .. WHITE .. sec.lightlevel .. DARKGRAY .. ", flr " .. GRAY .. floorlight .. DARKGRAY .. ", ceil " .. GRAY .. ceillight .. ".\n";
		}

		if ( printSecTextures ) {
			info = info .. "  Tex:" .. TAN .. "C " .. getTextureInfo( Sector.ceiling ) ..
						";\n  Tex:" .. DARKGREEN .. "F " .. getTextureInfo( Sector.floor ) .. ".\n";
		}

/*
SECF_SILENT			= 1,	// actors in sector make no noise
SECF_NOFALLINGDAMAGE= 2,	// No falling damage in this sector
SECF_FLOORDROP		= 4,	// all actors standing on this floor will remain on it when it lowers very fast.
SECF_NORESPAWN		= 8,	// players can not respawn in this sector
SECF_FRICTION		= 16,	// sector has friction enabled
SECF_PUSH			= 32,	// pushers enabled
SECF_SILENTMOVE		= 64,	// Sector movement makes mo sound (Eternity got this so this may be useful for an extended cross-port standard.) 
SECF_DMGTERRAINFX	= 128,	// spawns terrain splash when inflicting damage
SECF_ENDGODMODE		= 256,	// getting damaged by this sector ends god mode
SECF_ENDLEVEL		= 512,	// ends level when health goes below 10
SECF_HAZARD			= 1024,	// Change to Strife's delayed damage handling.

SECF_WASSECRET		= 1 << 30,	// a secret that was discovered
SECF_SECRET			= 1 << 31,	// a secret sector

SECMF_FAKEFLOORONLY	= 2,	// when used as heightsec in R_FakeFlat, only copies floor
SECMF_CLIPFAKEPLANES = 4,	// as a heightsec, clip planes to target sector's planes
SECMF_NOFAKELIGHT	= 8,	// heightsec does not change lighting
SECMF_IGNOREHEIGHTSEC= 16,	// heightsec is only for triggering sector actions
SECMF_UNDERWATER		= 32,	// sector is underwater
SECMF_FORCEDUNDERWATER= 64,	// sector is forced to be underwater
SECMF_UNDERWATERMASK	= 32+64,
SECMF_DRAWN			= 128,	// sector has been drawn at least once
SECMF_HIDDEN			= 256,	// Do not draw on textured automap
*/

		tempFlagsStr = "";

		switch ( printSecFlagsMode ) {
			case 1: // Short flag names.
				addSecFlag( Sector.SECF_SILENT, "quiet" );
				addSecFlag( Sector.SECF_NOFALLINGDAMAGE, "xfaldmg" );
				addSecFlag( Sector.SECF_FLOORDROP, "liftdrp" );
				addSecFlag( Sector.SECF_NORESPAWN, "xrespw" );
				addSecFlag( Sector.SECF_FRICTION, "frict" );
				addSecFlag( Sector.SECF_PUSH, "push" );
				addSecFlag( Sector.SECF_SILENTMOVE, "mvquiet" );
				addSecFlag( Sector.SECF_DMGTERRAINFX, "terrafx" );
				addSecFlag( Sector.SECF_ENDGODMODE, "xiddqd" );
				addSecFlag( Sector.SECF_ENDLEVEL, "endlvl" );
				addSecFlag( Sector.SECF_HAZARD, "StrfHzr" );
				addSecFlag( Sector.SECF_WASSECRET, "wassecr" );
				addSecFlag( Sector.SECF_SECRET, "newsecr" );
				addSecFlag2( Sector.SECMF_FAKEFLOORONLY, "fakeflr" );
				addSecFlag2( Sector.SECMF_CLIPFAKEPLANES, "clipfake" );
				addSecFlag2( Sector.SECMF_NOFAKELIGHT, "xfakelit" );
				addSecFlag2( Sector.SECMF_IGNOREHEIGHTSEC, "nofake" );
				addSecFlag2( Sector.SECMF_UNDERWATER, "water", SAPPHIRE );
				addSecFlag2( Sector.SECMF_FORCEDUNDERWATER, "watrforc", CYAN );
				addSecFlag2( Sector.SECMF_DRAWN, "drawn" );
				addSecFlag2( Sector.SECMF_HIDDEN, "hidden" );
				break;
			case 2: // Long flag names.
				break;
			case 0:
			default:
				break;
		}

		if ( tempFlagsStr != "" ) {
			BrokenLines lines = flagsfont.BreakLines( tempFlagsStr, flagsfont.GetCharWidth( 0x61 ) * 30 );

			for ( int i = 0; i < lines.Count(); i++ )
				info = info .. "  " .. lines.StringAt( i ) .. "\n";
		}

		outinfo = outinfo .. info;
	} // of protected void addSectorInfo( Sector sec, String sectorName = "" ) {}

	override String GetInfo_play( Actor thing, ZCheckerField thingfield ) {
		if ( thingfield.actorType != IAT_Normal )
			return "";

		outinfo = "";
		infothing = thing;

		bool differFloorCeilSectors = CVar.GetCVar( "mcm_zchecker_infovar_geomsecdiffers", players[ consoleplayer ] ).GetBool();

		printSecHeightsMode = CVar.GetCVar( "mcm_zchecker_infovar_geomsecheights", players[ consoleplayer ] ).GetInt();
		printSecLights = CVar.GetCVar( "mcm_zchecker_infovar_geomseclight", players[ consoleplayer ] ).GetBool();
		printSecFlagsMode = CVar.GetCVar( "mcm_zchecker_infovar_geomsecflags", players[ consoleplayer ] ).GetInt();
		printSecTextures = CVar.GetCVar( "mcm_zchecker_infovar_geomsectex", players[ consoleplayer ] ).GetBool();
		printSecOther = CVar.GetCVar( "mcm_zchecker_infovar_geomsecother", players[ consoleplayer ] ).GetBool();
		printSecPortal = CVar.GetCVar( "mcm_zchecker_infovar_geomsecportal", players[ consoleplayer ] ).GetBool();
		printSecTerrain = CVar.GetCVar( "mcm_zchecker_infovar_geomsecterrain", players[ consoleplayer ] ).GetBool();

		if ( differFloorCeilSectors ) {
			if ( thing.cursector != thing.floorsector && thing.cursector != thing.ceilingsector ) {
				addSectorInfo( thing.ceilingsector, "ceiling" );
				addSectorInfo( thing.floorsector, "floor" );
				addSectorInfo( thing.cursector, YELLOW .. "actual" );
			} else {
				String header = "ceil";
				if ( thing.cursector == thing.ceilingsector )
					header = header .. ", " .. YELLOW .. "cur";

				addSectorInfo( thing.ceilingsector, header );

				header = "floor";
				if ( thing.cursector == thing.floorsector )
					header = header .. ", " .. YELLOW .. "cur";

				addSectorInfo( thing.floorsector, header );
			}
		} else {
			String cursecname = "";

			if ( thing.cursector == thing.floorsector ) {
				cursecname = YELLOW .. ( thing.cursector == thing.ceilingsector? " f/c" : " floor" );
			} else if ( thing.cursector == thing.ceilingsector ) {
				cursecname = YELLOW .. " ceil";
			}

			addSectorInfo( thing.cursector, "actual" .. cursecname );
		} // of else, of if ( differFloorCeilSectors ) {}

		return outinfo .. "\n";
	}
} // of class ZCSectorsGeometryPanel: ZCBaseInfoPanelPart {}

class ZCLinesGeometryPanel: ZCBaseInfoPanelPart_PlayScope {
	override void OnCreate_play( void ) {
		optionCVarName = "mcm_zchecker_info_geomlines";
		optionLabel = "Actor lines";
		optionSubmenuName = "mcm_ZCheckerSubmenu_geomlines";
	}

	override String GetInfo_play( Actor thing, ZCheckerField thingfield ) {
		return "(Linedefs geometry).";
	}
} // of class ZCLinesGeometryPanel: ZCBaseInfoPanelPart {}
