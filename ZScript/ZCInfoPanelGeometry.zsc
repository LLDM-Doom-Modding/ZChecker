class ZCSectorsGeometryPanel: ZCBaseInfoPanelPart_PlayScope {
	String outinfo;
	Actor infothing;

	bool printSecLights, printSecTextures, printSecDamage, printSecOther, printSecPortal, printSecTerrain;
	int printSecFlagsMode, printSecHeightsMode;

	override void OnCreate_play( void ) {
		optionCVarName = "mcm_zchecker_info_geomsectors";
		optionLabel = "Actor sectors";
		optionSubmenuName = "mcm_ZCheckerSubmenu_geomsectors";

		printSecLights = printSecTextures = printSecOther = printSecPortal = printSecTerrain = false;
	}

/*
	native Sector CurSector;
	native Sector floorsector;
	native Sector ceilingsector;

	native double CeilingZ;
	native double FloorZ;
	native TextureID floorpic;
	native TextureID ceilingpic;

	native readonly int WaterLevel;
	native double FloorClip;

	native Line BlockingLine;
*/

	Sector tempInfoSec;
	String tempFlagsStr;
	uint secFlagsAmount;

	protected void addSecFlag( uint flag, String flagname ) {
		String flagcolor = ( ( ( secFlagsAmount / 5 ) & 1 )
						? ( ( tempInfoSec.flags & flag )? DARKGREEN : BLACK )
						: ( ( tempInfoSec.flags & flag )? GREEN : DARKGRAY ) );

		tempFlagsStr = tempFlagsStr .. flagcolor .. flagname .. " ";
		secFlagsAmount++;
	}

	protected void addSecFlag2( uint flag2, String flagname ) {
		String flagcolor = ( ( ( secFlagsAmount / 5 ) & 1 )
						? ( ( tempInfoSec.moreflags & flag2 )? DARKGREEN : BLACK )
						: ( ( tempInfoSec.moreflags & flag2 )? GREEN : DARKGRAY ) );

		tempFlagsStr = tempFlagsStr .. flagcolor .. flagname .. " ";
		secFlagsAmount++;
	}

	protected String getTextureInfo( int texpos ) {
		String outstr = "\"" .. CREAM .. tempInfoSec.GetTexture( texpos ) .. DARKGRAY .. "\"";

		vector2 texofs = ( tempInfoSec.GetXOffset( texpos ), tempInfoSec.GetYOffset( texpos ) );
		vector2 texscale = ( tempInfoSec.GetXScale( texpos ), tempInfoSec.GetYScale( texpos ) );
		double texangle = tempInfoSec.GetAngle( texpos );

		//if ( texofs.Length() != 0.0 || texscale.x != 1.0 || texscale.y != 1.0 || texangle != 0.0 )
			outstr.AppendFormat( BLACK .. "\n    scale" .. DARKGRAY .. "(" .. OLIVE .. "%.2f,%.2f" .. DARKGRAY .. ") " .. BLACK .. "+" .. DARKGRAY .. "(" .. PURPLE .. "%.2f,%.2f" .. DARKGRAY .. ");" ..
								 BLACK .. "\n    angle " .. DARKBROWN .. "%.2f" .. DARKGRAY, texscale.x, texscale.y, texofs.x, texofs.y, texangle );

		return outstr;
	}

	protected void addSectorInfo( Sector sec, String sectorName = "", bool fromnewline = false ) {
		if ( !sec ) {
			outinfo.AppendFormat( BLACK .. "\n(No%s%s sector)" .. GRAY, ( sectorName == ""? "" : " " ), sectorName .. BLACK );
			return;
		}

		bool noextrainfo = true;

		String info = ( fromnewline? "\n" : "" ) .. DARKGRAY .. "Sector " .. GRAY .. sec.Index() .. DARKGRAY .. ( sectorName == ""? ":" : " (" .. sectorName .. DARKGRAY .. "):" );
		tempInfoSec = sec;

		switch ( printSecHeightsMode ) {
			case 1:
				info.AppendFormat( "\n  Flr " .. DARKGREEN .. "%i" .. DARKGRAY .. "/Ceil " .. TAN .. "%i" .. DARKGRAY .. ".",
									int( sec.floorplane.d * sec.floorplane.negiC ), int( sec.ceilingplane.d * sec.ceilingplane.negiC ) );
				noextrainfo = false;
				break;
			case 2:
				double floorz = sec.floorplane.d * sec.floorplane.negiC;
				double ceilingz = sec.ceilingplane.d * sec.ceilingplane.negiC;

				info.AppendFormat( "\n  Ceil " .. TAN .. "%-4i" .. DARKGRAY .. " (head delta " .. TAN.. "%i" .. DARKGRAY .. ");\n"
								.. "  Flr " .. DARKGREEN .. "%-4i" .. DARKGRAY .. " (feet delta " .. DARKGREEN.. "%i" .. DARKGRAY .. ").",
								int( ceilingz ), int( ceilingz - infothing.pos.z - infothing.height ), int( floorz ), int( infothing.pos.z - floorz ) );
				noextrainfo = false;
				break;
			case 0:
			default:
				break;
		}

		if ( printSecLights ) {
			int floorlight = sec.GetFloorLight();
			int ceillight = sec.GetCeilingLight();
			noextrainfo = false;

			if ( floorlight == sec.lightlevel && floorlight == ceillight )
				info = info .. "\n  Light level " .. WHITE .. sec.lightlevel .. DARKGRAY .. ".";
			else
				info = info .. "\n  Light " .. WHITE .. sec.lightlevel .. DARKGRAY .. ", flr " .. GRAY .. floorlight .. DARKGRAY .. ", ceil " .. GRAY .. ceillight .. ".";
		}

		if ( printSecTextures ) {
			noextrainfo = false;
			info = info .. "\n  Tex:" .. TAN .. "C " .. getTextureInfo( Sector.ceiling ) ..
						";\n  Tex:" .. DARKGREEN .. "F " .. getTextureInfo( Sector.floor ) .. ".";
		}

		if ( printSecDamage ) {
			// [McM]: now "sec.GetSpecial()" is not used.
			noextrainfo = false;

			info = info .. BRICK .. "\n  Damage" .. DARKRED .. ": type \"" .. ( sec.damageType == 'None'? DARKGRAY : ORANGE ) .. sec.damageType .. DARKRED .. "\",\n    " ..
				( sec.damageAmount == 0? DARKGRAY : BRICK ) .. sec.damageAmount .. DARKRED .. " hp/" .. BRICK .. sec.damageInterval .. DARKRED .. " tics, leakydmg " .. sec.leakydamage .. ".";
		}


/*
SECF_SILENT			= 1,	// actors in sector make no noise
SECF_NOFALLINGDAMAGE= 2,	// No falling damage in this sector
SECF_FLOORDROP		= 4,	// all actors standing on this floor will remain on it when it lowers very fast.
SECF_NORESPAWN		= 8,	// players can not respawn in this sector
SECF_FRICTION		= 16,	// sector has friction enabled
SECF_PUSH			= 32,	// pushers enabled
SECF_SILENTMOVE		= 64,	// Sector movement makes mo sound (Eternity got this so this may be useful for an extended cross-port standard.) 
SECF_DMGTERRAINFX	= 128,	// spawns terrain splash when inflicting damage
SECF_ENDGODMODE		= 256,	// getting damaged by this sector ends god mode
SECF_ENDLEVEL		= 512,	// ends level when health goes below 10
SECF_HAZARD			= 1024,	// Change to Strife's delayed damage handling.
//SECF_NOATTACK		= 2048  // [New engine versions flag].

SECF_WASSECRET		= 1 << 30,	// a secret that was discovered
SECF_SECRET			= 1 << 31,	// a secret sector

SECMF_FAKEFLOORONLY	= 2,	// when used as heightsec in R_FakeFlat, only copies floor
SECMF_CLIPFAKEPLANES = 4,	// as a heightsec, clip planes to target sector's planes
SECMF_NOFAKELIGHT	= 8,	// heightsec does not change lighting
SECMF_IGNOREHEIGHTSEC= 16,	// heightsec is only for triggering sector actions
SECMF_UNDERWATER		= 32,	// sector is underwater
SECMF_FORCEDUNDERWATER= 64,	// sector is forced to be underwater
SECMF_UNDERWATERMASK	= 32+64,
SECMF_DRAWN			= 128,	// sector has been drawn at least once
SECMF_HIDDEN			= 256,	// Do not draw on textured automap
*/
		tempFlagsStr = "";
		secFlagsAmount = 0;

		switch ( printSecFlagsMode ) {
			case 1: // Short flag names.
				addSecFlag( Sector.SECF_SILENT, "qit" );
				addSecFlag( Sector.SECF_NOFALLINGDAMAGE, "-fld" );
				addSecFlag( Sector.SECF_FLOORDROP, "lftd" );
				addSecFlag( Sector.SECF_NORESPAWN, "-rspw" );
				addSecFlag( Sector.SECF_FRICTION, "fric" );
				addSecFlag( Sector.SECF_PUSH, "p" );
				addSecFlag( Sector.SECF_SILENTMOVE, "mvqt" );
				addSecFlag( Sector.SECF_DMGTERRAINFX, "tfx" );
				addSecFlag( Sector.SECF_ENDGODMODE, "-god" );
				addSecFlag( Sector.SECF_ENDLEVEL, "endl" );
				addSecFlag( Sector.SECF_HAZARD, "stfhz" );
				addSecFlag( Sector.SECF_WASSECRET, "was9" );
				addSecFlag( Sector.SECF_SECRET, "is9" );
				addSecFlag( 2048, "-mna" ); // Not found in GZDoom 3.3.0.
				addSecFlag2( Sector.SECMF_FAKEFLOORONLY, "fflr" );
				addSecFlag2( Sector.SECMF_CLIPFAKEPLANES, "fclp" );
				addSecFlag2( Sector.SECMF_NOFAKELIGHT, "-flit" );
				addSecFlag2( Sector.SECMF_IGNOREHEIGHTSEC, "-fhs" );
				addSecFlag2( Sector.SECMF_UNDERWATER, "wtr" );
				addSecFlag2( Sector.SECMF_FORCEDUNDERWATER, "wtr2" );
				addSecFlag2( Sector.SECMF_DRAWN, "vis" );
				addSecFlag2( Sector.SECMF_HIDDEN, "hid" );
				break;
			case 2: // Long flag names.
				addSecFlag( Sector.SECF_SILENT, "quiet" );
				addSecFlag( Sector.SECF_NOFALLINGDAMAGE, "-falldmg" );
				addSecFlag( Sector.SECF_FLOORDROP, "liftdrp" );
				addSecFlag( Sector.SECF_NORESPAWN, "-respawn" );
				addSecFlag( Sector.SECF_FRICTION, "frict" );
				addSecFlag( Sector.SECF_PUSH, "push" );
				addSecFlag( Sector.SECF_SILENTMOVE, "movquiet" );
				addSecFlag( Sector.SECF_DMGTERRAINFX, "terrainfx" );
				addSecFlag( Sector.SECF_ENDGODMODE, "-iddqd" );
				addSecFlag( Sector.SECF_ENDLEVEL, "endlvl" );
				addSecFlag( Sector.SECF_HAZARD, "strifehzrd" );
				addSecFlag( Sector.SECF_WASSECRET, "wassecr" );
				addSecFlag( Sector.SECF_SECRET, "newsecr" );
				addSecFlag( 2048, "-monatk" ); // Not found in GZDoom 3.3.0.
				addSecFlag2( Sector.SECMF_FAKEFLOORONLY, "fakeflr" );
				addSecFlag2( Sector.SECMF_CLIPFAKEPLANES, "clipfakeplns" );
				addSecFlag2( Sector.SECMF_NOFAKELIGHT, "-fakelit" );
				addSecFlag2( Sector.SECMF_IGNOREHEIGHTSEC, "-fakehghtsec" );
				addSecFlag2( Sector.SECMF_UNDERWATER, "water" );
				addSecFlag2( Sector.SECMF_FORCEDUNDERWATER, "waterforc" );
				addSecFlag2( Sector.SECMF_DRAWN, "drawn" );
				addSecFlag2( Sector.SECMF_HIDDEN, "hidden" );
				break;
			case 0:
			default:
				break;
		}

		if ( tempFlagsStr != "" ) {
			info = info .. "\n" .. BreakPanelLines( tempFlagsStr );
			noextrainfo = false;
		}

		if ( noextrainfo )
			info.Replace( ":", "." );
		else
			RemoveLastNewlineSymbol( info );

		outinfo = outinfo .. info;
	} // of protected void addSectorInfo( Sector sec, String sectorName = "" ) {}

	override String GetInfo_play( Actor thing, ZCheckerField thingfield ) {
		if ( thingfield.actorType != IAT_Normal )
			return "";

		outinfo = "";
		infothing = thing;

		bool differFloorCeilSectors = CVar.GetCVar( "mcm_zchecker_infovar_geomsecdiffers", players[ consoleplayer ] ).GetBool();

		printSecHeightsMode = CVar.GetCVar( "mcm_zchecker_infovar_geomsecheights", players[ consoleplayer ] ).GetInt();
		printSecLights = CVar.GetCVar( "mcm_zchecker_infovar_geomseclight", players[ consoleplayer ] ).GetBool();
		printSecFlagsMode = CVar.GetCVar( "mcm_zchecker_infovar_geomsecflags", players[ consoleplayer ] ).GetInt();
		printSecTextures = CVar.GetCVar( "mcm_zchecker_infovar_geomsectex", players[ consoleplayer ] ).GetBool();
		printSecDamage = CVar.GetCVar( "mcm_zchecker_infovar_geomsecdamage", players[ consoleplayer ] ).GetBool();
		printSecOther = CVar.GetCVar( "mcm_zchecker_infovar_geomsecother", players[ consoleplayer ] ).GetBool();
		printSecPortal = CVar.GetCVar( "mcm_zchecker_infovar_geomsecportal", players[ consoleplayer ] ).GetBool();
		printSecTerrain = CVar.GetCVar( "mcm_zchecker_infovar_geomsecterrain", players[ consoleplayer ] ).GetBool();

		if ( differFloorCeilSectors ) {
			if ( thing.cursector != thing.floorsector && thing.cursector != thing.ceilingsector ) {
				if ( thing.floorsector == thing.ceilingsector ) {
					addSectorInfo( thing.floorsector, "floor/ceil" );
				} else {
					addSectorInfo( thing.ceilingsector, "ceiling" );
					addSectorInfo( thing.floorsector, "floor", true );
				}
				addSectorInfo( thing.cursector, YELLOW .. "actual", true );

			} else {
				String header = "ceil";
				if ( thing.cursector == thing.ceilingsector )
					header = header .. ", " .. YELLOW .. "cur";

				addSectorInfo( thing.ceilingsector, header );

				header = "floor";
				if ( thing.cursector == thing.floorsector )
					header = header .. ", " .. YELLOW .. "cur";

				addSectorInfo( thing.floorsector, header, true );
			}
		} else {
			String cursecname = "";

			if ( thing.cursector == thing.floorsector )
				cursecname = YELLOW .. ( thing.cursector == thing.ceilingsector? " f/c" : " floor" );
			else if ( thing.cursector == thing.ceilingsector )
				cursecname = YELLOW .. " ceil";

			addSectorInfo( thing.cursector, "actual" .. cursecname );
		} // of else, of if ( differFloorCeilSectors ) {}

/*
	native int floorterrain;
	native TerrainDef GetFloorTerrain();

struct TerrainDef native {
	native Name TerrainName;
	native bool IsLiquid;
	native int Splash;
	native double FootClip;
	native double Friction;
	native double MoveFactor;

	native float StepVolume;
	native int WalkStepTics;
	native int RunStepTics;
	native Sound LeftStepSound;
	native Sound RightStepSound;

	native int DamageAmount;
	native Name DamageMOD;
	native int DamageTimeMask;
	native bool AllowProtection;
};*/

		if ( printSecTerrain ) {
			TerrainDef ter = thing.GetFloorTerrain();

			if ( ter ) {
				String C = DARKBROWN;

				String damageStr = "";
				if ( printSecDamage ) {
					damageStr = RED .. "  Damage" .. C .. ": type \"" .. ORANGE .. ter.DamageMOD .. C .. "\",\n    " ..
						RED .. ter.DamageAmount .. C .. " hp/" .. GRAY .. ter.DamageTimeMask .. C .. " tics. " .. ( ter.AllowProtection? DARKGREEN .. "Resistable" : ORANGE .. "No protect" ) .. "\n";
				}

				outinfo.AppendFormat( C ..
						"\nTerrain \"" .. TAN .. "%s" .. C .. "\" (" .. DARKGRAY .. "%i" .. C .. "):\n" ..
						"  Fric " .. TAN .. "%1.2f" .. C .. ", mul " .. TAN .. "%1.2f" .. C .. ", clipping " .. TAN .. "%1.2f\n" ..
						"  %s" .. C .. ", splash " .. GRAY .. "%i" .. C .. ".\n%s" .. C ..
						"  Steps: vol " .. GRAY .. "%1.2f, " .. C .. "tics " .. DARKGRAY .. "wlk" .. CYAN .. "%i" .. C .. "/" .. DARKGRAY .. "run" .. CYAN .. "%i" .. C .. ".\n"
						"    Left snd \"" .. TAN .. ter.LeftStepSound .. C .. "\";\n    Right snd \"" .. TAN .. ter.RightStepSound .. C .. "\".",
					ter.TerrainName, thing.floorterrain,
					ter.Friction, ter.MoveFactor, ter.FootClip,
					( ter.IsLiquid? DARKGRAY .. "Not liquid" : BLUE .. "Is liquid" ), ter.Splash,
					damageStr,
					ter.StepVolume, ter.WalkStepTics, ter.RunStepTics
				);
			} else {
				outinfo = outinfo .. DARKGRAY .. "\nNo terrain (" .. thing.floorterrain .. ").";
			}
		} // of if ( printSecTerrain ) {}

		return outinfo;
	}
} // of class ZCSectorsGeometryPanel: ZCBaseInfoPanelPart_PlayScope {}

class ZCLinesGeometryPanel: ZCBaseInfoPanelPart_PlayScope {
	override void OnCreate_play( void ) {
		optionCVarName = "mcm_zchecker_info_geomlines";
		optionLabel = "Actor lines";
		optionSubmenuName = "mcm_ZCheckerSubmenu_geomlines";
	}

	override String GetInfo_play( Actor thing, ZCheckerField thingfield ) {
		return BLACK .. "([WIP] Linedefs geometry must be here).";
	}
} // of class ZCLinesGeometryPanel: ZCBaseInfoPanelPart_PlayScope {}
