//

class ZCOptionMenuPanels: OptionMenu {
	enum EPanelMenuActionTypes {
		PMAT_None			= -1,
		PMAT_EnterSubmenu	= 0,
		PMAT_MoveItemUp,
		PMAT_MoveItemDown,

		PMAT_Quantity
	};

	int firstPanelItemPos, lastPanelItemPos;

	const DARKGRAY = TEXTCOLOR_DARKGRAY;
	const GRAY = TEXTCOLOR_GRAY;
	const GOLD = TEXTCOLOR_GOLD;

	ZCheckerHandler handler;

	transient CVar panelsOrderCVar;


	private OptionMenuItemStaticText AddStaticText( String label = " " ) {
		return new( "OptionMenuItemStaticText" ).Init( label );
	}

	private OptionMenuItemOption AddOption( String label, Name command, Name values ) {
		return new( "OptionMenuItemOption" ).Init( label, command, values );
	}

	private void ReinitMenuHeaderPart( OptionMenuDescriptor desc ) {
		desc.mItems.Push( AddStaticText() );
		desc.mItems.Push( AddStaticText( GOLD .. "Information panels settings:" ) );
		desc.mItems.Push( AddStaticText( TEXTCOLOR_DARKGREEN .. "Enter sumbenu" .. DARKGRAY .. " with " .. GRAY .. "<F4>" .. DARKGRAY .. ", " .. GRAY .. "<space>" .. DARKGRAY .. ", '" .. GRAY .. "E" .. DARKGRAY .. "' or " .. GRAY .. "<tab>" .. DARKGRAY .. ";" ) );
		desc.mItems.Push( AddStaticText( TEXTCOLOR_TEAL .. "Move panels" .. DARKGRAY .. " with '" .. GRAY .. "+" .. DARKGRAY .. "', '" .. GRAY .. "-" .. DARKGRAY .. "', " .. GRAY .. "<KP+>" .. DARKGRAY .. " or " .. GRAY .. "<KP->" .. DARKGRAY .. "." ) );
		desc.mItems.Push( AddStaticText( DARKGRAY .. "Note: order will be saved in several play tics." ) );
		desc.mItems.Push( AddStaticText() );
	}

	private void ReinitMenuLastPart( OptionMenuDescriptor desc ) {
		desc.mItems.Push( AddStaticText() );
		desc.mItems.Push( new( "ZCOptionMenuItemRecreateInfopanels" ).Init( "Reset information panels order", self ) );
		desc.mItems.Push( AddStaticText() );
		desc.mItems.Push( AddStaticText( GOLD .. "General settings:" ) );
		desc.mItems.Push( new( "OptionMenuItemSubmenu" ).Init( "Information panel settings", "mcm_ZChecker_InfoPanelControl" ) );
		desc.mItems.Push( AddOption( "Log level", "mcm_zchecker_loglevel", "mcm_ZCheckerOption_LogLevels" ) );

		desc.mItems.Push( AddStaticText() );
		desc.mItems.Push( AddStaticText( GOLD .. "\"Everything\" map settings:" ) );
		desc.mItems.Push( AddOption( "Spawn +STEALTH actors: ", "mcm_zchecker_ev_spawnstealth", "YesNo" ) );
		desc.mItems.Push( AddOption( "Spawn +INVISIBLE actors: ", "mcm_zchecker_ev_spawninvisible", "YesNo" ) );
		desc.mItems.Push( AddOption( "Spawn actors with sprite \"PLYC*\": ", "mcm_zchecker_ev_spawnplyc", "YesNo" ) );
		desc.mItems.Push( AddOption( "Spawn actors with sprite \"TNT1A0\": ", "mcm_zchecker_ev_spawntnt1a0", "YesNo" ) );
	}

	void SetPanelOptionsOrder( OptionMenuDescriptor desc ) {
		String curorder = "";
		panelsOrderCVar = handler.panels.panelsOrderCVar;

		for ( int i = firstPanelItemPos; i < lastPanelItemPos; i++ ) {
			ZCOptionMenuItemInfopanel paneloption = ZCOptionMenuItemInfopanel( desc.mItems[ i ] );

			if ( paneloption ) {
				curorder = curorder .. paneloption.panelclass.GetClassName() .. ",";
				ZCGlobal.UILog( LL_Debug, GetClassName() .. "::SetPanelOptionsOrder(). Saved \"" .. TEXTCOLOR_OLIVE .. paneloption.panelclass.GetClassName() .. LLCOLOR_DEBUG .. "\"." );
			}
		}

		handler.panels.panelsstr = curorder;
		//handler.panels.panelsorderChanged = true;
		handler.panels.UpdatePanels();
	}

	private int InsertMenuPanelPart( ZCBaseInfoPanelPart panel, OptionMenuDescriptor desc ) {
		ZCOptionMenuItemInfopanel item = new( "ZCOptionMenuItemInfopanel" );
		ZCOptionMenuItemInfopanelSubmenu submenuItem = NULL;

		desc.mItems.Push( item.Init( panel ) );

		if ( panel.optionSubmenuName ) {
			submenuItem = new( "ZCOptionMenuItemInfopanelSubmenu" );
			submenuItem.Init( item, panel );

			desc.mItems.Push( submenuItem );
			return 2; // Items offset (+2, option and its submenu);
		}

		return 1; // Items offset (+1, option only).
	}

	protected void ReinitMenuPanels( OptionMenuDescriptor desc, ZCheckerHandler handler ) {
		int addedItemsAmount = 0;

		if ( handler.panels.panelsorderChanged )
			handler.panels.UpdatePanels();

		for ( int i = 0; i < handler.panels.curPanels.Size(); i++ ) {
			ZCBaseInfoPanelPart newpart = handler.panels.curPanels.nodes[ i ].panel;

			addedItemsAmount += InsertMenuPanelPart( newpart, desc );
			ZCGlobal.UILog( LL_Debug, GetClassName() .. "::ReinitMenuPanels(). Added Panel class \"" .. TEXTCOLOR_ICE .. newpart.GetClassName() .. LLCOLOR_DEBUG .. "\"." );
		}

		lastPanelItemPos += addedItemsAmount;
	}

	void ReinitMenuItems( OptionMenuDescriptor desc ) {
        desc.mItems.Clear();
		ReinitMenuHeaderPart( desc );

		firstPanelItemPos = lastPanelItemPos = desc.mItems.Size();

		if ( !handler ) {
			ZCGlobal.ClearscopeLog( LL_Emergency, GetClassName() .. "::Init(). Cannot locate ZChecker static event handler." );
			desc.mItems.Push( AddStaticText( TEXTCOLOR_FIRE .. "Cannot locate ZChecker static event handler." ) );
		} else {
			ReinitMenuPanels( desc, handler );
		}

		ReinitMenuLastPart( desc );
	}

	override void Init( Menu parent, OptionMenuDescriptor desc ) {
		handler = ZCheckerHandler( StaticEventHandler.Find( "ZCheckerHandler" ) );

		ReinitMenuItems( desc );

		Super.Init( parent, desc );
	} // of override void Init( Menu parent, OptionMenuDescriptor desc ) {}


	override bool OnUIEvent( UIEvent e ) {
		int curpos = mDesc.mSelectedItem;
		ZCOptionMenuItemInfopanel curitem = NULL;

		if ( curpos > 0 )
			curitem = ZCOptionMenuItemInfopanel( mDesc.mItems[ curpos ] );

		EPanelMenuActionTypes actiontype = PMAT_None;
		int key = e.KeyChar;

		//console.printf( "e.Type: " .. e.Type .. ", e.KeyChar: " .. e.KeyChar .. ", e.KeyString: \"" .. e.KeyString .. "\" (len " .. e.KeyString.Length() .. ")" );
		//console.printf( "curitem " .. curitem .. ", actiontype " .. actiontype .. "; pos " .. firstPanelItemPos .. " <= " .. curpos .. " < " .. lastPanelItemPos );

		if ( e.Type == e.Type_KeyDown ) {
			if ( key == e.Key_F3 || key == e.Key_F4 || key == e.Key_Tab )
				actiontype = PMAT_EnterSubmenu;

		} else if ( e.Type == e.Type_Char ) {
			if ( key == 0x45 || key == 0x65 || key == 0x20 )
				actiontype = PMAT_EnterSubmenu;
			else if ( key == 0x2D )
				actiontype = PMAT_MoveItemUp;
			else if ( key == 0x2B )
				actiontype = PMAT_MoveItemDown;
		} else if ( e.Type == e.Type_WheelUp ) {
			actiontype = PMAT_MoveItemUp;
		} else if ( e.Type == e.Type_WheelDown ) {
			actiontype = PMAT_MoveItemDown;
		}

		if ( curitem && actiontype != PMAT_None && curpos < lastPanelItemPos && curpos >= firstPanelItemPos ) {
			int moveOffset = ( curitem.mSubmenu? 2 : 1 );

			if ( actiontype == PMAT_MoveItemUp || actiontype == PMAT_MoveItemDown ) {
				bool movePrepared = false;

				if ( actiontype == PMAT_MoveItemUp ) {
					int newpos = curpos - ( 1 + !!( mDesc.mItems[ curpos - 1 ] is "ZCOptionMenuItemInfopanelSubmenu" ) );

					curitem = ZCOptionMenuItemInfopanel( mDesc.mItems[ newpos ] );
					moveOffset = ( curitem && curitem.mSubmenu? 2 : 1 );

					movePrepared = ( curpos - moveOffset >= firstPanelItemPos );

					curpos = newpos;
				} else {
					movePrepared = ( curpos + moveOffset < lastPanelItemPos );
				}

				Menu.MenuSound( "menu/change" );

				if ( movePrepared ) {
					OptionMenuItem movingitem = NULL;

					int curMoveOffset = moveOffset;
					int newCursorOffset = 1;

					Name mSubmenuSrc = ZCOptionMenuItemInfopanel( mDesc.mItems[ curpos ] ).mSubmenu;
					Name mSubmenuDest = ZCOptionMenuItemInfopanel( mDesc.mItems[ curpos + moveOffset ] ).mSubmenu;

					/*	Direction	Dn	Dn	Dn	Dn	Up	Up	Up	Up
						SubmenuSrc	-	+	-	+	-	+	-	+
						SubmenuDest	-	-	+	+	-	-	+	+
						Rezult		+1	+1	+1	+1	-1	-1	-2	-1
					*/

					if ( mSubmenuDest )
						moveOffset++;
					else if ( mSubmenuSrc && actiontype == PMAT_MoveItemUp )
						newCursorOffset++;

					//console.printf( "curMoveOffset " .. curMoveOffset .. ", newCursorOffset " .. newCursorOffset );


					while ( curMoveOffset --> 0 ) {
						movingitem = mDesc.mItems[ curpos ];
						mDesc.mItems.Delete( curpos, 1 );
						mDesc.mItems.Insert( curpos + moveOffset, movingitem );
					}

					while ( newCursorOffset --> 0 )
						Menu.GetCurrentMenu().MenuEvent( ( actiontype == PMAT_MoveItemUp? MKEY_Up : MKEY_Down ), false );

					SetPanelOptionsOrder( mDesc );
				} else {
					Menu.MenuSound( "menu/invalid" );
				}

			} else if ( actiontype == PMAT_EnterSubmenu ) {
				// Tab, F4, 'e', 'E' and Space opens a submenu (if any).
				if ( curitem.mSubmenu ) {
					Menu.MenuSound( "menu/choose" );
					Menu.SetMenu( curitem.mSubmenu );
				} else {
					Menu.MenuSound( "menu/invalid" );
				}

				return true;
			}
		} // of if ( curitem && actiontype != PMAT_None && curpos < lastPanelItemPos && curpos >= firstPanelItemPos ) {}

		return Super.OnUIEvent( e );
	} // of override bool OnUIEvent( UIEvent e ) {}

} // of class ZCOptionMenuPanels: OptionMenu {}


class ZCOptionMenuItemInfopanel: OptionMenuItemOption {
	Name mSubmenu;
	class<ZCBaseInfoPanelPart> panelclass;

	ZCOptionMenuItemInfopanel Init( ZCBaseInfoPanelPart panel ) {
		String panellabel = panel.optionLabel;
		if ( panel is "ZCBaseInfoPanelPart_PlayScope" )
			panellabel = "[play] >> " .. panellabel;

		Super.Init( panellabel, panel.optionCVarName, 'OnOff' );

		mSubmenu = panel.optionSubmenuName;
		panelclass = panel.GetClass();

		return self;
	}
}

class ZCOptionMenuItemInfopanelSubmenu: OptionMenuItemStaticText {
	ZCOptionMenuItemInfopanel masterMenuItem;
	ZCBaseInfoPanelPart masterInfoPanel;
	ZCOptionMenuPanels masterMenu;

	OptionMenuDescriptor subdesc;

	ZCOptionMenuItemInfopanelSubmenu Init( ZCOptionMenuItemInfopanel masteritem, ZCBaseInfoPanelPart infopanel ) {
		masterMenuItem = masteritem;
		masterInfoPanel = infopanel;
		mLabel = "";

		masterMenu = ZCOptionMenuPanels( Menu.GetCurrentMenu() );
		subdesc = OptionMenuDescriptor( MenuDescriptor.GetDescriptor( infopanel.optionSubmenuName ) );	

		return self;
	}

	override int Draw( OptionMenuDescriptor desc, int y, int indent, bool selected ) {
		bool masterItemSelected = false;

		if ( desc && desc.mSelectedItem > 0 ) {
			mLabel = masterInfoPanel.GetSubmenuLabel( masterMenuItem, subdesc );
			masterItemSelected = ( desc.mItems[ desc.mSelectedItem ] == masterMenuItem );
		}

		drawLabel( indent, y, ( masterItemSelected? OptionMenuSettings.mFontColorSelection : Font.CR_DARKGRAY ) );

		return indent;
	}

	/*override bool MouseEvent( int type, int x, int y ) {
		if ( type == Menu.MOUSE_Click && masterMenu ) {
			for ( int i = masterMenu.firstInfoPanelPos; i < masterMenu.lastInfoPanelPos; i++ ) {
				if ( desc.mItems[ i ] == masterMenuItem ) {
					desc.mSelectedItem = i;
					break;
				}
			}

			return Menu.GetCurrentMenu().MenuEvent( Menu.MKEY_Enter, true );
		}

		return true;
	}*/

} // of class ZCOptionMenuItemInfopanelSubmenu: OptionMenuItemStaticText {}

class ZCOptionMenuItemRecreateInfopanels: OptionMenuItem {
	ZCOptionMenuPanels zcparentmenu;

	ZCOptionMenuItemRecreateInfopanels Init( String label, ZCOptionMenuPanels parentmenu ) {
		Super.Init( label, 'None' );
		zcparentmenu = parentmenu;

		return self;
	}

	override int Draw( OptionMenuDescriptor desc, int y, int indent, bool selected ) {
		drawLabel( indent, y, selected? OptionMenuSettings.mFontColorSelection : OptionMenuSettings.mFontColor );

		return indent;
	}

	override bool Activate() {
		if ( zcparentmenu.handler && zcparentmenu.handler.panels ) {
			ZCPanelsStorage panels = zcparentmenu.handler.panels;

			panels.panelsstr = "";
			panels.UpdatePanels( false );
			zcparentmenu.ReinitMenuItems( zcparentmenu.mDesc );

			zcparentmenu.mDesc.mSelectedItem = zcparentmenu.lastPanelItemPos + 1;

			Menu.MenuSound( "menu/activate" );

			ZCGlobal.ClearscopeLog( LL_Detailed, TEXTCOLOR_GRAY .. "The information panels order has been reset." );
		}

		return true;
	}
} // of class ZCOptionMenuItemRecreateInfopanels: OptionMenuItem {}
