//

class ZCOptionMenuPanels: OptionMenu {
	enum EPanelMenuActionTypes {
		PMAT_None			= -1,
		PMAT_EnterSubmenu	= 0,
		PMAT_MoveItemUp,
		PMAT_MoveItemDown,
		PMAT_SwitchOption,

		PMAT_Quantity
	};

	int firstPanelItemPos, lastPanelItemPos;

	const DARKGRAY = TEXTCOLOR_DARKGRAY;
	const GRAY = TEXTCOLOR_GRAY;
	const GOLD = TEXTCOLOR_GOLD;

	ZCheckerHandler handler;


	private OptionMenuItemStaticText NewStaticText( String label = " " ) {
		return new( "OptionMenuItemStaticText" ).Init( label );
	}

	private void ReinitMenuHeaderPart( OptionMenuDescriptor desc ) {
		desc.mItems.Push( NewStaticText() );
		desc.mItems.Push( NewStaticText( GOLD .. "Informational panels settings:" ) );
		desc.mItems.Push( NewStaticText( TEXTCOLOR_DARKGREEN .. "Enter sumbenu" .. DARKGRAY .. " with " .. GRAY .. "<F4>" .. DARKGRAY .. ", '" .. GRAY .. "E" .. DARKGRAY .. "', '" .. GRAY .. "S" .. DARKGRAY .. "', " .. GRAY .. "<tab>" .. DARKGRAY .. " or " .. GRAY .. "mouse click" .. DARKGRAY .. ";" ) );
		desc.mItems.Push( NewStaticText( TEXTCOLOR_TEAL .. "Move panels" .. DARKGRAY .. " with '" .. GRAY .. "+" .. DARKGRAY .. "'/" .. GRAY .. "<KP+>" .. DARKGRAY .. ", '" .. GRAY .. "-" .. DARKGRAY .. "'/" .. GRAY .. "<KP->" .. DARKGRAY .. " and " .. GRAY .. "mouse wheel" .. DARKGRAY .. "." ) );
		desc.mItems.Push( NewStaticText( DARKGRAY .. "Note: order will be saved after one play tic." ) );
		desc.mItems.Push( NewStaticText() );
	}

	private void ReinitMenuLastPart( OptionMenuDescriptor desc ) {
		desc.mItems.Push( NewStaticText() );
		desc.mItems.Push( NewStaticText( TEXTCOLOR_GOLD .. "Panels order reset" ) );
		desc.mItems.Push( new( "ZCOptionMenuItemRecreateInfopanels" ).Init( "Reset informational panels order" ) );
		desc.mItems.Push( NewStaticText() );
	}

	void SetPanelOptionsOrder( OptionMenuDescriptor desc ) {
		String curorder = "";

		for ( int i = firstPanelItemPos; i < lastPanelItemPos; i++ ) {
			ZCOptionMenuItemInfopanel paneloption = ZCOptionMenuItemInfopanel( desc.mItems[ i ] );

			if ( paneloption ) {
				curorder = curorder .. paneloption.panelclass.GetClassName() .. ",";
				ZCGlobal.UILog( LL_Debug, GetClassName() .. "::SetPanelOptionsOrder(). Saved \"" .. TEXTCOLOR_OLIVE .. paneloption.panelclass.GetClassName() .. LLCOLOR_DEBUG .. "\"." );
			}
		}

		handler.panels.panelsstr = curorder;
		handler.panels.UpdatePanels();
	}

	private int InsertMenuPanelPart( ZCBaseInfoPanelPart panel, OptionMenuDescriptor desc ) {
		ZCOptionMenuItemInfopanel item = new( "ZCOptionMenuItemInfopanel" );
		ZCOptionMenuItemInfopanelSubmenu submenuItem = NULL;

		desc.mItems.Push( item.Init( panel ) );

		if ( panel.optionSubmenuName ) {
			submenuItem = new( "ZCOptionMenuItemInfopanelSubmenu" );
			submenuItem.Init( item, panel );

			desc.mItems.Push( submenuItem );
			return 2; // Items offset (+2, option and its submenu);
		}

		return 1; // Items offset (+1, option only).
	}

	protected void ReinitMenuPanelItems( OptionMenuDescriptor desc, ZCheckerHandler handler ) {
		int addedItemsAmount = 0;

		if ( handler.panels.panelsorderChanged )
			handler.panels.UpdatePanels();

		for ( int i = 0; i < handler.panels.curPanels.Size(); i++ ) {
			ZCBaseInfoPanelPart newpart = handler.panels.curPanels.nodes[ i ].panel;

			addedItemsAmount += InsertMenuPanelPart( newpart, desc );
			ZCGlobal.UILog( LL_Debug, GetClassName() .. "::ReinitMenuPanels(). Added Panel class \"" .. TEXTCOLOR_ICE .. newpart.GetClassName() .. LLCOLOR_DEBUG .. "\"." );
		}

		lastPanelItemPos += addedItemsAmount;
	} // of protected void ReinitMenuPanels( OptionMenuDescriptor desc, ZCheckerHandler handler ) {}

	void ReinitMenuItems( OptionMenuDescriptor desc ) {
        desc.mItems.Clear(); // For the "Reset infopanels order" button.
		ReinitMenuHeaderPart( desc );

		firstPanelItemPos = lastPanelItemPos = desc.mItems.Size();

		if ( !handler ) {
			ZCGlobal.ClearscopeLog( LL_Emergency, GetClassName() .. "::Init(). Cannot locate ZChecker static event handler." );
			desc.mItems.Push( new( "OptionMenuItemZCHandlerExistenceCheckWarning" ).Init(
					"\cxCannot locate ZChecker static event handler.\n\ciPossible reason: \cu\"\crEventHandler = ...\cu\"\n\ciin MAPINFO on GZDoom older than 4.8.0.\n\cxInformational panels are not able to be initialized."
				) );
		} else {
			ReinitMenuPanelItems( desc, handler );
		}

		ReinitMenuLastPart( desc );
	} // of void ReinitMenuItems( OptionMenuDescriptor desc ) {}


	override void Init( Menu parent, OptionMenuDescriptor desc ) {
		handler = ZCheckerHandler( StaticEventHandler.Find( "ZCheckerHandler" ) );

		if ( !desc.mItems.Size() ) {
			ReinitMenuItems( desc );

		} else {
			// Items are saved between menu sessions but menu itself not.

			for ( int i = 0; i < desc.mItems.Size(); i++ ) {
				if ( desc.mItems[ i ] is "ZCOptionMenuItemInfopanel" ) {
					firstPanelItemPos = i;
					break;
				}
			}

			if ( firstPanelItemPos != 0 ) {
				for ( int i = desc.mItems.Size() - 1; i >= 0; i-- ) {
					if ( desc.mItems[ i ] is "ZCOptionMenuItemInfopanel" ) {
						i += 1;
						lastPanelItemPos = i + !!( desc.mItems[ i ] is "ZCOptionMenuItemInfopanelSubmenu" );
						break;
					}
				} // of for ( int i = desc.mItems.Size() - 1; i >= 0; i-- ) {}
			} // of if ( firstPanelItemPos != 0 ) {}

		} // of else of if ( !desc.mItems.Size() ) {}

		Super.Init( parent, desc );
	} // of override void Init( Menu parent, OptionMenuDescriptor desc ) {}


	override bool OnUIEvent( UIEvent e ) {
		int curpos = mDesc.mSelectedItem;
		ZCOptionMenuItemInfopanel curitem = NULL;

		EPanelMenuActionTypes actiontype = PMAT_None;
		int key = e.KeyChar;


		// Click-safe mouse pointing:
		if ( e.type == e.Type_RButtonDown ) {
			SetCapture( true );
			MouseEvent( MOUSE_Move, e.MouseX, e.MouseY );

		} else if ( e.type == e.Type_RButtonUp ) {
			SetCapture( false );

		// Specific infopanels menu keys:
		} else if ( e.Type == e.Type_KeyDown ) {
			if ( key == e.Key_F3 || key == e.Key_F4 || key == e.Key_Tab )
				actiontype = PMAT_EnterSubmenu;

		} else if ( e.Type == e.Type_Char ) {
			// 'E'/'e', 'S'/'s':
			if ( key == 0x45 || key == 0x65 || key == 0x53 || key == 0x73 )
				actiontype = PMAT_EnterSubmenu;
			else if ( key == 0x2D )
				actiontype = PMAT_MoveItemUp;
			else if ( key == 0x2B )
				actiontype = PMAT_MoveItemDown;
			else if ( key == 0x20 )
				actiontype = PMAT_SwitchOption;

		} else if ( e.Type == e.Type_WheelUp ) {
			actiontype = PMAT_MoveItemUp;

		} else if ( e.Type == e.Type_WheelDown ) {
			actiontype = PMAT_MoveItemDown;

		} else if ( e.Type == e.Type_MButtonDown ) {
			MouseEvent( MOUSE_Move, e.MouseX, e.MouseY );
			curpos = mDesc.mSelectedItem;
			actiontype = PMAT_EnterSubmenu;

		}


		if ( curpos > 0 )
			curitem = ZCOptionMenuItemInfopanel( mDesc.mItems[ curpos ] );


		//console.printf( "e.Type: " .. e.Type .. ", e.KeyChar: " .. e.KeyChar .. ", e.KeyString: \"" .. e.KeyString .. "\" (len " .. e.KeyString.Length() .. ")" );
		//console.printf( "curitem " .. curitem .. ", actiontype " .. actiontype .. "; pos " .. firstPanelItemPos .. " <= " .. curpos .. " < " .. lastPanelItemPos );


		if ( curitem && actiontype != PMAT_None && curpos < lastPanelItemPos && curpos >= firstPanelItemPos ) {
			int moveOffset = ( curitem.mSubmenu? 2 : 1 );

			if ( actiontype == PMAT_MoveItemUp || actiontype == PMAT_MoveItemDown ) {
				bool movePrepared = false;

				if ( actiontype == PMAT_MoveItemUp ) {
					int newpos = curpos - ( 1 + !!( mDesc.mItems[ curpos - 1 ] is "ZCOptionMenuItemInfopanelSubmenu" ) );

					curitem = ZCOptionMenuItemInfopanel( mDesc.mItems[ newpos ] );
					moveOffset = ( curitem && curitem.mSubmenu? 2 : 1 );

					movePrepared = ( curpos - moveOffset >= firstPanelItemPos );

					curpos = newpos;
				} else {
					movePrepared = ( curpos + moveOffset < lastPanelItemPos );
				}

				Menu.MenuSound( "menu/change" );

				if ( movePrepared ) {
					OptionMenuItem movingitem = NULL;

					int curMoveOffset = moveOffset;
					int newCursorOffset = 1;

					Name mSubmenuSrc = ZCOptionMenuItemInfopanel( mDesc.mItems[ curpos ] ).mSubmenu;
					Name mSubmenuDest = ZCOptionMenuItemInfopanel( mDesc.mItems[ curpos + moveOffset ] ).mSubmenu;

					/*	Direction	Dn	Dn	Dn	Dn	Up	Up	Up	Up
						SubmenuSrc	-	+	-	+	-	+	-	+
						SubmenuDest	-	-	+	+	-	-	+	+
						Rezult		+1	+1	+1	+1	-1	-1	-2	-1
					*/

					if ( mSubmenuDest )
						moveOffset++;
					else if ( mSubmenuSrc && actiontype == PMAT_MoveItemUp )
						newCursorOffset++;

					//console.printf( "curMoveOffset " .. curMoveOffset .. ", newCursorOffset " .. newCursorOffset );


					while ( curMoveOffset --> 0 ) {
						movingitem = mDesc.mItems[ curpos ];
						mDesc.mItems.Delete( curpos, 1 );
						mDesc.mItems.Insert( curpos + moveOffset, movingitem );
					}

					while ( newCursorOffset --> 0 )
						Menu.GetCurrentMenu().MenuEvent( ( actiontype == PMAT_MoveItemUp? MKEY_Up : MKEY_Down ), false );

					SetPanelOptionsOrder( mDesc );
				} else {
					Menu.MenuSound( "menu/invalid" );
				}

			} else if ( actiontype == PMAT_EnterSubmenu ) {
				// Tab, F4, 'e', 'E', 's' and 'S' opens a submenu (if any).
				curitem.OpenSubmenu();
				return true;

			} else if ( actiontype == PMAT_SwitchOption ) {
				// Space switches the value, same as Enter or L/R arrows.
				Menu.GetCurrentMenu().MenuEvent( MKEY_Enter, false );
				return true;

			}
		} // of if ( curitem && actiontype != PMAT_None && curpos < lastPanelItemPos && curpos >= firstPanelItemPos ) {}

		return Super.OnUIEvent( e );
	} // of override bool OnUIEvent( UIEvent e ) {}

	override bool MouseEvent( int type, int x, int y ) {
		y = ( y / CleanYfac_1 ) - mDesc.mDrawTop;

		if ( mFocusControl ) {
			mFocusControl.MouseEvent( type, x, y );
			return true;
		}

		int yline = ( y / OptionMenuSettings.mLinespacing );

		if ( yline >= mDesc.mScrollTop )
			yline += mDesc.mScrollPos;

		if ( yline >= 0 && yline < mDesc.mItems.Size() && ( mDesc.mItems[ yline ].Selectable() || mDesc.mItems[ yline ] is "ZCOptionMenuItemInfopanelSubmenu" ) ) {
			mDesc.mSelectedItem = yline;
			mDesc.mItems[ yline ].MouseEvent( type, x, y );
			return true;
		}

		mDesc.mSelectedItem = -1;

		return true;
	} // of override bool MouseEvent( int type, int x, int y ) {}

	override void OnReturn() {
		SetCapture( false );
	}


} // of class ZCOptionMenuPanels: OptionMenu {}




// === Random option menu items:


class ZCOptionMenuItemInfopanel: OptionMenuItemOption {
	Name mSubmenu;
	class<ZCBaseInfoPanelPart> panelclass;

	ZCOptionMenuItemInfopanel Init( ZCBaseInfoPanelPart panel ) {
		String panellabel = panel.optionLabel;

		if ( panel is "ZCBaseInfoPanelPart_PlayScope" )
			panellabel = "[play] >> " .. panellabel;

		Super.Init( panellabel, panel.optionCVarName, 'OnOff' );

		mSubmenu = panel.optionSubmenuName;
		panelclass = panel.GetClass();

		return self;
	}

	void OpenSubmenu( void ) {
		if ( mSubmenu ) {
			Menu.MenuSound( "menu/choose" );
			Menu.SetMenu( mSubmenu );
		} else {
			Menu.MenuSound( "menu/invalid" );
		}
	}
} // of class ZCOptionMenuItemInfopanel: OptionMenuItemOption {}

class ZCOptionMenuItemInfopanelSubmenu: OptionMenuItemStaticText {
	ZCOptionMenuItemInfopanel masterMenuItem;
	ZCBaseInfoPanelPart masterInfoPanel;

	OptionMenuDescriptor subdesc;


	private String GetSubmenuLabel( void ) {
		return masterInfoPanel.GetSubmenuLabel( subdesc );
	}

	ZCOptionMenuItemInfopanelSubmenu Init( ZCOptionMenuItemInfopanel masteritem, ZCBaseInfoPanelPart infopanel ) {
		masterMenuItem = masteritem;
		masterInfoPanel = infopanel;

		subdesc = OptionMenuDescriptor( MenuDescriptor.GetDescriptor( infopanel.optionSubmenuName ) );	
		mLabel = GetSubmenuLabel();

		return self;
	}

	override int Draw( OptionMenuDescriptor desc, int y, int indent, bool selected ) {
		bool masterItemSelected = false;

		if ( desc ) {
			if ( desc.mSelectedItem > 0 ) {
				mLabel = GetSubmenuLabel();
				masterItemSelected = ( desc.mItems[ desc.mSelectedItem ] == masterMenuItem );
			}
		} else {
			mLabel = GetClassName() .. "::Draw(). No OptionMenuDescriptor.";
		}

		drawLabel( indent, y, ( masterItemSelected? OptionMenuSettings.mFontColorSelection : Font.CR_DARKGRAY ) );

		return indent;
	}

	override bool MouseEvent( int type, int x, int y ) {
		ZCOptionMenuPanels masterMenu = ZCOptionMenuPanels( Menu.GetCurrentMenu() );

		if ( masterMenu && masterMenuItem ) {
			// Highlight the master item position instead of submenu item:
			for ( int i = 0; i < masterMenu.mDesc.mItems.Size(); i++ ) {
				if ( masterMenu.mDesc.mItems[ i ] == masterMenuItem ) {
					masterMenu.mDesc.mSelectedItem = i;
					break;
				}
			}

			// Open the submenu (currently called after the UIEvent.Type_LButtonUp):
			if ( type == Menu.MOUSE_Release )
				masterMenuItem.OpenSubmenu();
		} else {
			ZCGlobal.ClearscopeLog( LL_Emergency, GetClassName() .. "::MouseEvent(). No masterMenu (" .. masterMenu .. ") or masterMenuItem (" .. masterMenuItem .. "). Mouse event type " .. type .. "." );
		}

		return true;
	}

} // of class ZCOptionMenuItemInfopanelSubmenu: OptionMenuItemStaticText {}

class ZCOptionMenuItemRecreateInfopanels: OptionMenuItem {
	ZCOptionMenuItemRecreateInfopanels Init( String label ) {
		Super.Init( label, 'None' );
		return self;
	}

	override int Draw( OptionMenuDescriptor desc, int y, int indent, bool selected ) {
		drawLabel( indent, y, selected? OptionMenuSettings.mFontColorSelection : OptionMenuSettings.mFontColor );

		return indent;
	}

	override bool Activate() {
		ZCOptionMenuPanels curmenu = ZCOptionMenuPanels( Menu.GetCurrentMenu() );

		if ( curmenu && curmenu.handler && curmenu.handler.panels ) {
			ZCPanelsStorage panels = curmenu.handler.panels;

			panels.panelsstr = "";
			panels.UpdatePanels( false );

			curmenu.ReinitMenuItems( curmenu.mDesc );
			curmenu.mDesc.mSelectedItem = curmenu.lastPanelItemPos + 2;

			Menu.MenuSound( "menu/activate" );

			ZCGlobal.ClearscopeLog( LL_Detailed, TEXTCOLOR_GRAY .. "The informational panels order has been reset." );
		} else {
			Menu.MenuSound( "menu/invalid" );
		}

		return true;
	}
} // of class ZCOptionMenuItemRecreateInfopanels: OptionMenuItem {}


// For the PSprite overlay ID choice:

class OptionMenuItemZCPSpriteInputField: OptionMenuItemTextField {
	OptionMenuItemZCPSpriteInputField Init( String label, Name command, CVar graycheck = null ) {
		Super.Init( label, command, graycheck );
		return self;
	}

	override bool MenuEvent( int mkey, bool fromcontroller ) {
		if ( mkey == Menu.MKEY_Enter ) {
			String basestr = String.Format( "%i", GetCVarString().ToInt() );

			Menu.MenuSound( "menu/choose" );
			mEnter = TextEnterMenu.Open( Menu.GetCurrentMenu(), basestr, -1, 2, fromcontroller );
			mEnter.ActivateMenu();
			return true;

		} else if ( mkey == Menu.MKEY_Input ) {
			int setval;
			String setstr = mEnter.GetText();
			setstr.ToLower();

			if ( setstr == "flash" || setstr == "fire" ) {
				setval = PSprite.FLASH;

			} else {
				setval = setstr.ToInt();

				if ( setval == 0 )
					setval = PSprite.WEAPON;
			}

			setstr = String.Format( "%i", setval );

			switch ( setval ) {
				case PSprite.WEAPON:
					setstr = setstr .. " (weapon/main)";
					break;
				case PSprite.FLASH:
					setstr = setstr .. " (flash)";
					break;
				case PSprite.STRIFEHANDS:
					setstr = setstr .. " (Strife hands)";
					break;
				case PSprite.TARGETCENTER:
					setstr = setstr .. " (PowerTargeter center)";
					break;
				case PSprite.TARGETLEFT:
					setstr = setstr .. " (PowerTargeter left)";
					break;
				case PSprite.TARGETRIGHT:
					setstr = setstr .. " (PowerTargeter right)";
					break;
				default:
					break;
			}

			if ( mCVar )
				mCVar.SetString( setstr );

			mEnter = NULL;
			return true;
		}

		return Super.MenuEvent( mkey, fromcontroller );
	} // of override bool MenuEvent( int mkey, bool fromcontroller ) {}

} // of class OptionMenuItemZCNumberTextField: OptionMenuItemTextField {}


class OptionMenuItemZCHandlerExistenceCheckWarning: OptionMenuItemStaticText {
	private String realLabel;
	private OptionMenuDescriptor desc;
	private bool isHandlerFound, isWarningInjected;

	OptionMenuItemStaticText Init( String label, int cr = -1 ) {
		isHandlerFound = !!ZCheckerHandler( StaticEventHandler.Find( "ZCheckerHandler" ) );
		isWarningInjected = false;

		realLabel = ( label.Left( 1 ) == "$"? StringTable.Localize( label ) : label );

		return Super.Init( "", cr );
	}

	private int getSelfIndex( OptionMenuDescriptor desc ) {
		int selfIndex = 0;

		for ( int i = 0; i < desc.mItems.Size(); i++ ) {
			if ( self == desc.mItems[ i ] )
				return i;
		}

		// Impossible value, actually: "Ticker()" normally will be called 
		//only from some valid menu.
		return -1;
	}

	private void LocateMenuDescriptor( void ) {
		if ( !desc ) {
			OptionMenu curmenu = OptionMenu( Menu.GetCurrentMenu() );
			desc = ( curmenu? OptionMenuDescriptor( curmenu.mDesc ) : NULL );

			if ( !desc )
				ZCGlobal.UILog( LL_Emergency, GetClassName() .. "::LocateMenuDescriptor(). No menu descriptor; OptionMenu <" .. curmenu .. ">." );
		}
	}

	// Seems like there's not so much more ways to inject a warning message to current opened menu.
	override void Ticker() {
		LocateMenuDescriptor();

		if ( isHandlerFound && desc ) {
			int removeIndex = getSelfIndex( desc );
			desc.mItems.Delete( removeIndex, 1 );

			if ( desc.mSelectedItem > removeIndex )
				desc.mSelectedItem--;

			Destroy();
			return;
		}

		if ( !isHandlerFound && !isWarningInjected && desc ) {
			int startInjectIndex = getSelfIndex( desc );

			Array<String> labeldiv;
			realLabel.Split( labeldiv, "\n" );
			int labeldivSize = labeldiv.Size();
			//console.printf( TEXTCOLOR_DARKGRAY .. "realLabel: \"" .. TEXTCOLOR_DARKGREEN .. realLabel .. TEXTCOLOR_DARKGRAY .. "\". labeldivSize: " .. labeldivSize .. "." );

			for ( int i = labeldivSize - 1; i >= 0; i-- ) {
				//labeldiv[ i ].Replace( "\\c", "\c" ); // [McM] Not required for the localized strings.
				desc.mItems.Insert( startInjectIndex, new( "OptionMenuItemStaticText" ).Init( labeldiv[ i ] ) );
			}

			if ( desc.mSelectedItem > startInjectIndex )
				desc.mSelectedItem += labeldivSize;

			isWarningInjected = true;
		}

		Super.Ticker();
	} // of override void Ticker() {}

} // of class OptionMenuItemZCHandlerCheck: OptionMenuItemStaticText {}
