class ZCheckerCCMDInfo play {
	Array<String> args;			// Arguments excluding ZC-CCMD name;
	ZCheckerHandler handler;	// Pointer to EventHandler (some GZDoom versions strangely crashes on the "FindEventHandler()" calls);
	transient ConsoleEvent e;	// Pointer to the pure and non-altered structure.

	// Init or reinit:
	String InitFromEvent( ConsoleEvent initEvent ) {
		args.Clear();

		e = initEvent;
		e.Name.Split( args, ZCHECKER_AGRS_SEPARATOR, TOK_SKIPEMPTY );

		// If debug, display maximal amount of arguments (sometimes it saves
		//about ten minutes of the bughunting...):
		if ( ZCGlobal.Get().zcCurLogLevel == LL_Debug ) {
			int delimetersAmount = 0;

			for ( int i = 0; i < e.Name.Length(); i++ )
				if ( e.Name.CharAt( i ) == ZCHECKER_AGRS_SEPARATOR )
					delimetersAmount++;

			ZCGlobal.ClearscopeLog( LL_Debug, GetClassName() .. "::InitFromEvent(). Maximal amount of arguments (excluding name): " .. delimetersAmount );
		}

		String zcCommandName = "";

		if ( args.Size() ) {
			// Get rid of the event name:
			zcCommandName = args[ 0 ];
			args.Delete( 0, 1 );
		} else {
			ZCGlobal.ClearscopeLog( LL_Emergency, GetClassName() .. "::InitFromEvent(). Arguments is omitted." );
		}

		return zcCommandName;
	}
} // of class ZCheckerCCMDInfo {}


class ZCheckerField {
	uint fieldPos;
	Actor mo;				// Testee actor itself.
	EZCheckerInfoActorType actorType;
}


// Base ZChecker CCMD class.
class ZCConsoleClass abstract {
	enum EConsoleClassFlags {
		CCF_None			= 0,
		CCF_Important		= 0x0001,	// Will be shown without "zchelp all" argument.
		CCF_Unreleased		= 0x0002,	// CCMD: help will be colored in gray.
		CCF_NoCacheHelp		= 0x0004	// Help string will not be cached.
	};

	EConsoleClassFlags zcFlags;

	protected String helpCacheString;

	// Returns a new console class with determined importantment flag:
	static play ZCConsoleClass Create( class<ZCConsoleClass> classname, bool important = false ) {
		ZCConsoleClass created = ZCConsoleClass( new( classname ) );
		created.zcFlags = important? CCF_Important : CCF_None;

		return created;
	}

	// Override to set up flags (excluding CCF_Important) and other special stuff:
	virtual void OnLoad( void ) {
		zcFlags = CCF_None;
	}

	virtual void PostBeginPlay() {
		helpCacheString = "";

		bool important = zcFlags & CCF_Important;
		OnLoad();
		zcFlags = important? ( zcFlags | CCF_Important ) : ( zcFlags & ~CCF_Important );
	}

	// A wrapper which unites aliases and description to one nice string:
	virtual String GetHelpString( void ) {
		return TEXTCOLOR_RED .. "Wrong inheriting (\"" .. GetClassName() .. "::GetHelpString()\" isn't overrided).";
	}
} // of class ZCConsoleClass abstract play {}

class ZCConsoleSeparator: ZCConsoleClass {
	virtual String GetHelpSeparatorName( void ) {
		return "";
	}

	override final String GetHelpString( void ) {
		// Attempt to speed up help strings processing:
		if ( helpCacheString == "" || zcFlags & CCF_NoCacheHelp ) {
			helpCacheString = "";
			String title = GetHelpSeparatorName();
			int titleLen = title.Length();

			if ( titleLen > 70 ) {
				helpCacheString = " - - " .. title;
			} else {
				String sepDecor = " - - - - - - - - - - - - - - -";

				if ( titleLen != 0 ) {
					sepDecor = sepDecor.Left( sepDecor.Length() - titleLen );

					if ( sepDecor.Length() & 1 )
						sepDecor = sepDecor .. " ";
				}

				helpCacheString = sepDecor .. title .. sepDecor;
			}
		}

		return helpCacheString;
	} // of override final String GetHelpString( void ) {}

} // of class ZCConsoleSeparator: ZCConsoleClass {}

class ZCTooltipClass: ZCConsoleClass {
	const HEADER	= TEXTCOLOR_SAPPHIRE;
	const NORMAL	= TEXTCOLOR_WHITE;
	const DARKGRAY	= TEXTCOLOR_DARKGRAY;
	const HIGHLIGHT1= TEXTCOLOR_GOLD;
	const HIGHLIGHT2= TEXTCOLOR_DARKGREEN;

	protected String HighlightTextPart( String origstr, String boundPattern, String highlightColor ) {
		String outstr = "";
		int prevCharIndexStart = 0;
		int curCharIndex;
		bool highlight = false;

		while ( ( curCharIndex = origstr.IndexOf( boundPattern, prevCharIndexStart ) ) != -1 ) {
			highlight = !highlight;
			outstr = outstr .. origstr.Mid( prevCharIndexStart, curCharIndex - prevCharIndexStart ) .. ( highlight? highlightColor : NORMAL );

			prevCharIndexStart = curCharIndex + 2;
		}

		if ( !highlight )
			outstr = outstr .. origstr.Mid( prevCharIndexStart, origstr.Length() );

		return ( outstr == "" )? origstr : outstr;
	}

	String HighlightText( String str ) {
		str = HighlightTextPart( str, "~~", DARKGRAY );
		str = HighlightTextPart( str, "@@", HIGHLIGHT1 );
		str = HighlightTextPart( str, "##", HIGHLIGHT2 );

		return str;
	}

	virtual String GetPlaintext( void ) {
		return "";
	}
	virtual String GetExamples( void ) {
		return "";
	}

	override String GetHelpString( void ) {
		if ( helpCacheString == "" || zcFlags & CCF_NoCacheHelp ) {
			helpCacheString = "";
			String addtext = GetPlaintext();

			if ( addtext != "" )
				helpCacheString = helpCacheString .. HEADER .. "\\--------= =-----/\n| Tips: " .. NORMAL .. addtext .. "\n";

			addtext = GetExamples();

			if ( addtext != "" )
				helpCacheString = helpCacheString .. HEADER .. "\\------------= =-/\n| Examples:\n" .. NORMAL .. addtext .. "\n";
		}

		return helpCacheString;
	}
} // of class ZCTooltipClass: ZCConsoleClass {}



class ZCConsoleCommand: ZCConsoleClass abstract play {
	enum EClassnameParseStatus {
		CPS_Default = 0,
		CPS_Variable,
		CPS_RegexFound,
		CPS_RegexFailed
	};

	enum EPositionParseStatus {
		PPS_Error = -4,
		PPS_WrongPos = -3,
		PPS_Linetarget = -2,
		PPS_Self = -1,
		PPS_First = 0
	};


	EClassnameParseStatus classnameParseStatus;

	ZCheckerCCMDInfo ccmd;
	ZCTooltipClass helpTooltip;


	protected clearscope bool checkTesteePlace( int place ) {
		return ( place >= 0 && place < MaxTestee );
	}

	// Returns "true" is string is an integer; "converted" is a pointer:
	protected clearscope bool str2int_Ptr( in String str, out int converted, bool usesign = false ) {
		bool isInteger = false;

		if ( str && str.Length() ) {
			bool isSigned = false;

			int firstChar = str.CharCodeAt( 0 );

			if ( firstChar == 0x2D /* '-' */ && usesign ) {
				isSigned = true;
				str = str.Mid( 1, str.Length() - 1 );
				firstChar = str.CharCodeAt( 0 );
			}

			int tempConverted = str.ToInt();

			if ( ( firstChar >= 0x31 && firstChar <= 0x39 ) || ( firstChar == 0x30 && str.Length() == 1 ) ) {
				isInteger = ( usesign || !isSigned );
				converted = ( isSigned? -tempConverted : tempConverted );
			}
		}

		return isInteger;
	}

	// Gets a linetarget actor:
	protected play Actor LinetraceActor( Actor from = NULL ) {
		Actor outActor = NULL;
        FLineTraceData RemoteRay;

		if ( from == NULL )
			from = players[ ccmd.e.Player ].mo;

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::LinertraceActor(). Address of source actor: " .. from );

		from.LineTrace( from.Angle, 0xFFFF, from.Pitch, TRF_ALLACTORS, offsetz: from.height - 12, data: RemoteRay );

		if ( RemoteRay.HitType == TRACE_HitActor ) {
			outActor = RemoteRay.HitActor;

			if ( outActor is "ZCheckerActorInfo" && outActor.master )
				outActor = outActor.master;
		} else {
			ZCGlobal.Log( LL_Normal, "No available actors found in nearest 65535 mappixels." );
		}

		return outActor;
	} // of protected play Actor LinetraceActor( void ) {}


	protected EPositionParseStatus getPlaceTestee( out Actor newTestee, uint argpos = 0 ) {
		EPositionParseStatus newTesteePosStatus = PPS_Error;
		newTestee = NULL;

		String arg = ccmd.args[ argpos ];
		arg.ToLower();

		if ( arg == "self" || arg == "s" ) {			
			if ( newTestee = players[ ccmd.e.Player ].mo )
				newTesteePosStatus = PPS_Self;

		} else if ( arg.Left( 3 ) == "cam" ) {
			if ( newTestee = players[ ccmd.e.Player ].Camera )
				newTesteePosStatus = PPS_Self;

		} else if ( str2int_Ptr( arg, +newTesteePosStatus ) ) {
			if ( checkTesteePlace( --newTesteePosStatus ) ) {
				if ( !( newTestee = ccmd.handler.Testee[ newTesteePosStatus ].mo ) )
					ZCGlobal.Log( LL_Main, "No actor in position " .. ( newTesteePosStatus + 1 ) );
			} else {
				ZCGlobal.Log( LL_Main, TEXTCOLOR_YELLOW .. "Wrong position " .. ( newTesteePosStatus + 1 ) .. LLCOLOR_MAIN .. " (must be in range [1.." .. MaxTestee .. "])." );
				newTesteePosStatus = PPS_WrongPos;
			}
		} else if ( arg == "lt" || arg == "linetarget" ) {
			newTestee = LinetraceActor();
			newTesteePosStatus = PPS_Linetarget;
		} else {
			ZCGlobal.Log( LL_Main, TEXTCOLOR_YELLOW .. "Unknown placeholder \"" .. arg .. "\" in position " .. ( argpos + 1 ) .. TEXTCOLOR_DARKGRAY .. ". Possible values: " .. LLCOLOR_MAIN .. "1.." .. MaxTestee .. ", s[elf], cam[era], lt" .. TEXTCOLOR_DARKGRAY .. "|" .. LLCOLOR_MAIN .. "linetarget" .. TEXTCOLOR_DARKGRAY .. "." );
		}

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::getPlaceTestee(). Actor \"" .. ZCGlobal.ObjectName( newTestee ) .. "\" with status " .. newTesteePosStatus .. ". Arg \"" .. arg .. "\"." );

		return newTesteePosStatus;
	} // of protected EPositionParseStatus getPlaceTestee( out Actor newTestee, uint argpos = 0 ) {}


	// Returns "-1" if argument cannot be resolved as boolean, and "0"/"1" otherwise:
	protected int getBoolArg( uint argnum ) {
		int argxtype = -1;

		if ( argnum < ccmd.args.Size() ) {
			String argx = ccmd.args[ argnum ];

			if ( argx == "0" || argx ~== "false" || argx ~== "f" || argx ~== "reset" )
				argxtype = 0;
			else if ( argx == "1" || argx ~== "true" || argx ~== "t" || argx ~== "set" )
				argxtype = 1;
		} else {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::getBoolArg(). Argument " .. argnum .. " is too large (max " .. ccmd.args.Size() .. ")." );
		}

		return argxtype;
	}

	protected String GetInternalZCheckerString( String zcname ) {
		return ZCGlobal.Get().GetZCheckerString( zcname );
	}

	protected String ParseSpecialActorName( String classname, class<Actor> parentfilter = "Actor" ) {
		classnameParseStatus = CPS_Default;

		if ( classname.CharAt( 0 ) == "%" || classname.CharAt( 0 ) == "%%" )
			classname = "$" .. classname.Mid( 1, classname.Length() - 1 );

		if ( classname.Length() > 63 ) {
			classname.Truncate( 63 );
			ZCGlobal.Log( LL_Main, TEXTCOLOR_DARKGRAY .. GetClassName() .. "::ParseSpecialActorName(). " .. TEXTCOLOR_YELLOW .. "Value truncated " .. LLCOLOR_MAIN .. "to 63 characters (\"" .. classname .. "\")." );
		}

		String origValue = classname;
		String testSpecialValue = classname.Mid( 1, classname.Length() - 1 );
		testSpecialValue.ToLower();

		bool isSpecial = false;
		Actor caller = ( ccmd? players[ ccmd.e.Player ].mo : NULL );

		if ( caller ) {
			if ( testSpecialValue == "linetarget" || testSpecialValue == "lt" ) {
				isSpecial = true;
				classname = ZCGlobal.ObjectName( LinetraceActor( caller ) );
			} else if ( testSpecialValue == "self" ) {
				isSpecial = true;
				classname = caller.GetClassName();
			} else if ( testSpecialValue == "target" ) {
				isSpecial = true;
				classname = ZCGlobal.ObjectName( caller.target );
			} else if ( testSpecialValue == "master" ) {
				isSpecial = true;
				classname = ZCGlobal.ObjectName( caller.master );
			} else if ( testSpecialValue == "tracer" ) {
				isSpecial = true;
				classname = ZCGlobal.ObjectName( caller.tracer );
			}
		}

		if ( testSpecialValue == "null" || testSpecialValue == "none" ) {
			classnameParseStatus = CPS_Variable;
			classname = "";
		}


		int preventiveChoice = -1;
		int preventiveChoiceStrStart;

		if ( ( preventiveChoiceStrStart = classname.IndexOf( ":" ) ) == -1 )
			preventiveChoiceStrStart = classname.IndexOf( "," );

		if ( preventiveChoiceStrStart != -1 ) {
			String preventiveChoiceStr = classname.Mid( preventiveChoiceStrStart + 1, classname.Length() - preventiveChoiceStrStart - 1 );

			if ( !str2int_Ptr( preventiveChoiceStr, preventiveChoice ) ) {
				ZCGlobal.Log( LL_Main, TEXTCOLOR_YELLOW .. "\"" .. preventiveChoiceStr .. "\" isn't a numerical selection." );
				preventiveChoice = -1;
			}

			classname.Truncate( preventiveChoiceStrStart );
		} // of if ( preventiveChoiceStrStart != -1 ) {}


		if ( isSpecial ) {
			classnameParseStatus = CPS_Variable;
			ZCGlobal.Log( LL_Debug, GetClassName() .. "::ParseSpecialActorName(). Value \"" .. origValue .. "\" parsed as special placeholder and thus set to \"" .. classname .. "\"." );

			if ( classname == "" )
				ZCGlobal.Log( LL_Main, TEXTCOLOR_YELLOW .. "Skipped " .. LLCOLOR_MAIN .. "empty placeholder \"" .. origValue .. "\". You may use \"%%null\" or \"%%none\" to override this." );
		} else if ( classname.CharAt( 0 ) == "$" ) {
			classnameParseStatus = CPS_Variable;
			classname = GetInternalZCheckerString( classname );

			if ( classname == "" )
				ZCGlobal.Log( LL_Main, TEXTCOLOR_YELLOW .. "Skipped " .. LLCOLOR_MAIN .. "unset internal variable \"" .. origValue .. "\"." );

			isSpecial = true;
		} else if ( ccmd && ccmd.handler && ( classname.IndexOf( "*" ) != -1 || classname.IndexOf( "-" ) != -1 ) ) {
			String curpart = "";
			int lastpart = 0;
			int lastpartStartIndex = 0;
			bool specialchar = false;
			int skipchars = 0;
			bool onlySpecialChars = true;

			classname.ToLower();

			Array<String> parts;
			Array<int> partindices;
			parts.Clear();
			partindices.Clear();

			for ( int i = 0; i < classname.Length(); i++ ) {
				String curchar = classname.CharAt( i );

				if ( curchar == "*" ) {
					specialchar = true;
					skipchars--;
				} else if ( curchar == "-" ) {
					specialchar = true;
				} else {
					if ( specialchar ) {
						parts.Push( curpart );
						partindices.Push( lastpartStartIndex );

						lastpart++;
						curpart = "";
						lastpartStartIndex = i + skipchars;
						specialchar = false;
					}

					curpart = curpart .. curchar;
					onlySpecialChars = false;
				}
			} // of for ( int i = 0; i < classname.Length(); i++ ) {}

			if ( onlySpecialChars ) {
				ZCGlobal.Log( LL_Main, "Not provided any class identifier character." );
			} else {
				if ( lastpart != parts.Size() + 1 ) {
					parts.Push( curpart );
					partindices.Push( lastpartStartIndex );
				}

				if ( specialchar ) {
					parts.Push( "" );
					partindices.Push( classname.Length() - lastpartStartIndex + skipchars );
				}
			} // of else, of if ( onlySpecialChars ) {}


			//console.printf( TEXTCOLOR_PURPLE .. "parts.Size() " .. parts.Size() .. ", partindices.Size() " .. partindices.Size() .. ". " .. TEXTCOLOR_TEAL .. "curpart " .. curpart .. ", lastpart " .. lastpart .. " at " .. lastpartStartIndex .. ", skipchars " .. skipchars );

			if ( parts.Size() != partindices.Size() ) {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::ParseSpecialActorName(). Corrupter sizes: " .. TEXTCOLOR_WHITE .. "parts == " .. parts.Size() .. LLCOLOR_EMERGENCY .. ", " .. TEXTCOLOR_WHITE .. "part indices == " .. partindices.Size() .. LLCOLOR_EMERGENCY );

				for ( int i = 0; i < max( parts.Size(), partindices.Size() ); i++ )
					ZCGlobal.Log( LL_Main, TEXTCOLOR_DARKGRAY .. "Part #" .. i .. ": \c-\"" .. ( i < parts.Size()? parts[ i ] : TEXTCOLOR_RED .. "NONE" .. TEXTCOLOR_DARKGRAY ) .. "\"" .. TEXTCOLOR_DARKGRAY .. ", starts from \c-" .. ( i < partindices.Size()? partindices[ i ] .. "" : TEXTCOLOR_RED .. "NONE" .. TEXTCOLOR_DARKGRAY ) .. TEXTCOLOR_DARKGRAY );

			} else if ( parts.Size() > 1 ) {
				int firstSearchNameCellIndex = ( parts[ 0 ] != ""? ZCInternalActorNameCell.GetClassnameCellIndex( classname ) : -1 );
				int lastSearchNameCellIndex = ( firstSearchNameCellIndex == -1? ZCInternalActorNameCell.ARRAY_Quantity : firstSearchNameCellIndex + 1 );

				if ( firstSearchNameCellIndex == -1 )
					firstSearchNameCellIndex = 0;

				Array<String> nameCandidates;
				nameCandidates.Clear();

				ZCheckerHandler handler = ccmd.handler;

				for ( int i = firstSearchNameCellIndex; i < lastSearchNameCellIndex; i++ ) {
					ZCInternalActorNameCell cell = handler.allActorNames[ i ];

					for ( int j = 0; j < cell.names.Size(); j++ ) {
						String curname = cell.names[ j ];

						int curpartindex = partindices[ 1 ];
						bool candidateFound = true;

						if ( parts[ 0 ] != "" ) {
							if ( curname.Left( parts[ 0 ].Length() ) != parts[ 0 ] )
								candidateFound = false;
						}

						for ( int k = ( parts.Size() * !candidateFound ) + 1; k < parts.Size() - 1; k++ ) {
							//console.printf( "\"%20s\". Part " .. k .. ": from %2i \"" .. parts[ k ] .. "\", found at " .. curname.IndexOf( parts[ k ], curpartindex ), curname, curpartindex );
							int partFoundIndex = curname.IndexOf( parts[ k ], curpartindex );

							//console.printf( "\"%20s\": " .. TEXTCOLOR_DARKGRAY .. "partFoundIndex %i (<) partindices[ k ] %i.", curname, partFoundIndex, partindices[ k ] );

							if ( partFoundIndex == -1 || partFoundIndex < partindices[ k ] ) {
								candidateFound = false;
								//console.printf( "\"%20s\": " .. TEXTCOLOR_BRICK .. "break.", curname );
								break;
							}

							if ( k < parts.Size() - 1 )
								curpartindex = partFoundIndex + 1; //partindices[ k + 1 ];
						} // of for ( int k = 0; k < parts.Size(); k++ ) {}

						// Special last characters/symbols sequence handling:
						int partsPreSize = parts.Size() - 1;

						if ( candidateFound ) {
							//console.printf( "\"%20s\": " .. TEXTCOLOR_PURPLE .. "len %i (<) %i as ( curpartindex %i + ( partindex[-1] %i - namelen %i ).", curname, curname.Length(), curpartindex + partindices[ partsPreSize ], curpartindex, partindices[ partsPreSize ], classname.Length() );

							if ( parts[ partsPreSize ] != "" ) {
								curpartindex = max( curpartindex, curname.Length() - parts[ partsPreSize ].Length() );
								int partFoundIndex = curname.IndexOf( parts[ partsPreSize ], curpartindex );

								if ( partFoundIndex == -1 || partFoundIndex < partindices[ partsPreSize ] )
									candidateFound = false;

							// Handling a "word-" case:
							} else if ( curname.Length() < partindices[ partsPreSize ] ) {
								//console.printf( "\"%20s\": " .. TEXTCOLOR_BRICK .. "not found, len %i (<) partindex %i.", curname, curname.Length(), partindices[ partsPreSize ] );
								candidateFound = false;
							}
						}

						if ( candidateFound ) {
							class<Actor> curnameclass = Name( curname );

							if ( curnameclass is parentfilter )
								nameCandidates.Push( curname );
						}
					} // of for ( int j = 0; j < cell.names.Size(); j++ ) {}

				} // of for ( int i = firstSearchNameCellIndex; i < lastSearchNameCellIndex; i++ ) {}


				int nameCandidatesSize = nameCandidates.Size();

				String filtertip = "";
				if ( parentfilter != "Actor" )
					filtertip = TEXTCOLOR_DARKGRAY .. " with filter " .. TEXTCOLOR_WHITE .. parentfilter.GetClassName() .. TEXTCOLOR_DARKGRAY .. "" .. LLCOLOR_MAIN;

				if ( nameCandidatesSize == 1 ) {
					classnameParseStatus = CPS_RegexFound;
					classname = nameCandidates[ 0 ];
					ZCGlobal.Get().SetZCheckerString( "$parsed", classname );
				} else if ( nameCandidatesSize == 0 ) {
					classname = "";
					classnameParseStatus = CPS_RegexFailed;
					ZCGlobal.Log( LL_Main, "Cannot find any suitable actor name candidates" .. filtertip .. "." );
				} else {
					if ( preventiveChoice >= nameCandidatesSize ) {
						ZCGlobal.Log( LL_Main, "Selected index " .. TEXTCOLOR_TEAL .. preventiveChoice .. LLCOLOR_MAIN .. " is " .. TEXTCOLOR_YELLOW .. "out of range" .. LLCOLOR_MAIN .. " of the found candidates." );
						preventiveChoice = -1;
					}

					if ( preventiveChoice != -1 ) {
						classname = nameCandidates[ preventiveChoice ];
						classnameParseStatus = CPS_RegexFound;
						ZCGlobal.Get().SetZCheckerString( "$parsed", classname );
					} else {
						classname = "";
						classnameParseStatus = CPS_RegexFailed;

						ZCGlobal.Log( LL_Main, "Found more than one suitable actor name candidate" .. filtertip .. ":" );

						for ( int i = 0; i < nameCandidatesSize; i++ )
							ZCGlobal.Log( LL_Main, TEXTCOLOR_DARKGRAY .. i .. ". \"" .. TEXTCOLOR_WHITE .. nameCandidates[ i ] .. TEXTCOLOR_DARKGRAY .. "\"." );
					}
				}
			} // of if ( parts.Size() > 1 ) {}

		} else if ( preventiveChoice != -1 ) {
			ZCGlobal.Log( LL_Main, "Ignoring numerical selection " .. preventiveChoice );
		}

		return classname;
	} // of protected String ParseSpecialActorName( String classname ) {}

	protected bool SetInternalZCheckerString( String zcname, String value ) {
		if ( zcname.CharAt( 0 ) == "%" || zcname.CharAt( 0 ) == "%%" )
			zcname = "$" .. zcname.Mid( 1, zcname.Length() - 1 );

		if ( zcname.Length() > 63 ) {
			zcname.Truncate( 63 );
			ZCGlobal.Log( LL_Main, TEXTCOLOR_YELLOW .. "Variable name truncated " .. LLCOLOR_MAIN .. "to 63 characters (\"" .. zcname .. "\")." );
		}

		String newValue;

		newValue = ParseSpecialActorName( value );

		if ( ( classnameParseStatus == CPS_Variable ) || ( newValue != "" ) )
			return ZCGlobal.Get().SetZCheckerString( zcname, newValue );

		return false;
	}

	// Returns help aliases/description string for a class:
	protected String getHelpByClass( class<ZCConsoleCommand> classname, bool desc = false ) {
		ZCConsoleCommand temp = ZCConsoleCommand( new( classname ) );

		String outHelpString = desc? temp.GetHelpDescString() : temp.GetHelpNameString();

		temp.Destroy();

		return outHelpString;
	} // of protected String getHelpByClass( class<ZCConsoleCommand> classname, bool desc = false ) {}


	// Returns linked netevent command name (see KEYCONF):
	clearscope virtual String GetCommand( void ) const {
		return "";
	}

	// Returns aliases separated by a semicolon:
	virtual String GetHelpNameString( void ) const {
		return TEXTCOLOR_RED .. GetClassName() .. "::GetHelpNameString() usage example: \"zcAlias <arg>;zcAlias2;zc-alias [<arg1>] [<arg2>]\"\c-";
	}

	// Returns usage quick help (command description):
	virtual String GetHelpDescString( void ) const {
		return GetCommand() .. " help!";
	}

	// A wrapper which unites aliases and description to one nice string:
	final override String GetHelpString( void ) {
		// Attempt to speed up help strings processing:
		if ( helpCacheString == "" || zcFlags & CCF_NoCacheHelp ) {
			helpCacheString = "";

			Array<String> aliases;
			GetHelpNameString().Split( aliases, ";", TOK_SKIPEMPTY );

			bool unreleased = !!( zcFlags & CCF_Unreleased );

			String ccmdColorHeader = ( unreleased? CCMDCOLOR_TITLEWIP : CCMDCOLOR_TITLE );
			String ccmdColorArgs   = ( unreleased? CCMDCOLOR_TITLEWIP : CCMDCOLOR_TITLEARGS );

			for ( int i = 0; i < aliases.Size(); i++ ) {
				int spaceIndex = aliases[ i ].IndexOf( " " );
				if ( spaceIndex != -1 )
					aliases[ i ] = ccmdColorHeader .. aliases[ i ].Left( spaceIndex ) .. ccmdColorArgs .. aliases[ i ].Mid( spaceIndex, aliases[ i ].Length() - spaceIndex );

				aliases[ i ].Replace( "|", TEXTCOLOR_BRICK .. "|" .. ccmdColorArgs );
				aliases[ i ].Replace( "[", TEXTCOLOR_DARKGRAY .. "[" .. ccmdColorArgs );
				aliases[ i ].Replace( "]", TEXTCOLOR_DARKGRAY .. "]" .. ccmdColorArgs );
				aliases[ i ].Replace( "<", TEXTCOLOR_LIGHTBLUE .. "<" .. ccmdColorArgs );
				aliases[ i ].Replace( ">", TEXTCOLOR_LIGHTBLUE .. ">" .. ccmdColorArgs );
			}

			// Extra aliases:
			for ( int i = 0; i < aliases.Size() - 1; i++ )
				helpCacheString = helpCacheString .. ccmdColorArgs .. aliases[ i ] .. CCMDCOLOR_DESC .. ",\n";

			// Last alias and a description:
			helpCacheString = helpCacheString .. ccmdColorArgs .. aliases[ aliases.Size() - 1 ] .. CCMDCOLOR_DESC .. ":\n  " .. ( unreleased? TEXTCOLOR_ORANGE .. "[WIP] " .. CCMDCOLOR_TITLEWIP : CCMDCOLOR_DESC ) .. GetHelpDescString();

			String lastChar = helpCacheString.CharAt( helpCacheString.Length() - 1 );

			if ( !( lastChar == "." || lastChar == "!" || lastChar == "?" ) )
				helpCacheString = helpCacheString .. ".";
		}

		return helpCacheString;
	}

	// Returns "true" if all args provided right, "false" otherwise:
	virtual bool HandleArguments() {
		return false;
	}

	// Command itself:
	virtual void DoCommand( void ) { }

} // of class ZCConsoleCommand abstract {}


class ZCBaseInfoPanelPart abstract {
	protected bool playScoped;

	const NORMAL	= TEXTCOLOR_NORMAL;
	const N			= NORMAL;
	const BRICK		= TEXTCOLOR_BRICK;
	const TAN		= TEXTCOLOR_TAN;
	const GRAY		= TEXTCOLOR_GRAY;
	const GREY		= TEXTCOLOR_GREY;
	const GREEN		= TEXTCOLOR_GREEN;
	const BROWN		= TEXTCOLOR_BROWN;
	const GOLD		= TEXTCOLOR_GOLD;
	const RED		= TEXTCOLOR_RED;
	const BLUE		= TEXTCOLOR_BLUE;
	const ORANGE	= TEXTCOLOR_ORANGE;
	const WHITE		= TEXTCOLOR_WHITE;
	const YELLOW	= TEXTCOLOR_YELLOW;
	const BLACK		= TEXTCOLOR_BLACK;
	const LIGHTBLUE	= TEXTCOLOR_LIGHTBLUE;
	const CREAM		= TEXTCOLOR_CREAM;
	const OLIVE		= TEXTCOLOR_OLIVE;
	const DARKGREEN	= TEXTCOLOR_DARKGREEN;
	const DARKRED	= TEXTCOLOR_DARKRED;
	const DARKBROWN	= TEXTCOLOR_DARKBROWN;
	const PURPLE	= TEXTCOLOR_PURPLE;
	const DARKGRAY	= TEXTCOLOR_DARKGRAY;
	const CYAN		= TEXTCOLOR_CYAN;
	const ICE		= TEXTCOLOR_ICE;
	const FIRE		= TEXTCOLOR_FIRE;
	const SAPPHIRE	= TEXTCOLOR_SAPPHIRE;
	const TEAL		= TEXTCOLOR_TEAL;

	ZCheckerHandler handler;

	String optionCVarName;
	String optionLabel;
	String optionSubmenuName;


	static ZCBaseInfoPanelPart Create( class<ZCBaseInfoPanelPart> panelclass, ZCheckerHandler globalHandler ) {
		ZCBaseInfoPanelPart panel = ZCBaseInfoPanelPart( new( panelclass ) );

		panel.handler = globalHandler;
		panel.OnCreate();
		panel.playScoped = false;

		return panel;
	}

	bool IsPlayScope( void ) {
		return playScoped;
	}

	virtual void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_...";
		optionLabel = "<" .. GetClassName() .. ">";
		optionSubmenuName = "";
	}

	ui virtual String GetInfo( Actor thing, ZCheckerField thingfield ) {
		return GetClassName() .. "::GetInfo(). Not overrided.";
	}

	/*play virtual String GetInfo_play( Actor thing, ZCheckerField thingfield ) {
		return GetClassName() .. "::GetInfo_play(). Not overrided.";
	}*/

	ui virtual String GetSubmenuLabel( ZCOptionMenuItemInfopanel masterMenuItem, OptionMenuDescriptor submenuDesc ) {
		String label = "Submenu. ";

		int i = 0;

		for ( ; i < submenuDesc.mItems.Size() && label.Length() < 30; i++ ) {
			OptionMenuItem cur = OptionMenuItem( submenuDesc.mItems[ i ] );

			String addlabel = "";

			if ( cur is 'OptionMenuItemOption' ) {
				OptionMenuItemOption curoption = OptionMenuItemOption( cur );
				addlabel = StringTable.Localize( OptionValues.GetText( curoption.mValues, curoption.GetSelection() ) );

				if ( addlabel.Length() == 0 )
					addlabel = "Unknown";
			} else if ( cur is 'OptionMenuItemSlider' ) {
				OptionMenuItemSlider curslider = OptionMenuItemSlider( cur );
				addlabel = String.Format( String.Format( "%%.%df", curslider.mShowValue ), curslider.GetSliderValue() );
			}

			if ( addlabel != "" )
				label = label .. "\"" .. cur.mLabel .. ":" .. addlabel .. "\" ";
		}

		if ( i < submenuDesc.mItems.Size() )
			label = label .. " [...more]";

		return label;
	}


	protected PlayerPawn getItemPlayerOwner( Inventory item ) {
		PlayerPawn ownerPlayer = PlayerPawn( item.Owner );

		return ( ( ownerPlayer && ownerPlayer.player && ownerPlayer.player.ReadyWeapon )? ownerPlayer : NULL );
	}

	protected bool isItemPickedupWeapon( Actor item ) {
		return !!( item is "StateProvider" && getItemPlayerOwner( Inventory( item ) ) );
	}
} // of class ZCBaseInfoPanelPart abstract {}

class ZCBaseInfoPanelPart_PlayScope: ZCBaseInfoPanelPart abstract play {
	Array<String> playscopedInfo;

	play static ZCBaseInfoPanelPart_PlayScope CreatePlayScope( class<ZCBaseInfoPanelPart> panelclass, ZCheckerHandler globalHandler ) {
		ZCBaseInfoPanelPart_PlayScope panel = ZCBaseInfoPanelPart_PlayScope( new( panelclass ) );

		panel.handler = globalHandler;
		panel.OnCreate_play();
		panel.playScoped = true;

		for ( int i = 0; i < MaxTestee; i++ )
			panel.playscopedInfo.Push( "" );

		return panel;
	}

	play virtual void OnCreate_play( void ) {
		Super.OnCreate();
	}

	play virtual String GetInfo_play( Actor thing, ZCheckerField thingfield ) {
		return RED .. GetClassName() .. "::GetInfo_play(). Not overrided.";
	}

	clearscope String InternalGetInfo_clearscope( int index ) {
		return playscopedInfo[ index ];
	}

	final override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		return RED .. GetClassName() .. "::GetInfo(). " .. FIRE .. "Override \"GetInfo_play()\" instead" .. RED .. ".";
	}
}
