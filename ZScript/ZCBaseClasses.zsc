//
// Base ZChecker API classes: CCMDs, infopanels, tooltips etc.
//

// Class to be handled with the ZChecker console manager.
// Also inherits a ZChecker CCMDs.
class ZCConsoleClass abstract {
	enum EConsoleClassFlags {
		CCF_None			= 0,
		CCF_Important		= 0x0001,	// Will be shown without "zchelp all" argument.
		CCF_NoCacheHelp		= 0x0002	// Help string will not be cached (handled in the "GetHelpString()".
	};

	EConsoleClassFlags zcFlags;

	protected String helpCacheString;

	// Returns a new console class with determined importantment flag:
	static play ZCConsoleClass Create( class<ZCConsoleClass> classname, bool important = false ) {
		ZCConsoleClass created = ZCConsoleClass( new( classname ) );
		created.zcFlags = important? CCF_Important : CCF_None;

		return created;
	}

	// Override to set up flags (without CCF_Important, which has special 
	//handling) and other init stuff in all console class inheritances:
	virtual virtualscope void OnLoad( void ) {
		zcFlags = CCF_None;
		helpCacheString = "";
	}

	// A wrapper which unites aliases and description to one nice string:
	virtual String GetHelpString( void ) {
		return TEXTCOLOR_RED .. "Wrong inheriting (\"" .. GetClassName() .. "::GetHelpString()\" isn't overrided).";
	}
} // of class ZCConsoleClass abstract {}

class ZCConsoleSeparator: ZCConsoleClass {
	virtual String GetHelpSeparatorName( void ) {
		return "";
	}

	final override String GetHelpString( void ) {
		// Attempt to speed up help strings processing:
		if ( helpCacheString == "" || zcFlags & CCF_NoCacheHelp ) {
			helpCacheString = "";
			String title = GetHelpSeparatorName();
			int titleLen = title.Length();

			if ( titleLen > 70 ) {
				helpCacheString = " - - " .. title;
			} else {
				String sepDecor = " - - - - - - - - - - - - - - -";

				if ( titleLen != 0 ) {
					sepDecor = sepDecor.Left( sepDecor.Length() - titleLen );

					if ( sepDecor.Length() & 1 )
						sepDecor = sepDecor .. " ";
				}

				helpCacheString = sepDecor .. title .. sepDecor;
			}
		}

		return helpCacheString;
	} // of final override String GetHelpString( void ) {}

} // of class ZCConsoleSeparator: ZCConsoleClass {}

class ZCTooltipClass: ZCConsoleClass {
	const HEADER	= TEXTCOLOR_SAPPHIRE;
	const NORMAL	= TEXTCOLOR_WHITE;
	const DARKGRAY	= TEXTCOLOR_DARKGRAY;
	const COMMAND	= TEXTCOLOR_LIGHTBLUE;
	const HIGHLIGHT1= TEXTCOLOR_GOLD;
	const HIGHLIGHT2= TEXTCOLOR_DARKGREEN;

	const TABSYMBOL	= "	";
	const LISTPREFIX= " " .. TEXTCOLOR_BLACK .. "-" .. LLCOLOR_MAIN .. " ";

	String HighlightText( String origstr ) {
		String outstr = "";
		int prevCharIndexStart = 0;
		int curCharIndex;
		int prevTypeChar = -1;

		while ( ( curCharIndex = origstr.IndexOf( "`", prevCharIndexStart ) ) != -1 ) {
			outstr = outstr .. origstr.Mid( prevCharIndexStart, curCharIndex - prevCharIndexStart );

			int typechar = origstr.CharCodeAt( curCharIndex + 1 );

			// Converting to uppercase:
			if ( typechar >= LETTER_A_LOWER && typechar <= LETTER_Z_LOWER )
				typechar &= ~0x20;

			if ( typechar == prevTypeChar ) {
				outstr = outstr .. NORMAL;
				typechar = -1;
			} else {
				switch ( typechar ) {
					// '0', 'N', 'X', '-':
					case 0x30: case 78: case 88: case 45:
						outstr = outstr .. NORMAL;
						break;
					// 'C', '@':
					case 67: case 64:
						outstr = outstr .. COMMAND;
						break;
					// '1', 'Y', '!':
					case 0x31: case 89:
						outstr = outstr .. HIGHLIGHT1;
						break;
					// '2', 'G':
					case 0x32: case 71:
						outstr = outstr .. HIGHLIGHT2;
						break;
					// '3', 'D', '~':
					case 0x33: case 68: case 126:
						outstr = outstr .. DARKGRAY;
						break;
					// 'A', 'H':
					case 65: case 72:
						outstr = outstr .. HEADER;
						break;
					// '`':
					case 96:
						outstr = outstr .. "`";
						break;
					default:
						typechar = -1;
						break;
				} // of switch ( typechar ) {}
			} // of else of if ( typechar == prevTypeChar ) {}

			prevTypeChar = typechar;

			prevCharIndexStart = curCharIndex + 2;
		} // of while ( ( curCharIndex = origstr.IndexOf( "`", prevCharIndexStart ) ) != -1 ) {}

		outstr = outstr .. origstr.Mid( prevCharIndexStart, origstr.Length() );

		return outstr;
	} // of String HighlightText( String origstr ) {}

	String IndentTabList( String str ) {
		if ( str.CharCodeAt( 0 ) == 0x09 )
			str = LISTPREFIX .. str;

		str.Replace( TABSYMBOL, LISTPREFIX );

		return str;
	}

	String IndentTabs( String str ) {
		if ( str.CharCodeAt( 0 ) == 0x09 )
			str = "  " .. str;

		str.Replace( TABSYMBOL, "  " );

		return str;
	} // of String IndentTabs( String origstr ) {}

	String IndentNewlines( String str ) {
		if ( str.CharCodeAt( 0 ) != " " )
			str = "  " .. str;

		str.Replace( "\n", "\n  " );

		return str;
	} // of String IndentNewlines( String origstr ) {}


	virtual String GetPlaintext( void ) {
		return "";
	}
	virtual String GetTips( void ) {
		return "";
	}
	virtual String GetExamples( void ) {
		return "";
	}

	override String GetHelpString( void ) {
		if ( helpCacheString == "" || ( zcFlags & CCF_NoCacheHelp ) ) {
			helpCacheString = "";
			String addtext = GetPlaintext();

			if ( addtext != "" )
				helpCacheString = NORMAL .. addtext .. "\n";

			addtext = GetTips();

			if ( addtext != "" )
				helpCacheString = helpCacheString .. HEADER .. "\\--------= =-----/\n" .. HEADER .. "| Tips:\n" .. NORMAL .. addtext .. "\n";

			addtext = GetExamples();

			if ( addtext != "" )
				helpCacheString = helpCacheString .. HEADER .. "\\------------= =-/\n" .. HEADER .. "| Examples:\n" .. NORMAL .. IndentNewlines( addtext ) .. "\n";
		}

		return helpCacheString;
	}
} // of class ZCTooltipClass: ZCConsoleClass {}



struct ZCheckerCCMDInterfaceData {
	// Linked netevent command name (see KEYCONF):
	String neteventName;

	// Aliases separated by a semicolon:
	String helpHeader;
	// Usage quick help (command description):
	String helpDesc;

	// A tooltip class (extra information which is being printed via "zchelp <command>"):
	ZCTooltipClass helpTooltip;
};

class ZCConsoleCommand: ZCConsoleClass abstract play {
	enum EConsoleCommandFlags {
		// <enum EConsoleCommandFlags {}>.
		CCF_Unreleased			= 0x0004,	// Help will be colored in dark gray.

		CCF_NonblockingFailure	= 0x0008,	// Testing of the subsequent ZChecker CCMDs will not stop when "HandleArguments()" \
		CCF_NonblockingSuccess	= 0x0010,	//for this netevent returns false for "Failure" and true for "Success".
	};

	enum EClassnameParseStatus {
		CPS_Default = 0,
		CPS_Variable,
		CPS_RegexFound,
		CPS_RegexFailed
	};

	enum EPositionParseStatus {
		PPS_Error = -4,
		PPS_WrongPos = -3,
		PPS_Linetarget = -2,
		PPS_Self = -1,
		PPS_First = 0
	};


	EClassnameParseStatus classnameParseStatus;

	ZCheckerCCMDInfo ccmd;
	ZCheckerCCMDInterfaceData ccmdInterfaceData;


	protected void SetupCCMDInterface( String neteventname, String helpheader, String helpdesc, class<ZCTooltipClass> tooltipClass = NULL ) {
		ccmdInterfaceData.neteventName = neteventname;
		ccmdInterfaceData.helpHeader = helpheader;
		ccmdInterfaceData.helpDesc = helpdesc;

		if ( tooltipClass ) {
			ccmdInterfaceData.helpTooltip = ZCTooltipClass( new( tooltipClass ) );
			//ZCTooltipClass( ZCGlobal.Get().zcHandler.LocateZCConsoleClass( tooltipClass ) );
		}
	} // of protected void SetupCCMDInterface( String neteventname, String helpheader, String helpdesc, class<ZCTooltipClass> tooltip = NULL ) {}

	// Call "SetupCCMDInterface()" here:
	virtual void InitCCMD( void ) /*abstract*/ {
		/* SetupCCMDInterface(); */
	}

	// Returns "true" if all args provided right, "false" otherwise:
	virtual bool HandleArguments() {
		return false;
	}

	// Command itself:
	virtual void DoCommand( void ) { }



	private clearscope void printInitMissedWarning( String whatmissed ) {
		ZCGlobal.ClearscopeLog( LL_Emergency, GetClassName() .. "::OnLoad(). Missed " .. whatmissed .. " in the " .. TEXTCOLOR_WHITE .. "InitCCMD()" .. LLCOLOR_EMERGENCY .. " overload." );
	}

	final override void OnLoad( void ) {
		Super.OnLoad();

		ccmdInterfaceData.neteventName = "-";
		ccmdInterfaceData.helpHeader = "";
		ccmdInterfaceData.helpDesc = "";
		ccmdInterfaceData.helpTooltip = NULL;

		InitCCMD();

		if ( ccmdInterfaceData.neteventName == "-" )
			printInitMissedWarning( "netevent name" );

		if ( ccmdInterfaceData.helpHeader == "" ) {
			printInitMissedWarning( "help header" );
			ccmdInterfaceData.helpHeader = TEXTCOLOR_RED .. GetClassName() .. "::InitCCMD() usage example: \"zcAlias <arg>;zcAlias2;zc-alias [<arg1>] [<arg2>]\"\c-";
		}

		if ( ccmdInterfaceData.helpDesc == "" ) {
			printInitMissedWarning( "help description" );
			ccmdInterfaceData.helpDesc = "No help description provided in the " .. GetClassName() .. "::InitCCMD().";
		}
	} // of override void OnLoad( void ) {}

	protected clearscope bool checkTesteePlace( int place ) {
		return ( place >= 0 && place < MaxTestee );
	}

	// Returns "true" is string is an integer; "converted" is a pointer:
	protected clearscope bool str2int_Ptr( in String str, out int converted, bool usesign = false ) {
		bool isInteger = false;

		if ( str && str.Length() ) {
			bool isSigned = false;

			int firstChar = str.CharCodeAt( 0 );

			if ( firstChar == 0x2D /* '-' */ && usesign ) {
				isSigned = true;
				str = str.Mid( 1, str.Length() - 1 );
				firstChar = str.CharCodeAt( 0 );
			}

			int tempConverted = str.ToInt();

			if ( ( firstChar >= 0x31 && firstChar <= 0x39 ) || ( firstChar == 0x30 && str.Length() == 1 ) ) {
				isInteger = ( usesign || !isSigned );
				converted = ( isSigned? -tempConverted : tempConverted );
			}
		}

		return isInteger;
	}

	// Gets a linetarget actor:
	protected play Actor LinetraceActor( Actor from = NULL ) {
		Actor outActor = NULL;
        FLineTraceData remoteRay;

		if ( from == NULL )
			from = players[ ccmd.e.Player ].mo;

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::LinertraceActor(). Address of source actor: " .. from );

		from.LineTrace( from.angle, 0xFFFF, from.pitch, TRF_ALLACTORS, offsetz: from.height - 12, data: remoteRay );

		if ( remoteRay.HitType == TRACE_HitActor ) {
			outActor = remoteRay.HitActor;

			if ( outActor is "ZCheckerActorInfo" && ZCGlobal.SpecialZCActorsHandling() ) {
				if ( outActor.master ) {
					outActor = outActor.master;
				} else {
					ZCGlobal.Log( LL_Normal, TEXTCOLOR_DARKGRAY .. "Skipped special class \"" .. outActor.GetClassName() .. "\"." );
					outActor = NULL;
				}
			}
		} else {
			ZCGlobal.Log( LL_Normal, "No available linetarget actors found." );
		}

		return outActor;
	} // of protected play Actor LinetraceActor( Actor from = NULL ) {}


	protected EPositionParseStatus getPlaceTestee( out Actor newTestee, uint argpos = 0 ) {
		EPositionParseStatus newTesteePosStatus = PPS_Error;
		newTestee = NULL;

		String arg = ccmd.args[ argpos ];
		arg.ToLower();

		if ( arg == "self" || arg == "s" ) {			
			if ( newTestee = players[ ccmd.e.Player ].mo )
				newTesteePosStatus = PPS_Self;

		} else if ( arg.Left( 3 ) == "cam" ) {
			if ( newTestee = players[ ccmd.e.Player ].Camera )
				newTesteePosStatus = PPS_Self;

		} else if ( str2int_Ptr( arg, +newTesteePosStatus ) ) {
			if ( checkTesteePlace( --newTesteePosStatus ) ) {
				if ( !( newTestee = ccmd.handler.Testee[ newTesteePosStatus ].mo ) )
					ZCGlobal.Log( LL_Main, "No actor in position " .. ( newTesteePosStatus + 1 ) );
			} else {
				ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Wrong position " .. ( newTesteePosStatus + 1 ) .. LLCOLOR_MAIN .. " (must be in range [1.." .. MaxTestee .. "])." );
				newTesteePosStatus = PPS_WrongPos;
			}
		} else if ( arg == "lt" || arg == "linetarget" ) {
			newTestee = LinetraceActor();
			newTesteePosStatus = PPS_Linetarget;
		} else {
			ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Unknown placeholder \"" .. arg .. "\" in position " .. ( argpos + 1 ) .. TEXTCOLOR_DARKGRAY .. ". Possible values: " .. LLCOLOR_MAIN .. "1.." .. MaxTestee .. ", s[elf], cam[era], lt" .. TEXTCOLOR_DARKGRAY .. "|" .. LLCOLOR_MAIN .. "linetarget" .. TEXTCOLOR_DARKGRAY .. "." );
		}

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::getPlaceTestee(). Actor \"" .. ZCGlobal.ObjectName( newTestee ) .. "\" with status " .. newTesteePosStatus .. ". Arg[ " .. argpos .. " ] == \"" .. arg .. "\"." );

		return newTesteePosStatus;
	} // of protected EPositionParseStatus getPlaceTestee( out Actor newTestee, uint argpos = 0 ) {}


	// Returns "-1" if argument cannot be resolved as boolean, and "0"/"1" otherwise:
	protected int getBoolArg( uint argnum ) {
		int argxtype = -1;

		if ( argnum < ccmd.args.Size() ) {
			String argx = ccmd.args[ argnum ];

			if ( argx == "0" || argx ~== "false" || argx ~== "f" || argx ~== "reset" )
				argxtype = 0;
			else if ( argx == "1" || argx ~== "true" || argx ~== "t" || argx ~== "set" )
				argxtype = 1;
		} else {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::getBoolArg(). Argument index " .. argnum .. " is out of bounds (max " .. ccmd.args.Size() .. ")." );
		}

		return argxtype;
	}

	protected String GetInternalZCheckerString( String zcname ) {
		return ZCGlobal.Get().GetZCheckerString( zcname );
	}

	protected String ParseSpecialActorName( String classname, class<Actor> parentfilter = "Actor" ) {
		classnameParseStatus = CPS_Default;

		if ( classname.CharAt( 0 ) == "%" || classname.CharAt( 0 ) == "%%" )
			classname = "$" .. classname.Mid( 1, classname.Length() - 1 );

		if ( classname.Length() > 63 ) {
			classname.Truncate( 63 );
			ZCGlobal.Log( LL_Main, TEXTCOLOR_DARKGRAY .. GetClassName() .. "::ParseSpecialActorName(). " .. LLCOLOR_WARNING .. "Value truncated " .. LLCOLOR_MAIN .. "to 63 characters (\"" .. classname .. "\")." );
		}

		String origValue = classname;
		String testSpecialValue = classname.Mid( 1, classname.Length() - 1 );
		testSpecialValue.ToLower();

		bool isSpecial = false;
		Actor caller = ( ccmd? players[ ccmd.e.Player ].mo : NULL );

		if ( caller ) {
			Actor found = NULL;

			if ( testSpecialValue == "linetarget" || testSpecialValue == "lt" ) {
				isSpecial = true;
				found = LinetraceActor( caller );
			} else if ( testSpecialValue == "self" ) {
				isSpecial = true;
				found = caller;
			} else if ( testSpecialValue == "target" ) {
				isSpecial = true;
				found = caller.target;
			} else if ( testSpecialValue == "master" ) {
				isSpecial = true;
				found = caller.master;
			} else if ( testSpecialValue == "tracer" ) {
				isSpecial = true;
				found = caller.tracer;
			}

			if ( isSpecial )
				classname = ( found? ZCGlobal.ObjectName( found ) : "" );
		}

		if ( testSpecialValue == "null" || testSpecialValue == "none" ) {
			classnameParseStatus = CPS_Variable;
			classname = "";
		}


		int preventiveChoice = -1;
		int preventiveChoiceStrStart;

		if ( ( preventiveChoiceStrStart = classname.IndexOf( ":" ) ) == -1 )
			preventiveChoiceStrStart = classname.IndexOf( "," );

		if ( preventiveChoiceStrStart != -1 ) {
			String preventiveChoiceStr = classname.Mid( preventiveChoiceStrStart + 1, classname.Length() - preventiveChoiceStrStart - 1 );

			if ( !str2int_Ptr( preventiveChoiceStr, preventiveChoice ) ) {
				preventiveChoice = -1;
			}

			if ( preventiveChoice < 1 ) {
				ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Selection \"" .. preventiveChoiceStr .. "\" isn't a positive integer." );
				preventiveChoice = -1;
			}

			classname.Truncate( preventiveChoiceStrStart );
		} // of if ( preventiveChoiceStrStart != -1 ) {}


		if ( isSpecial ) {
			classnameParseStatus = CPS_Variable;
			ZCGlobal.Log( LL_Debug, GetClassName() .. "::ParseSpecialActorName(). Value \"" .. origValue .. "\" parsed as special placeholder and thus set to \"" .. classname .. "\"." );

			if ( classname == "" )
				ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Skipped " .. LLCOLOR_MAIN .. "empty placeholder \"" .. origValue .. "\". You may use \"%%null\" or \"%%none\" to override this." );
		} else if ( classname.CharAt( 0 ) == "$" ) {
			classnameParseStatus = CPS_Variable;
			classname = GetInternalZCheckerString( classname );

			if ( classname == "" )
				ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Skipped " .. LLCOLOR_MAIN .. "unset internal variable \"" .. origValue .. "\"." );

			isSpecial = true;
		} else if ( ccmd && ccmd.handler && ( classname.IndexOf( "*" ) != -1 || classname.IndexOf( "-" ) != -1 ) ) {
			String curpart = "";
			int lastpart = 0;
			int lastpartStartIndex = 0;
			bool specialchar = false;
			int skipchars = 0;
			bool onlySpecialChars = true;

			classname.ToLower();

			Array<String> parts;
			Array<int> partindices;
			parts.Clear();
			partindices.Clear();

			for ( int i = 0; i < classname.Length(); i++ ) {
				String curchar = classname.CharAt( i );

				if ( curchar == "*" ) {
					specialchar = true;
					skipchars--;
				} else if ( curchar == "-" ) {
					specialchar = true;
				} else {
					if ( specialchar ) {
						parts.Push( curpart );
						partindices.Push( lastpartStartIndex );

						lastpart++;
						curpart = "";
						lastpartStartIndex = i + skipchars;
						specialchar = false;
					}

					curpart = curpart .. curchar;
					onlySpecialChars = false;
				}
			} // of for ( int i = 0; i < classname.Length(); i++ ) {}

			if ( onlySpecialChars ) {
				ZCGlobal.Log( LL_Main, "Not provided any class identifier character." );
			} else {
				if ( lastpart != parts.Size() + 1 ) {
					parts.Push( curpart );
					partindices.Push( lastpartStartIndex );
				}

				if ( specialchar ) {
					parts.Push( "" );
					partindices.Push( classname.Length() - lastpartStartIndex + skipchars );
				}
			} // of else, of if ( onlySpecialChars ) {}


			//console.printf( TEXTCOLOR_PURPLE .. "parts.Size() " .. parts.Size() .. ", partindices.Size() " .. partindices.Size() .. ". " .. TEXTCOLOR_TEAL .. "curpart " .. curpart .. ", lastpart " .. lastpart .. " at " .. lastpartStartIndex .. ", skipchars " .. skipchars );

			if ( parts.Size() != partindices.Size() ) {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::ParseSpecialActorName(). Corrupter sizes: " .. TEXTCOLOR_WHITE .. "parts == " .. parts.Size() .. LLCOLOR_EMERGENCY .. ", " .. TEXTCOLOR_WHITE .. "part indices == " .. partindices.Size() .. LLCOLOR_EMERGENCY );

				for ( int i = 0; i < max( parts.Size(), partindices.Size() ); i++ )
					ZCGlobal.Log( LL_Main, TEXTCOLOR_DARKGRAY .. "Part #" .. i .. ": \c-\"" .. ( i < parts.Size()? parts[ i ] : TEXTCOLOR_RED .. "NONE" .. TEXTCOLOR_DARKGRAY ) .. "\"" .. TEXTCOLOR_DARKGRAY .. ", starts from \c-" .. ( i < partindices.Size()? partindices[ i ] .. "" : TEXTCOLOR_RED .. "NONE" .. TEXTCOLOR_DARKGRAY ) .. TEXTCOLOR_DARKGRAY );

			} else if ( parts.Size() > 1 ) {
				int firstSearchNameCellIndex = ( parts[ 0 ] != ""? ZCInternalActorNameCell.GetClassnameCellIndex( classname ) : -1 );
				int lastSearchNameCellIndex = ( firstSearchNameCellIndex == -1? ZCInternalActorNameCell.ARRAY_Quantity : firstSearchNameCellIndex + 1 );

				if ( firstSearchNameCellIndex == -1 )
					firstSearchNameCellIndex = 0;

				Array<String> nameCandidates;
				nameCandidates.Clear();

				ZCheckerHandler handler = ccmd.handler;

				for ( int i = firstSearchNameCellIndex; i < lastSearchNameCellIndex; i++ ) {
					ZCInternalActorNameCell cell = handler.allActorNames[ i ];

					for ( int j = 0; j < cell.names.Size(); j++ ) {
						String curname = cell.names[ j ];

						int curpartindex = partindices[ 1 ];
						bool candidateFound = true;

						if ( parts[ 0 ] != "" ) {
							if ( curname.Left( parts[ 0 ].Length() ) != parts[ 0 ] )
								candidateFound = false;
						}

						for ( int k = ( parts.Size() * !candidateFound ) + 1; k < parts.Size() - 1; k++ ) {
							//console.printf( "\"%20s\". Part " .. k .. ": from %2i \"" .. parts[ k ] .. "\", found at " .. curname.IndexOf( parts[ k ], curpartindex ), curname, curpartindex );
							int partFoundIndex = curname.IndexOf( parts[ k ], curpartindex );

							//console.printf( "\"%20s\": " .. TEXTCOLOR_DARKGRAY .. "partFoundIndex %i (<) partindices[ k ] %i.", curname, partFoundIndex, partindices[ k ] );

							if ( partFoundIndex == -1 || partFoundIndex < partindices[ k ] ) {
								candidateFound = false;
								//console.printf( "\"%20s\": " .. TEXTCOLOR_BRICK .. "break.", curname );
								break;
							}

							if ( k < parts.Size() - 1 )
								curpartindex = partFoundIndex + 1; //partindices[ k + 1 ];
						} // of for ( int k = 0; k < parts.Size(); k++ ) {}

						// Special last characters/symbols sequence handling:
						int partsPreSize = parts.Size() - 1;

						if ( candidateFound ) {
							//console.printf( "\"%20s\": " .. TEXTCOLOR_PURPLE .. "len %i (<) %i as ( curpartindex %i + ( partindex[-1] %i - namelen %i ).", curname, curname.Length(), curpartindex + partindices[ partsPreSize ], curpartindex, partindices[ partsPreSize ], classname.Length() );

							if ( parts[ partsPreSize ] != "" ) {
								curpartindex = max( curpartindex, curname.Length() - parts[ partsPreSize ].Length() );
								int partFoundIndex = curname.IndexOf( parts[ partsPreSize ], curpartindex );

								if ( partFoundIndex == -1 || partFoundIndex < partindices[ partsPreSize ] )
									candidateFound = false;

							// Handling a "word-" case:
							} else if ( curname.Length() < partindices[ partsPreSize ] ) {
								//console.printf( "\"%20s\": " .. TEXTCOLOR_BRICK .. "not found, len %i (<) partindex %i.", curname, curname.Length(), partindices[ partsPreSize ] );
								candidateFound = false;
							}
						}

						if ( candidateFound ) {
							class<Actor> curnameclass = Name( curname );

							if ( curnameclass is parentfilter )
								nameCandidates.Push( curname );
						}
					} // of for ( int j = 0; j < cell.names.Size(); j++ ) {}

				} // of for ( int i = firstSearchNameCellIndex; i < lastSearchNameCellIndex; i++ ) {}


				int nameCandidatesSize = nameCandidates.Size();

				String filtertip = "";
				if ( parentfilter != "Actor" )
					filtertip = TEXTCOLOR_DARKGRAY .. " with filter " .. TEXTCOLOR_WHITE .. parentfilter.GetClassName() .. TEXTCOLOR_DARKGRAY .. "" .. LLCOLOR_MAIN;

				if ( nameCandidatesSize == 1 ) {
					classnameParseStatus = CPS_RegexFound;
					classname = nameCandidates[ 0 ];
					ZCGlobal.Get().SetZCheckerString( "$parsed", classname );
				} else if ( nameCandidatesSize == 0 ) {
					classname = "";
					classnameParseStatus = CPS_RegexFailed;
					ZCGlobal.Log( LL_Main, "Cannot find any suitable actor name candidates" .. filtertip .. "." );
				} else {
					if ( preventiveChoice > nameCandidatesSize ) {
						ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Selected index " .. TEXTCOLOR_LIGHTBLUE .. preventiveChoice .. LLCOLOR_WARNING .. " is out of range" .. LLCOLOR_MAIN .. " of the found candidates." );
						preventiveChoice = -1;
					}

					if ( preventiveChoice != -1 ) {
						classname = nameCandidates[ preventiveChoice - 1 ];
						classnameParseStatus = CPS_RegexFound;
						ZCGlobal.Get().SetZCheckerString( "$parsed", classname );
					} else {
						classname = "";
						classnameParseStatus = CPS_RegexFailed;

						ZCGlobal.Log( LL_Main, "Found more than one suitable actor name candidate" .. filtertip .. ":" );

						for ( int i = 0; i < nameCandidatesSize; i++ )
							ZCGlobal.Log( LL_Main, TEXTCOLOR_DARKGRAY .. ( i + 1 ) .. ". \"" .. TEXTCOLOR_WHITE .. nameCandidates[ i ] .. TEXTCOLOR_DARKGRAY .. "\"." );
					}
				}
			} // of if ( parts.Size() > 1 ) {}

		} else if ( preventiveChoice != -1 ) {
			ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Ignoring numerical selection " .. preventiveChoice .. LLCOLOR_MAIN );
		}

		return classname;
	} // of protected String ParseSpecialActorName( String classname, class<Actor> parentfilter = "Actor" ) {}

	// Less or greater safe wrapper around a "Thinker::Destroy()":
	protected bool RemoveWorldThinker( Thinker th ) {
		String thinkerName = th.GetClassName();

		Actor thing = Actor( th );

		if ( thing && thing.player && thing.player.mo == thing && !ZCGlobal.DangerousCCMDsAllowed( "destroying live player" ) ) {
			ZCGlobal.Log( LL_Main, TEXTCOLOR_DARKRED .. "It's better not to destroy a live player " .. ( thing.PlayerNumber() + 1 ) .. LLCOLOR_MAIN .. ". " .. LLCOLOR_WARNING .. "Terminated" .. LLCOLOR_MAIN .. "." );
		} else {
			if ( thing )
				thing.ClearCounters();

			th.Destroy();
			return true;
		}

		return false;
	} // of protected void RemoveWorldThinker( Thinker th ) {}

	protected bool SetInternalZCheckerString( String zcname, String value ) {
		if ( zcname.CharAt( 0 ) == "%" || zcname.CharAt( 0 ) == "%%" )
			zcname = "$" .. zcname.Mid( 1, zcname.Length() - 1 );

		if ( zcname.Length() > 63 ) {
			zcname.Truncate( 63 );
			ZCGlobal.Log( LL_Main, LLCOLOR_WARNING .. "Variable name truncated " .. LLCOLOR_MAIN .. "to 63 characters (\"" .. zcname .. "\")." );
		}

		String newValue;

		newValue = ParseSpecialActorName( value );

		// if ( ( classnameParseStatus == CPS_Variable ) || ( newValue != "" ) )
		if ( newValue != "" )
			return ZCGlobal.Get().SetZCheckerString( zcname, newValue );

		return false;
	}

	// A wrapper which unites aliases and description to one nice string:
	override String GetHelpString( void ) {
		// Attempt to speed up help strings processing:
		if ( helpCacheString == "" || zcFlags & CCF_NoCacheHelp ) {
			helpCacheString = "";

			Array<String> aliases;
			ccmdInterfaceData.helpHeader.Split( aliases, ";", TOK_SKIPEMPTY );

			int aliasesSize = aliases.Size();
			bool unreleased = !!( zcFlags & CCF_Unreleased );

			String ccmdColorHeader = ( unreleased? CCMDCOLOR_TITLEWIP : CCMDCOLOR_TITLE );
			String ccmdColorArgs   = ( unreleased? CCMDCOLOR_TITLEWIP : CCMDCOLOR_TITLEARGS );

			for ( int i = 0; i < aliasesSize; i++ ) {
				int spaceIndex = aliases[ i ].IndexOf( " " );
				if ( spaceIndex != -1 )
					aliases[ i ] = ccmdColorHeader .. aliases[ i ].Left( spaceIndex ) .. ccmdColorArgs .. aliases[ i ].Mid( spaceIndex, aliases[ i ].Length() - spaceIndex );
				else
					aliases[ i ] = ccmdColorHeader .. aliases[ i ];

				aliases[ i ].Replace( "|", TEXTCOLOR_BRICK .. "|" .. ccmdColorArgs );
				aliases[ i ].Replace( "[", TEXTCOLOR_DARKGRAY .. "[" .. ccmdColorArgs );
				aliases[ i ].Replace( "]", TEXTCOLOR_DARKGRAY .. "]" .. ccmdColorArgs );
				aliases[ i ].Replace( "<", TEXTCOLOR_LIGHTBLUE .. "<" .. ccmdColorArgs );
				aliases[ i ].Replace( ">", TEXTCOLOR_LIGHTBLUE .. ">" .. ccmdColorArgs );
			}

			// Extra aliases:
			for ( int i = 0; i < aliasesSize - 1; i++ )
				helpCacheString = helpCacheString .. ccmdColorArgs .. aliases[ i ] .. CCMDCOLOR_DESC .. ",\n";

			// Last alias and a description:
			helpCacheString = helpCacheString .. ccmdColorArgs .. aliases[ aliasesSize - 1 ] .. CCMDCOLOR_DESC .. ":\n  " .. ( unreleased? TEXTCOLOR_ORANGE .. "[WIP] " .. CCMDCOLOR_TITLEWIP : CCMDCOLOR_DESC ) .. ccmdInterfaceData.helpDesc;

			String lastChar = helpCacheString.CharAt( helpCacheString.Length() - 1 );

			if ( !( lastChar == "." || lastChar == "!" || lastChar == "?" ) )
				helpCacheString = helpCacheString .. ".";
		}

		return helpCacheString;
	} // of final override String GetHelpString( void ) {}

} // of class ZCConsoleCommand abstract {}


// ZChecker informational panel part class (in general is an UI scope).
// Also inherits a play-scoped infopanel parts.
class ZCBaseInfoPanelPart abstract {
	protected bool playScoped;

	const NORMAL	= LLCOLOR_MAIN;
	const N			= NORMAL;
	const BRICK		= TEXTCOLOR_BRICK;
	const TAN		= TEXTCOLOR_TAN;
	const GRAY		= TEXTCOLOR_GRAY;
	const GREY		= TEXTCOLOR_GREY;
	const GREEN		= TEXTCOLOR_GREEN;
	const BROWN		= TEXTCOLOR_BROWN;
	const GOLD		= TEXTCOLOR_GOLD;
	const RED		= TEXTCOLOR_RED;
	const BLUE		= TEXTCOLOR_BLUE;
	const ORANGE	= TEXTCOLOR_ORANGE;
	const WHITE		= TEXTCOLOR_WHITE;
	const YELLOW	= TEXTCOLOR_YELLOW;
	const BLACK		= TEXTCOLOR_BLACK;
	const LIGHTBLUE	= TEXTCOLOR_LIGHTBLUE;
	const CREAM		= TEXTCOLOR_CREAM;
	const OLIVE		= TEXTCOLOR_OLIVE;
	const DARKGREEN	= TEXTCOLOR_DARKGREEN;
	const DARKRED	= TEXTCOLOR_DARKRED;
	const DARKBROWN	= TEXTCOLOR_DARKBROWN;
	const PURPLE	= TEXTCOLOR_PURPLE;
	const DARKGRAY	= TEXTCOLOR_DARKGRAY;
	const CYAN		= TEXTCOLOR_CYAN;
	const ICE		= TEXTCOLOR_ICE;
	const FIRE		= TEXTCOLOR_FIRE;
	const SAPPHIRE	= TEXTCOLOR_SAPPHIRE;
	const TEAL		= TEXTCOLOR_TEAL;

	ZCheckerHandler handler;

	String optionCVarName;
	String optionLabel;
	String optionSubmenuName;


	/* API section */

	virtual void OnCreate( void ) {
		optionCVarName = "mcm_zchecker_info_...";
		optionLabel = "<" .. GetClassName() .. ">";
		optionSubmenuName = "";
	}

	ui virtual String GetInfo( Actor thing, ZCheckerField thingfield ) {
		return GetClassName() .. "::GetInfo(). Not overrided.";
	}

	ui virtual String GetSubmenuLabel( ZCOptionMenuItemInfopanel masterMenuItem, OptionMenuDescriptor submenuDesc ) {
		String label = "Submenu. ";

		int i = 0;

		for ( ; i < submenuDesc.mItems.Size() && label.Length() < 30; i++ ) {
			OptionMenuItem cur = OptionMenuItem( submenuDesc.mItems[ i ] );

			String addlabel = "";

			if ( cur is 'OptionMenuItemOption' ) {
				OptionMenuItemOption curoption = OptionMenuItemOption( cur );
				addlabel = StringTable.Localize( OptionValues.GetText( curoption.mValues, curoption.GetSelection() ) );

				if ( addlabel.Length() == 0 )
					addlabel = "Unknown";
			} else if ( cur is 'OptionMenuItemSlider' ) {
				OptionMenuItemSlider curslider = OptionMenuItemSlider( cur );
				addlabel = String.Format( String.Format( "%%.%df", curslider.mShowValue ), curslider.GetSliderValue() );
			}

			if ( addlabel != "" )
				label = label .. "\"" .. cur.mLabel .. ":" .. addlabel .. "\" ";
		}

		if ( i < submenuDesc.mItems.Size() )
			label = label .. " [...more]";

		return label;
	}


	/* Internal section */

	static ZCBaseInfoPanelPart Create( class<ZCBaseInfoPanelPart> panelclass, ZCheckerHandler globalHandler ) {
		ZCBaseInfoPanelPart panel = ZCBaseInfoPanelPart( new( panelclass ) );

		panel.handler = globalHandler;
		panel.OnCreate();
		panel.playScoped = false;

		return panel;
	}

	bool IsPlayScope( void ) {
		return playScoped;
	}

	protected PlayerPawn getItemPlayerOwner( Inventory item ) {
		PlayerPawn ownerPlayer = PlayerPawn( item.Owner );

		return ( ( ownerPlayer && ownerPlayer.player && ownerPlayer.player.ReadyWeapon )? ownerPlayer : NULL );
	}

	// Translates a string into multiline text.
	protected String BreakPanelLines( String instr, String prefix = "  ", uint textwidth = -1 ) {
		String brokenstr = "";
		Font panelsfont = handler.panels.infopanelsFont;

		if ( textwidth <= 0 )
			textwidth = 32;

		BrokenLines lines = panelsfont.BreakLines( instr, panelsfont.GetCharWidth( 0x61 ) * textwidth );

		int linesAmount = lines.Count();

		for ( int i = 0; i < linesAmount - 1; i++ )
			brokenstr = brokenstr .. prefix .. lines.StringAt( i ) .. "\n";

		// Do not insert a last newline character:
		if ( linesAmount )
			brokenstr = brokenstr .. prefix .. lines.StringAt( linesAmount - 1 );

		return brokenstr;
	}

	// Actually this is a convenience crutch.
	protected void RemoveLastNewlineSymbol( out String str ) {
		String lastchar = str.CharAt( str.Length() - 1 );

		if ( lastchar == "\n" )
			str = str.Left( str.Length() - 1 );
	}
} // of class ZCBaseInfoPanelPart abstract {}

class ZCBaseInfoPanelPart_PlayScope: ZCBaseInfoPanelPart abstract play {
	Array<String> playscopedInfo;


	/* API section */

	play virtual void OnCreate_play( void ) {
		Super.OnCreate();
	}

	play virtual String GetInfo_play( Actor thing, ZCheckerField thingfield ) {
		return RED .. GetClassName() .. "::GetInfo_play(). Not overrided.";
	}


	/* Internal section */

	play static ZCBaseInfoPanelPart_PlayScope CreatePlayScope( class<ZCBaseInfoPanelPart> panelclass, ZCheckerHandler globalHandler ) {
		ZCBaseInfoPanelPart_PlayScope panel = ZCBaseInfoPanelPart_PlayScope( new( panelclass ) );

		panel.handler = globalHandler;
		panel.OnCreate_play();
		panel.playScoped = true;

		for ( int i = 0; i < MaxTestee; i++ )
			panel.playscopedInfo.Push( "" );

		return panel;
	}

	clearscope String InternalGetInfo_clearscope( int index ) {
		return playscopedInfo[ index ];
	}

	final override String GetInfo( Actor thing, ZCheckerField thingfield ) {
		return RED .. GetClassName() .. "::GetInfo(). " .. FIRE .. "Override \"GetInfo_play()\" instead" .. RED .. ".";
	}
} // of class ZCBaseInfoPanelPart_PlayScope: ZCBaseInfoPanelPart abstract play {}
