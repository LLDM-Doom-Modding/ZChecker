struct ZCheckerEvMapConfig {
	ZCheckerPlayerLastPos posMain, posArena;

	bool mainlocPaused, arenaPaused;

	vector2 mainlocStart, mainlocEnd;
	vector2 arenaCreatePos;
	vector2 arenaStart, arenaEnd;
}

class ZCheckerEvSectorSetters {
	uint evType;

	Array<Sector> startSectors; // At least one must be presented.
	uint curSegment;
	ZCheckerSectorSetter setter;
}

class ZCheckerEverythingMapHandler: EventHandler {
	const ZCUDMF_Type = "user_zcsector_type";	// Category.
	const ZCUDMF_TypeSegment = "user_zcsector_typesegment";	// Next segment in the category.

	const ZCUDMF_JumpX = "user_zcsector_jump_x";
	const ZCUDMF_JumpY = "user_zcsector_jump_y";
	const ZCUDMF_JumpAmount = "user_zcsector_jumpamount";
	const ZCUDMF_InfoOfsX = "user_zcsector_infoofs_x";
	const ZCUDMF_InfoOfsY = "user_zcsector_infoofs_y";

	const ZCUDMF_SpecialDef = "user_zcsector_specialdef";

	enum ESectorStarts {
		S__Nothing = -1,

		S_Monsters = 0, S_MonstersLarge, S_MonstersHuge,
		S_Weapons, S_Ammo, S_HealthAndArmor, S_Powerups, S_Keys, S_OtherItems,

		S_DecorSolid, S_DecorSolidLarge, S_DecorShootable,
		S_DecorShootableLarge, S_DecorEthereal, S_DecorEtherealLarge,
		S_DecorNoBlockmap, S_DecorNoInteraction, S_DecorHuge,

		S_Missiles, S_Players, S_SpecialActors,
		// "S_Sound" will not be spawned due to its bNOSECTOR nature.

		S__Quantity
	};

	static const String ESectorStartAliases[] = { // Case-insensitive.
		"Monsters", "Large monsters", "Huge monsters",
		"Weapons", "Ammo", "Health and armor", "Powerups", "Keys", "Other items", 

		"Decor impassible", "Decor impassible large", "Decor shootable", 
		"Decor shootable large", "Decor ethereal", "Decor ethereal large",
		"Decor NOBLOCKMAP", "Decor NOINTERACTION", "Decor huge",

		"Missiles", "Players", "Special actors"
	};

	ZCheckerEvSectorSetters evSectors[ S__Quantity ];

	bool canRecreateEverything;
	bool logSpawnInfo;

	ZCheckerEvMapConfig configuration;



	static String GetESectorName( int which ) {
		String outStr = "";

		if ( which <= S__Nothing || which >= S__Quantity )
			outStr = "<" .. TEXTCOLOR_FIRE .. "unknown: " .. which .. "\c->";
		else
			outStr = ZCheckerEverythingMapHandler.ESectorStartAliases[ which ];

		return outStr;
	}

	// Main function corresponds to the class directing:
	static ESectorStarts GetSectorStartForClass( class<Actor> testcls ) {
		ESectorStarts outValue = S__Nothing;
		readonly<Actor> cls = GetDefaultByType( testcls );

		if ( !cls.bNOSECTOR && !( testcls is 'RandomSpawner' ) ) {
			if ( cls.bISMONSTER ) {
				if ( cls.radius > 384 )
					outValue = S_MonstersHuge;
				else if ( cls.radius > 31.5 )
					outValue = S_MonstersLarge;
				else
					outValue = S_Monsters;
			} else if ( cls.bSPECIAL ) {
				if ( testcls is 'Weapon' || testcls is 'WeaponPiece' )
					outValue = S_Weapons;
				else if ( testcls is 'Ammo' || testcls is 'BackpackItem' )
					outValue = S_Ammo;
				else if ( testcls is 'Armor' || testcls is 'BasicArmor' || testcls is 'BasicArmorBonus' || testcls is 'Health' )
					outValue = S_HealthAndArmor;
				else if ( testcls is 'PowerupGiver' || testcls is 'Powerup' )
					outValue = S_Powerups;
				else if ( testcls is 'Key' || testcls is 'OraclePass' )
					outValue = S_Keys;
				else
					outValue = S_OtherItems;
			} else if ( cls.bMISSILE ) {
				outValue = S_Missiles;
			} else if ( testcls is 'PlayerPawn' ) {
				outValue = S_Players;

				// Skipped all actors with the +NOSECTOR flag set (well, almost):
			} else if (    cls.bACTLIKEBRIDGE || testcls is 'Unknown' || testcls is 'MapMarker'
						|| testcls is 'ItemFog' || testcls is 'PickupFlash' || testcls is 'TeleportFog' 
						|| testcls is 'SecurityCamera' || testcls is 'PatrolPoint' || testcls is 'PatrolSpecial'
						|| testcls is 'InterpolationPoint' || testcls is 'SectorFlagSetter' || testcls is 'ColorSetter'
						|| testcls is 'FadeSetter' || testcls is 'PointPuller' || testcls is 'PointPusher' || testcls is 'PathFollower' ) {
				outValue = S_SpecialActors;

				// Decorations:
			} else if ( cls.bNOBLOCKMAP ) {
				outValue = S_DecorNoBlockmap;
			} else if ( cls.bNOINTERACTION || cls.bNOCLIP ) {
				outValue = S_DecorNoInteraction;
			} else if ( cls.radius > 256 ) {
				outValue = S_DecorHuge;
			} else if ( cls.bSHOOTABLE ) {
				outValue = ( cls.radius > 32? S_DecorShootableLarge : S_DecorShootable );
			} else if ( cls.bSOLID ) {
				outValue = ( cls.radius > 32? S_DecorSolidLarge : S_DecorSolid );
			} else {
				outValue = ( cls.radius > 32? S_DecorEtherealLarge : S_DecorEthereal );
			}
		}

		return outValue;
	} // of static ESectorStarts GetSectorStartForClass( class<Actor> cls ) {}


	// Next classes forces the game to crash/end the level/etc:
	bool IsClassRestricted( class<Actor> cur ) {
		return (
				// Common dangers:
				cur is "DynamicLight"
			||  cur is "Decal"
			||  cur is "SpecialSpot"
			||  cur is "SpawnShot"
			||  cur is "WeaponPiece"
				// Specific dangers (usually crashing the game):
			||  cur is "BossBrain"
			||  cur is "BossEye"
			||  cur is "ParticleFountain"
			||  cur == "ZCheckerSectorSetter"
			||  cur == "Bat"
			||  cur is "ProgLevelEnder"
			||  cur is "SlideshowStarter"
			||  cur is "SpectralLightningBigBall1"
		);
	}

	// Test for actor which is forbidden for operating in the ZChecker level:
	bool IsActorRestricted( Actor cur ) {
		return cur && (
			  ( cur is "Inventory" && Inventory( cur ).owner )
			||( cur is "PlayerPawn" && cur.player )
			||  IsClassRestricted( cur.GetClass() )
		);
	}

	// Really just a wrapper around a some extremely rough algorithm (will be rewritten).
	static int FindNextExistingSectorIndex( ZCheckerEvSectorSetters evSector, int fromIndex = -1 ) {
		if ( !evSector )
			return -1;

		int firstExistingSectorIndex = -1;

		for ( int k = fromIndex + 1; k < evSector.startSectors.Size(); k++ ) {
			if ( evSector.startSectors[ k ] ) {
				firstExistingSectorIndex = k;
				break;
			}
		}

		return firstExistingSectorIndex;
	}


	private void logCreatingActor( String msg ) {
		if ( logSpawnInfo )
			ZCGlobal.ClearscopeLog( LL_Main, TEXTCOLOR_DARKGRAY .. "RecreateEverything(): " .. LLCOLOR_MAIN .. msg );
	}

	// Clears all previous spawned actors excluding forbidden and summons all of them again:
	void RecreateEverything( void ) {
		if ( !canRecreateEverything ) {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::RecreateEverything(). Cannot run due to the map errors, terminating." );
			return;
		}

		ThinkerIterator it = ThinkerIterator.Create( "Actor" );
		Actor curActor;

		// Destroy everything:
		while ( curActor = Actor( it.Next() ) ) {
			if ( !IsActorRestricted( curActor ) )
				curActor.Destroy();
		}

		// Reset e-sector setters:
		for ( int i = 0; i < S__Quantity; i++ ) {
			// Always exists because "RecreateEverything()" method is called after all error checks.
			int firstExistingSectorIndex = FindNextExistingSectorIndex( evSectors[ i ] );

			evSectors[ i ].curSegment = 0;
			evSectors[ i ].setter.SetOrigin( ( evSectors[ i ].startSectors[ firstExistingSectorIndex ].centerspot, 0 ), false );
			evSectors[ i ].setter.curJumpAmount = 0;
		}

		bool spawnReplaced = CVar.FindCVar( "mcm_zchecker_ev_spawnreplaced" ).GetBool();
		bool spawnStealth = CVar.FindCVar( "mcm_zchecker_ev_spawnstealth" ).GetBool();
		bool spawnInvis = CVar.FindCVar( "mcm_zchecker_ev_spawninvisible" ).GetBool();
		bool spawnPlayerChunks = CVar.FindCVar( "mcm_zchecker_ev_spawnplrchunks" ).GetBool();
		bool spawnPLYC = CVar.FindCVar( "mcm_zchecker_ev_spawnplyc" ).GetBool();
		bool spawnTNT1A0 = CVar.FindCVar( "mcm_zchecker_ev_spawntnt1a0" ).GetBool();
		bool skipRestrictedReplacements = CVar.FindCVar( "mcm_zchecker_ev_restrictreplacements" ).GetBool();

		int spriteTNT1A0 = Actor.GetSpriteIndex( "TNT1A0" );
		logSpawnInfo = CVar.FindCVar( "mcm_zchecker_ev_logspawninfo" ).GetBool();

		// Recreate everything:
		for ( int i = 0; i < AllActorClasses.Size(); i++ ) {
			class<Actor> cls = AllActorClasses[ i ];

			bool skipactor = false;

			if ( IsClassRestricted( cls ) ) {
				skipactor = true;

				if ( logSpawnInfo )
					ZCGlobal.Log( LL_Debug, GetClassName() .. "::RecreateEverything(). Class \"" .. cls.GetClassName() .. "\" is restricted." );

			} else if ( skipRestrictedReplacements ) {
				class<Actor> clsReplacee = Actor.GetReplacee( cls );

				if ( clsReplacee != cls && IsClassRestricted( clsReplacee ) ) {
					skipactor = true;
					logCreatingActor( "replaced by \"" .. cls.GetClassName() .. "\" class \"" .. clsReplacee.GetClassName() .. "\" is restricted." );
				}
			}

			if ( !skipactor ) {
				bool spriteCheckSuccess = spawnTNT1A0 && spawnPLYC;

				State st = GetDefaultByType( cls ).SpawnState;
				String stSpriteName = "TNT1A0";
				String stSpriteName4 = "TNT1";

				if ( !spriteCheckSuccess && st ) {
					int statesCountdown = 0;

					// "st.sprite" returns non-altered sprite.
					stSpriteName = TexMan.GetName( st.GetSpriteTexture( 0 ) );
					stSpriteName4 = stSpriteName.Left( 4 );

					while ( st.NextState && ( !spawnTNT1A0 && stSpriteName == "TNT1A0" || !spawnPLYC && stSpriteName4 == "PLYC" ) && statesCountdown < 7 ) {
						st = st.NextState;
						statesCountdown++;

						stSpriteName = TexMan.GetName( st.GetSpriteTexture( 0 ) );
						stSpriteName4 = stSpriteName.Left( 4 );
					}

					spriteCheckSuccess = ( spawnTNT1A0 || stSpriteName != "TNT1A0" );

					if ( spriteCheckSuccess )
						spriteCheckSuccess = ( spawnPLYC || ( stSpriteName4 != "PLYC" && stSpriteName != "" ) );
				}

				if ( !spriteCheckSuccess ) {
					String nonalteredSpriteName = "" .. SpriteID( st.sprite );

					if ( stSpriteName4 == nonalteredSpriteName )
						logCreatingActor( "class \"" .. cls.GetClassName() .. "\" omitted because of empty sprite \"" .. stSpriteName .. "\"." );
					else
						logCreatingActor( "class \"" .. cls.GetClassName() .. "\" omitted because of empty sprite \"" .. stSpriteName .. "\" " .. TEXTCOLOR_ORANGE .. "(was " .. nonalteredSpriteName .. ")." );

				} else if ( ( GetDefaultByType( cls ).bSTEALTH && !spawnStealth ) || ( GetDefaultByType( cls ).bINVISIBLE && !spawnInvis ) ) {
					logCreatingActor( "class \"" .. cls.GetClassName() .. "\" omitted because of +STEALTH/+INVISIBLE flag set." );

				} else if ( !spawnPlayerChunks && cls is "PlayerChunk" ) {
					logCreatingActor( "class \"" .. cls.GetClassName() .. "\" omitted due to inheritance from the \"PlayerChunk\"." );

				} else if ( !spawnReplaced && Actor.GetReplacement( cls ) != cls ) {
					logCreatingActor( "class \"" .. cls.GetClassName() .. "\" replaced and thus omitted." );

				} else {
					ESectorStarts clsType = GetSectorStartForClass( cls );

					if ( clsType != S__Nothing ) {
						logCreatingActor( TEXTCOLOR_DARKGREEN .. "summoned class \"" .. TEXTCOLOR_GREEN .. cls.GetClassName() .. TEXTCOLOR_DARKGREEN .. "\"" .. TEXTCOLOR_DARKGRAY .. " (sprite \"" .. stSpriteName .. "\")." );
						evSectors[ clsType ].setter.DoJump( cls );
					} else if ( logSpawnInfo ) {
						ZCGlobal.Log( LL_Debug, GetClassName() .. "::RecreateEverything(). Class \"" .. cls.GetClassName() .. "\" cannot be determined; skipped." );
					}
				}
			} // of if ( !skipactor ) {}

		} // of for ( int i = 0; i < AllActorClasses.Size(); i++ ) {}

	} // of void RecreateEverything( void ) {}


	override void OnRegister() {
		SetOrder( ZCheckerMapHandlerOrder );
		Super.OnRegister();
	}

	// Loads an Everything map:
	override void WorldLoaded( WorldEvent e ) {
		if ( !ZCGlobal.IsEverythingLevel() )
			return;

		for ( int i = 0; i < S__Quantity; i++ ) {
			evSectors[ i ] = new( 'ZCheckerEvSectorSetters' );
			evSectors[ i ].evType = i;
		}

		canRecreateEverything = true;

		// Finding special sectors and spawning ev-setters:
		for ( int i = 0; i < level.sectors.Size() && canRecreateEverything; i++ ) {
			String evSectorType = level.Sectors[ i ].GetUDMFString( ZCUDMF_Type );

			bool isSectorTyped = ( evSectorType != "" );
			bool continueFlag = !isSectorTyped;

			// Setting up every e-start sector type:
			for ( int j = 0; !continueFlag && j < S__Quantity; j++ ) {
				if ( evSectorType ~== ESectorStartAliases[ j ] ) {

					Sector s = level.Sectors[ i ];

					int typeseg = s.GetUDMFInt( ZCUDMF_TypeSegment );
					ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldLoaded(). Found segment #" .. typeseg .. " for \"" .. evSectorType .. "\" (sector " .. i .. ")." );

					// TODO: rewrite this block of code to something decent!
					if ( typeseg ) {
						if ( typeseg < 0 || typeseg > 0xFF )
							ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Custom value \"" .. ZCUDMF_TypeSegment .. " = " .. typeseg .. "\" in sector " .. i .. " not in range [0; 255]." );

						if ( typeseg < evSectors[ j ].startSectors.Size() ) {
							if ( evSectors[ j ].startSectors[ typeseg ] )
								ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Double define for \"" .. GetESectorName( j ) .. "\" segment " .. typeseg .. ". \c-Set linked sector from " .. evSectors[ j ].startSectors[ typeseg ].Index() .. " to " .. s.Index() );

							evSectors[ j ].startSectors.Delete( typeseg, 1 );
						}

						evSectors[ j ].startSectors.Insert( typeseg, s );

						ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldLoaded(). " .. TEXTCOLOR_DARKGREEN .. "Added" .. LLCOLOR_DEBUG .. " segment #" .. typeseg .. " to \"" .. GetESectorName( j ) .. "\" (sec " .. i .. ", segs.Size() " .. evSectors[ j ].startSectors.Size() .. ")." );
					} else {
						if ( evSectors[ j ].startSectors.Size() ) {
							if ( evSectors[ j ].startSectors[ 0 ] )
								ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Double define for \"" .. GetESectorName( j ) .. "\" segment 0." .. TEXTCOLOR_WHITE .. " [WIP; TODO]." );

							evSectors[ j ].startSectors[ 0 ] = s;
						} else {
							evSectors[ j ].startSectors.Push( s );
						}

						if ( evSectors[ j ].setter ) {
							//ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Cleared setter for \"" .. GetESectorName( j ) .. "\"\c- (linked now to sector " .. evSectors[ j ].startSectors[ 0 ].Index() .. ")." );
							evSectors[ j ].setter.Destroy();
						}
					} // of else of if ( typeseg ) {}

					if ( !evSectors[ j ].setter ) {
						int firstExistingSectorIndex = FindNextExistingSectorIndex( evSectors[ j ] );

						if ( firstExistingSectorIndex != -1 ) {
							vector3 setterPos = ( evSectors[ j ].startSectors[ firstExistingSectorIndex ].centerspot, 0 );

							evSectors[ j ].setter = ZCheckerSectorSetter( Actor.Spawn( "ZCheckerSectorSetter", setterPos ) );
							evSectors[ j ].setter.evSectorDef = evSectors[ j ];
							evSectors[ j ].setter.InitFromPos();

							//ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldLoaded(). Spawned ev-setter for the sector type \"" .. GetESectorName( j ) .. "\"." );
						} else {
							canRecreateEverything = false;
							ZCGlobal.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). Sector type \"" .. GetESectorName( j ) .. "\" has no start sectors." );
							break;
						}
					}

					continueFlag = true;
				} // of if ( evSectorType ~== ESectorStartAliases[ j ] ) {}
			} // of for ( int j = 0; j < S__Quantity; j++ ) {}

			//console.printf( level.Sectors[ i ].Index() .. ". st: " .. evSectorType .. "/" .. isSectorTyped .. ", sdef: " .. level.Sectors[ i ].GetUDMFString( ZCUDMF_SpecialDef ) );

			// Special main location/arena definition:
			if ( !isSectorTyped && ( evSectorType = level.Sectors[ i ].GetUDMFString( ZCUDMF_SpecialDef ) ) != "" ) {
				ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldLoaded(). Found special sector definition \"" .. evSectorType .. "\" (sector " .. i .. ")." );

				if ( evSectorType ~== "arena" ) {
					configuration.arenaCreatePos = level.Sectors[ i ].centerspot;
				} else if ( evSectorType ~== "arena_start" ) {	// Top-left arena point.
					configuration.arenaStart = level.Sectors[ i ].centerspot;
				} else if ( evSectorType ~== "arena_end" ) {		// Bottom-right arena point.
					configuration.arenaEnd = level.Sectors[ i ].centerspot;
				} else if ( evSectorType ~== "main_location_start" ) {	// Top-left main location point.
					configuration.mainlocStart = level.Sectors[ i ].centerspot;
				} else if ( evSectorType ~== "main_location_end" ) {		// Bottom-right main location point.
					configuration.mainlocEnd = level.Sectors[ i ].centerspot;
				}
			}
		} // of for ( int i = 0; i < level.sectors.Size(); i++ ) {}


		// Check for existing of each sector:
		for ( int i = 0; i < S__Quantity; i++ ) {
			if ( !evSectors[ i ].startSectors.Size() ) {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). Error: no e-start " .. GetESectorName( i ) );
				canRecreateEverything = false;
			} else if ( !evSectors[ i ].setter ) {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). Error: no sector setter for " .. GetESectorName( i ) );
				canRecreateEverything = false;
			}
		}

		// Create all:
		RecreateEverything();

		Super.WorldLoaded( e );
	} // of override void WorldLoaded( WorldEvent e ) {}

	override void PlayerEntered( PlayerEvent e ) {
		if ( ZCGlobal.IsEverythingLevel() && CVar.GetCVar( "mcm_zchecker_ev_auto_notarget", players[ e.PlayerNumber ] ).GetBool() ) {
			players[ e.PlayerNumber ].cheats |= CF_NOTARGET;

			if ( e.PlayerNumber == consoleplayer )
				ZCGlobal.Log( LL_Main, "Auto-notarget enabled." );
		}

		Super.PlayerEntered( e );
	} // of override void PlayerEntered( PlayerEvent e ) {}


	override void NetworkProcess( ConsoleEvent e ) {
		if ( ZCGlobal.IsEverythingLevel() ) {

			if ( e.Name ~== "zcheckermap_recreate" ) {
				ZCGlobal.Log( LL_Main, GetClassName() .. "::NetworkProcess(). Recreating/reloading map..." );
				RecreateEverything();
			} else if ( e.Name ~== "zcheckermap_pause_level_part" ) {
				vector2 pauseFrom, pauseTo;
				bool isPausing = false;
				String logStr = GetClassName() .. "::NetworkProcess(). ";

				if ( e.args[ 0 ] == 0 ) {
					pauseFrom = configuration.mainlocStart;
					pauseTo = configuration.mainlocEnd;

					logStr = logStr .. ( configuration.mainlocPaused? "L" : "Unl" );
					isPausing = configuration.mainlocPaused;
					configuration.mainlocPaused ^= true;

					logStr = logStr .. "oading main part...";
				} else {
					pauseFrom = configuration.arenaStart;
					pauseTo = configuration.arenaEnd;

					logStr = logStr .. ( configuration.arenaPaused? "L" : "Unl" );
					isPausing = configuration.arenaPaused;
					configuration.arenaPaused ^= true;

					logStr = logStr .. "oading arena part...";
				}

				ZCGlobal.Log( LL_Main, logStr );

				ThinkerIterator it = ThinkerIterator.Create( "Actor" );
				Actor curActor;

				// Load/unload all from selected level part:
				while ( curActor = Actor( it.Next() ) ) {
					if ( !IsActorRestricted( curActor ) && curActor.pos.x >= pauseFrom.x && curActor.pos.y <= pauseFrom.y && curActor.pos.x <= pauseTo.x && curActor.pos.y >= pauseTo.y ) {
						ZCGlobal.Log( LL_Debug, GetClassName() .. "::NetworkProcess(). Handling actor " .. curActor.GetClassName() );

						// This line has no check for the already setted INVISIBLE flag:
						curActor.bNOINTERACTION = curActor.bINVISIBLE = curActor.bDORMANT = !isPausing;
						curActor.A_ChangeLinkFlags( !isPausing, !isPausing );

						// Crashes:
						//if ( isPausing ) 
						//	curActor.UnlinkFromWorld();
						//else
						//	curActor.LinkToWorld();
					}
				} // of while ( curActor = Actor( it.Next() ) ) {}

			} // of } else if ( e.Name ~== "zcheckermap_pause_level_part" ) {}

		} // of if ( ZCGlobal.IsEverythingLevel() ) {}

		Super.NetworkProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {}

	override void WorldTick() {
		for ( int i = 0; i < MAXPLAYERS; i++ ) {
			if ( playeringame[ i ] && players[ i ].mo && !players[ i ].bot ) {
				PlayerPawn pl = players[ i ].mo;
				FLineTraceData lt;
				pl.LineTrace( pl.angle, pl.radius + 64.0, pl.pitch, TRF_ALLACTORS, pl.player.viewheight, data: lt );

				if ( lt.HitType == TRACE_HitActor && lt.HitActor.GetClassName() == "ZCheckerActorInfo" ) {
					pl.SetInventory( "ZCheckerInfoInventory", 1 );
					ZCheckerInfoInventory zcii = ZCheckerInfoInventory( pl.FindInventory( "ZCheckerInfoInventory" ) );
					zcii.Init( ZCheckerActorInfo( lt.HitActor ).GetInfoString() );
				}
			}
		}

		Super.WorldTick();
	} // of override void WorldTick() {}

	override void RenderOverlay( RenderEvent e ) {
		if ( ZCGlobal.IsEverythingLevel() && PlayerPawn( e.Camera ) ) {
			ZCheckerInfoInventory zcii = ZCheckerInfoInventory( e.Camera.FindInventory( "ZCheckerInfoInventory" ) );

			if ( zcii ) {
				String actorInfo = zcii.info;

				Font rfont = Font.FindFont( "smallfont" );

				Screen.DrawText( rfont, Font.CR_GRAY, 320 - actorInfo.Length() / 2 * rfont.GetCharWidth( "A" ), 60, 
						actorInfo, DTA_VirtualWidth, 640, DTA_VirtualHeight, 480 );
			}
		}

		Super.RenderOverlay( e );
	} // of override void RenderOverlay( RenderEvent e ) {}

} // of class ZCheckerEverythingMapHandler: EventHandler {}


class ZCheckerSectorSetter: Actor {
	const ZCUDMF_Type = ZCheckerEverythingMapHandler.ZCUDMF_Type;
	ZCheckerEvSectorSetters evSectorDef;

	vector2 jumpLen;
	int jumpMaxAmount;
	vector2 infoActorOffset;

	int curJumpAmount;

	Default {
		+NOINTERACTION;
		+NOBLOCKMAP;
	}

	void InitFromPos( void ) {
		bool continueFlag = true;

		if ( !floorsector ) {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::InitFromPos(). " .. LLCOLOR_WARNING .. "Warning: initialization of the sector setter of type \"" .. ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) .. "\" performed outside the map\c-." );
			continueFlag = false;
		} else if ( floorsector.GetUDMFString( ZCUDMF_Type ) != ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) ) {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::InitFromPos(). " .. LLCOLOR_WARNING .. "Warning: sector setter of type \"" .. ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) .. "\" now on sector " .. floorsector.Index() .. " type \"" .. floorsector.GetUDMFString( ZCUDMF_Type ) .. "\"\c-." );
			continueFlag = false;
		}

		if ( continueFlag ) {
			Sector s = floorsector;

			jumpLen = ( s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_JumpX ), s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_JumpY ) );
			infoActorOffset = ( s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_InfoOfsX ), s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_InfoOfsY ) );
			jumpMaxAmount = s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_JumpAmount );
			curJumpAmount = 0;
		}
	} // of void InitFromPos( void ) {}

	/*void Init( vector2 initJumpLen, int initJumpMax, vector2 initInfoActorOffset ) {
		jumpLen = initJumpLen;
		jumpMaxAmount = initJumpMax;
		infoActorOffset = initInfoActorOffset;

		curJumpAmount = 0;
		angle = 270.0; // South (bottom).
	} // of void Init( int initJumpLen, int initJumpMax, vector2 initInfoActorOffset ) {}*/

	protected bool jumpToNextTypeSegment( void ) {
		bool success = true;

		if ( curJumpAmount >= jumpMaxAmount ) {
			int nextSegment = ZCheckerEverythingMapHandler.FindNextExistingSectorIndex( evSectorDef, evSectorDef.curSegment );

			if ( nextSegment < 0 || nextSegment >= evSectorDef.startSectors.Size() ) {
				success = false;
			} else {
				evSectorDef.curSegment = nextSegment;
				SetOrigin( ( evSectorDef.startSectors[ evSectorDef.curSegment ].centerspot, 0 ), false );
				InitFromPos();
			}
		}

		return success;
	}

	void DoJump( class<Actor> cls ) {
		if ( jumpToNextTypeSegment() ) {
			Actor testeeActor = Actor.Spawn( cls, pos );

			if ( testeeActor ) {
				vector3 infoActorPos = pos + ( infoActorOffset, 0 );

				ZCheckerActorInfo infoActor = ZCheckerActorInfo( Actor.Spawn( "ZCheckerActorInfo", infoActorPos ) );
				infoActor.master = testeeActor;
				infoActor.masterClass = cls;
				infoActor.evSectorDef = evSectorDef;

				infoActor.SetMasterZ();

				SetOrigin( pos + ( jumpLen.x, jumpLen.y, 0 ), false );
				curJumpAmount++;
			} else {
				ZCGlobal.Log( LL_Detailed, GetClassName() .. "::DoJump(). " .. TEXTCOLOR_DARKBROWN .. "Cannot spawn actor \"" .. TEXTCOLOR_WHITE .. cls.GetClassName() .. TEXTCOLOR_DARKBROWN .. "\", is it abstract?" );
			}
		} else {
			ZCGlobal.Log( LL_Main, TEXTCOLOR_DARKGRAY .. GetClassName() .. "::DoJump(). " .. LLCOLOR_WARNING .. "Warning" .. LLCOLOR_MAIN .. ": maximal amount of jumps (" .. jumpMaxAmount .. ") was reached, actor \"" .. cls.GetClassName() .. "\" not spawned." );
		}

	} // of void DoJump( class<Actor> cls ) {}

} // of class ZCheckerSectorSetter: Actor {}


class ZCheckerPlayerLastPos: Actor {
	Default {
		+NOINTERACTION;
		+NOBLOCKMAP;
	}
}


class ZCheckerActorInfo: Actor {
	class<Actor> masterClass;
	String masterInfo;
	vector2 masterOffset;
	ZCheckerEvSectorSetters evSectorDef;

	enum EInfoactorStatus {
		IAS_Wrong = 0,
		IAS_Ready,
		IAS_MasterDied
	};

	EInfoactorStatus prevStatus;


	Default {
		-SOLID;
		-SHOOTABLE;
		+NOGRAVITY;
		+DONTSPLASH;
		Scale 0.5;
		Height 64;
		Radius 30;
		Activation THINGSPEC_Switch;
		+USESPECIAL;
	}

	override void PostBeginPlay() {
		if ( !masterClass ) {
			ZCGlobal.Log( LL_Debug, GetClassName() .. "::PostBeginPlay(). No master class defined, set to self." );
			masterClass = GetClass();
			master = self;
		}

		if ( master ) {
			masterOffset = pos.xy - master.pos.xy;

			masterInfo = master.GetClassName();

			if ( !( master.GetParentClass().GetClassName() == "Actor" ) )
				masterInfo = masterInfo .. "\cf: \c-" .. master.GetParentClass().GetClassName();

			class<Actor> replacee = Actor.GetReplacee( masterClass );

			if ( replacee != masterClass )
				masterInfo = masterInfo .. " \cnreplaces\c- " .. replacee.GetClassName();

			SetZ( floorZ );
		} else {
			ZCGlobal.Log( LL_Detailed, TEXTCOLOR_DARKGRAY .. "Removing " .. GetClassName() .. " at " .. ZCGlobal.squeezeVector3( pos ) .. ", class \"" .. LLCOLOR_MAIN .. masterClass.GetClassName() .. TEXTCOLOR_DARKGRAY .. "\" in \"" .. ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) .. "\" vanishes." );
			Destroy();
		}

		Super.PostBeginPlay();
	}

	void SetMasterZ( void ) {
		if ( master ) {
			if ( master.bSPAWNCEILING ) {
				master.SetZ( master.ceilingz - master.height );
				master.ClearInterpolation();
				floorclip = -64.0;
			} else if ( master.bNOGRAVITY || master.bNOINTERACTION ) {
				master.AddZ( 16.0 );
				master.ClearInterpolation();
				floorclip = -22.0;
			} else {
				floorclip = -3.5;
			}
		}
	} // of void SetMasterZ( void ) {}

	override void Activate( Actor other ) {
		if ( !PlayerPawn( other ) )
			return;

		if ( !master || ( master.health <= 0 || master.bCORPSE ) ) {
			if ( master )
				master.Destroy();

			master = Spawn( masterClass, ( pos.xy - masterOffset, 0.0 ) );
			ZCGlobal.Log( LL_Detailed, TEXTCOLOR_DARKGRAY .. GetClassName() .. "::Activate(). " .. LLCOLOR_Main .. "Spawned " .. master.GetClassName() .. "." );
			SetMasterZ();
		}
	}

	override void Deactivate( Actor other ) {
		Activate( other );
	}

	override void Tick() {
		if ( master is 'Inventory' && Inventory( master ).owner )
			master = NULL;

		EInfoactorStatus curStatus = IAS_Wrong;

		if ( master && master != self ) {
			if ( master.health <= 0 || master.bCORPSE )
				curStatus = IAS_MasterDied;
			else
				curStatus = IAS_Ready;
		}

		if ( curStatus != prevStatus ) {
			switch ( curStatus ) {
				case IAS_Ready: A_SetTranslation( "mcm_ZChecker_ActorInfoReady" ); break;
				case IAS_MasterDied: A_SetTranslation( "mcm_ZChecker_ActorInfoMasterDied" ); break;
				default: A_SetTranslation( "mcm_ZChecker_ActorInfoWrongMaster" ); break;
			}
		}

		prevStatus = curStatus;
	}

	String GetInfoString( void ) {
		return masterInfo;
	}

	States {
	Spawn:
		BAL1 B -1 Bright;
		stop;
	}
} // of class ZCheckerActorInfo: Actor {}

class ZCheckerInfoInventory: Inventory {
	String info;
	int ticks;

	Default {
		Inventory.MaxAmount 0x7FFFFFFF;
		Inventory.Amount 1;
	}

	void Init( String initInfo ) {
		info = initInfo;
		ticks = 0;
	}

	override void Tick() {
		Super.Tick();

		if ( ticks++ > 2 )
			Destroy();
	}
} // of class ZCheckerInfoInventory: Inventory {}
