
struct ZCheckerEverythingMapHandlerConfig {
	// Data-scoped variables. May be changed under both UI and play:
	transient CVar infostrXCenterCVar, infostrYCenterCVar, infostrScaleCVar;
	transient ZCPanelsStorage zcHandlerPanels;
	transient bool isNoFontWarningShown;

	String currentConsoleplayerInfostr;
}

class ZCheckerSectorSetterData play {
	uint evType;

	Array<Sector> startSectors; // At least one must be presented.
	uint curSegment;
	ZCheckerSectorSetter setter;
}

class ZCheckerEverythingMapHandler: EventHandler {
	const ZCUDMF_Type = "user_zcsector_type";	// Category.
	const ZCUDMF_TypeSegment = "user_zcsector_typesegment";	// Current segment index in the category.

	const ZCUDMF_JumpX = "user_zcsector_jump_x";
	const ZCUDMF_JumpY = "user_zcsector_jump_y";
	const ZCUDMF_JumpAmount = "user_zcsector_jumpamount";
	const ZCUDMF_InfoOfsX = "user_zcsector_infoofs_x";
	const ZCUDMF_InfoOfsY = "user_zcsector_infoofs_y";

	const ZCUDMF_SpecialDef = "user_zcsector_specialdef";

	enum ESectorStarts {
		S__Nothing = -1,

		S_Monsters = 0, S_MonstersLarge, S_MonstersHuge,
		S_Weapons, S_Ammo, S_HealthAndArmor, S_Powerups, S_Keys, S_OtherItems,

		S_DecorSolid, S_DecorSolidLarge, S_DecorShootable,
		S_DecorShootableLarge, S_DecorEthereal, S_DecorEtherealLarge,
		S_DecorNoBlockmap, S_DecorNoInteraction, S_DecorHuge,

		S_Missiles, S_Players, S_SpecialActors,
		// "S_Sound" will not be spawned due to its bNOSECTOR nature.

		S__Quantity
	};

	static const String ESectorStartAliases[] = { // Case-insensitive.
		"Monsters", "Large monsters", "Huge monsters",
		"Weapons", "Ammo", "Health and armor", "Powerups", "Keys", "Other items", 

		"Decor impassible", "Decor impassible large", "Decor shootable", 
		"Decor shootable large", "Decor ethereal", "Decor ethereal large",
		"Decor NOBLOCKMAP", "Decor NOINTERACTION", "Decor huge",

		"Missiles", "Players", "Special actors"
	};

	ZCheckerSectorSetterData evSectors[ S__Quantity ];

	bool canRecreateEverything;
	bool logSpawnInfo;
	transient bool isNoFontWarningShown;

	ZCheckerEverythingMapHandlerConfig configuration;


	static String GetESectorName( int which ) {
		String outStr = "";

		if ( which <= S__Nothing || which >= S__Quantity )
			outStr = "<" .. TEXTCOLOR_FIRE .. "unknown: " .. which .. "\c->";
		else
			outStr = ZCheckerEverythingMapHandler.ESectorStartAliases[ which ];

		return outStr;
	}

	// Main function corresponds to the class directing:
	static ESectorStarts GetSectorStartForClass( class<Actor> testcls ) {
		ESectorStarts outValue = S__Nothing;
		readonly<Actor> cls = GetDefaultByType( testcls );

		if ( !cls.bNOSECTOR && !( testcls is 'RandomSpawner' ) ) {
			if ( cls.bISMONSTER ) {
				if ( cls.radius > 384 )
					outValue = S_MonstersHuge;
				else if ( cls.radius > 31.5 )
					outValue = S_MonstersLarge;
				else
					outValue = S_Monsters;
			} else if ( cls.bSPECIAL ) {
				if ( testcls is 'Weapon' || testcls is 'WeaponPiece' )
					outValue = S_Weapons;
				else if ( testcls is 'Ammo' || testcls is 'BackpackItem' )
					outValue = S_Ammo;
				else if ( testcls is 'Armor' || testcls is 'BasicArmor' || testcls is 'BasicArmorBonus' || testcls is 'Health' )
					outValue = S_HealthAndArmor;
				else if ( testcls is 'PowerupGiver' || testcls is 'Powerup' )
					outValue = S_Powerups;
				else if ( testcls is 'Key' || testcls is 'OraclePass' )
					outValue = S_Keys;
				else
					outValue = S_OtherItems;
			} else if ( cls.bMISSILE ) {
				outValue = S_Missiles;
			} else if ( testcls is 'PlayerPawn' ) {
				outValue = S_Players;

				// Skipped all actors with the +NOSECTOR flag set (well, almost):
			} else if (    cls.bACTLIKEBRIDGE || testcls is 'Unknown' || testcls is 'MapMarker'
						|| testcls is 'ItemFog' || testcls is 'PickupFlash' || testcls is 'TeleportFog' 
						|| testcls is 'SecurityCamera' || testcls is 'PatrolPoint' || testcls is 'PatrolSpecial'
						|| testcls is 'InterpolationPoint' || testcls is 'SectorFlagSetter' || testcls is 'ColorSetter'
						|| testcls is 'FadeSetter' || testcls is 'PointPuller' || testcls is 'PointPusher' || testcls is 'PathFollower' ) {
				outValue = S_SpecialActors;

				// Decorations:
			} else if ( cls.bNOBLOCKMAP ) {
				outValue = S_DecorNoBlockmap;
			} else if ( cls.bNOINTERACTION || cls.bNOCLIP ) {
				outValue = S_DecorNoInteraction;
			} else if ( cls.radius > 256 ) {
				outValue = S_DecorHuge;
			} else if ( cls.bSHOOTABLE ) {
				outValue = ( cls.radius > 32? S_DecorShootableLarge : S_DecorShootable );
			} else if ( cls.bSOLID ) {
				outValue = ( cls.radius > 32? S_DecorSolidLarge : S_DecorSolid );
			} else {
				outValue = ( cls.radius > 32? S_DecorEtherealLarge : S_DecorEthereal );
			}
		}

		return outValue;
	} // of static ESectorStarts GetSectorStartForClass( class<Actor> cls ) {}


	// Next classes forces the game to crash/end the level/etc:
	bool IsClassRestricted( class<Actor> cur ) {
		return (
				// Common dangers:
				cur is "DynamicLight"
			||  cur is "Decal"
			||  cur is "SpecialSpot"
			||  cur is "SpawnShot"
			||  cur is "WeaponPiece"
				// Specific dangers (usually crashing the game):
			||  cur is "ParticleFountain"	// Crashes the game on first tic.
			||  cur is "BossBrain"			// Spawns next to the "ExplosiveBarrel"...
			||  cur == "Bat" 				// Tries to use a NULL "target" field.
			||  cur is "ProgLevelEnder" 	// Just ends the level almost immediately.
			||  cur is "SlideshowStarter" 	// Calls a "level.StartSlideshow()".
			||  cur is "SpectralLightningBigBall1" 	// "Tried to read from address zero. Called from Actor.SpawnSubMissile(); called from SpectralLightningBigBall1.A_SpectralBigBallLightning()".
			||  cur is "LittleFly" 			// Recursive thing search on neighbour sectors (freezes the engine).
		);
	}

	// Test for actor which is forbidden for operating in the ZChecker level:
	bool IsActorRestricted( Actor cur ) {
		return cur && (
			  ( cur is "Inventory" && Inventory( cur ).owner )
			||( cur is "PlayerPawn" && cur.player )
			||( cur.GetClass() == "ZCheckerSectorSetter" )
			||  IsClassRestricted( cur.GetClass() )
		);
	}

	// Really just a wrapper around a some extremely rough algorithm (will be rewritten).
	static int FindNextExistingSectorIndex( ZCheckerSectorSetterData evSector, int fromIndex = -1 ) {
		if ( !evSector )
			return -1;

		int firstExistingSectorIndex = -1;

		for ( int k = fromIndex + 1; k < evSector.startSectors.Size(); k++ ) {
			if ( evSector.startSectors[ k ] ) {
				firstExistingSectorIndex = k;
				break;
			}
		}

		return firstExistingSectorIndex;
	}


	private void logCreatingActor( String msg ) {
		if ( logSpawnInfo )
			ZCGlobal.ClearscopeLog( LL_Main, TEXTCOLOR_DARKGRAY .. "RecreateEverything(): " .. LLCOLOR_MAIN .. msg );
	}

	// Clears all previous spawned actors excluding forbidden and summons all of them again:
	void RecreateEverything( void ) {
		if ( !canRecreateEverything ) {
			ZCConsoleCommand.LogLocalize2Str( LL_Emergency, "EVMAP_INITERROR", GetClassName() );
			return;
		}

		ThinkerIterator it = ThinkerIterator.Create( "Actor" );
		Actor curActor;

		// Destroy everything:
		while ( curActor = Actor( it.Next() ) ) {
			if ( !IsActorRestricted( curActor ) )
				curActor.Destroy();
		}

		// Reset e-sector setters:
		for ( int i = 0; i < S__Quantity; i++ ) {
			// Always exists because "RecreateEverything()" method is called after all error checks.
			int firstExistingSectorIndex = FindNextExistingSectorIndex( evSectors[ i ] );

			evSectors[ i ].curSegment = 0;
			evSectors[ i ].setter.SetOrigin( ( evSectors[ i ].startSectors[ firstExistingSectorIndex ].centerspot, 0 ), false );
			evSectors[ i ].setter.curJumpAmount = 0;
		}

		bool spawnReplaced = CVar.FindCVar( "mcm_zchecker_ev_spawnreplaced" ).GetBool();
		bool spawnStealth = CVar.FindCVar( "mcm_zchecker_ev_spawnstealth" ).GetBool();
		bool spawnInvis = CVar.FindCVar( "mcm_zchecker_ev_spawninvisible" ).GetBool();
		bool spawnPlayerChunks = CVar.FindCVar( "mcm_zchecker_ev_spawnplrchunks" ).GetBool();
		bool spawnPLYC = CVar.FindCVar( "mcm_zchecker_ev_spawnplyc" ).GetBool();
		bool spawnTNT1A0 = CVar.FindCVar( "mcm_zchecker_ev_spawntnt1a0" ).GetBool();
		bool spawnMissedSprites = CVar.FindCVar( "mcm_zchecker_ev_spawnmissingsprites" ).GetBool();
		bool skipRestrictedReplacements = CVar.FindCVar( "mcm_zchecker_ev_restrictreplacements" ).GetBool();

		int spriteTNT1A0 = Actor.GetSpriteIndex( "TNT1A0" );
		logSpawnInfo = CVar.FindCVar( "mcm_zchecker_ev_logspawninfo" ).GetBool();

		// Recreate everything:
		for ( int i = 0; i < AllActorClasses.Size(); i++ ) {
			class<Actor> cls = AllActorClasses[ i ];

			bool skipactor = false;

			if ( IsClassRestricted( cls ) ) {
				skipactor = true;

				if ( logSpawnInfo )
					ZCGlobal.Log( LL_Debug, GetClassName() .. "::RecreateEverything(). Class \"" .. cls.GetClassName() .. "\" is restricted." );

			} else if ( skipRestrictedReplacements ) {
				class<Actor> clsReplacee = Actor.GetReplacee( cls );

				if ( clsReplacee != cls && IsClassRestricted( clsReplacee ) ) {
					skipactor = true;
					logCreatingActor( String.Format( ZCGlobal.Locz( "EVMAPSPAWN_REPLRESTRICTEDSKIP" ), cls.GetClassName(), clsReplacee.GetClassName() ) );
				}
			}

			if ( !skipactor ) {
				bool spriteCheckSuccess = spawnTNT1A0 && spawnPLYC;

				State st = GetDefaultByType( cls ).SpawnState;
				String stSpriteName = "TNT1A0";
				String stSpriteName4 = "TNT1";
				SpriteID stSprite = spriteTNT1A0;

				if ( !spriteCheckSuccess && st ) {
					int statesCountdown = 0;

					// "st.sprite" returns non-altered sprite.
					stSpriteName = TexMan.GetName( st.GetSpriteTexture( 0 ) );
					stSpriteName4 = stSpriteName.Left( 4 );
					stSprite = st.sprite;

					while ( st.NextState && ( !spawnTNT1A0 && stSpriteName == "TNT1A0" || !spawnPLYC && stSpriteName4 == "PLYC" ) && statesCountdown < 7 ) {
						st = st.NextState;
						statesCountdown++;

						stSpriteName = TexMan.GetName( st.GetSpriteTexture( 0 ) );
						stSpriteName4 = stSpriteName.Left( 4 );
						stSprite = st.sprite;
					}

					if ( stSpriteName4 == "TNT1" ) {
						// Empty or missing sprite:
						if ( stSprite == spriteTNT1A0 )
							spriteCheckSuccess = spawnTNT1A0;
						else
							spriteCheckSuccess = spawnMissedSprites;

					} else {
						// Valid or a "PLYC" sprite:
						spriteCheckSuccess = ( spawnPLYC || ( stSpriteName4 != "PLYC" && stSpriteName != "" ) );
					}

				}

				if ( !spriteCheckSuccess ) {
					if ( stSprite == spriteTNT1A0 )
						logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_EMPTYSPRITESKIP" ), cls.GetClassName(), stSpriteName ) );
					else
						logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_MISSPRITESKIP" ), cls.GetClassName(), stSpriteName, "" .. stSprite ) );

				} else if ( ( GetDefaultByType( cls ).bSTEALTH && !spawnStealth ) || ( GetDefaultByType( cls ).bINVISIBLE && !spawnInvis ) ) {
					logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_INVISSKIP" ), cls.GetClassName() ) );

				} else if ( !spawnReplaced && Actor.GetReplacement( cls ) != cls ) {
					logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_REPLACEDSKIP" ), cls.GetClassName() ) );

				} else if ( !spawnPlayerChunks && cls is "PlayerChunk" ) {
					logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_PLCHUNKSKIP" ), cls.GetClassName() ) );

				} else {
					ESectorStarts clsType = GetSectorStartForClass( cls );

					if ( clsType != S__Nothing ) {
						logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_SUCCESS" ), cls.GetClassName(), stSpriteName ) );
						evSectors[ clsType ].setter.DoJump( cls );
					} else if ( logSpawnInfo ) {
						ZCGlobal.Log( LL_Debug, GetClassName() .. "::RecreateEverything(). Class \"" .. cls.GetClassName() .. "\" cannot be assigned to any category and thus skipped." );
					}
				}
			} // of if ( !skipactor ) {}

		} // of for ( int i = 0; i < AllActorClasses.Size(); i++ ) {}

	} // of void RecreateEverything( void ) {}


	override void OnRegister() {
		SetOrder( ZCheckerMapHandlerOrder );
		Super.OnRegister();
	}

	// Loads an Everything map:
	override void WorldLoaded( WorldEvent e ) {
		if ( !ZCGlobal.IsEverythingLevel() ) {
			Super.WorldLoaded( e );

			Destroy();
			return;
		}

		for ( int i = 0; i < S__Quantity; i++ ) {
			evSectors[ i ] = new( 'ZCheckerSectorSetterData' );
			evSectors[ i ].evType = i;
		}

		canRecreateEverything = true;

		// Finding special sectors and spawning ev-setters:
		for ( int i = 0; i < level.sectors.Size() && canRecreateEverything; i++ ) {
			String evSectorType = level.Sectors[ i ].GetUDMFString( ZCUDMF_Type );

			bool isSectorTyped = ( evSectorType != "" );
			bool continueFlag = !isSectorTyped;

			// Setting up every e-start sector type:
			for ( int j = 0; !continueFlag && j < S__Quantity; j++ ) {
				if ( evSectorType ~== ESectorStartAliases[ j ] ) {

					Sector s = level.Sectors[ i ];

					int typeseg = s.GetUDMFInt( ZCUDMF_TypeSegment );
					ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldLoaded(). Found segment #" .. typeseg .. " for \"" .. evSectorType .. "\" (sector " .. i .. ")." );

					// TODO: rewrite this block of code to something decent!
					if ( typeseg ) {
						if ( typeseg < 0 || typeseg > 0xFF )
							ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Custom value \"" .. ZCUDMF_TypeSegment .. " = " .. typeseg .. "\" in sector " .. i .. " not in range [0; 255]." );

						if ( typeseg < evSectors[ j ].startSectors.Size() ) {
							if ( evSectors[ j ].startSectors[ typeseg ] )
								ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Double define for \"" .. GetESectorName( j ) .. "\" segment " .. typeseg .. ". \c-Set linked sector from " .. evSectors[ j ].startSectors[ typeseg ].Index() .. " to " .. s.Index() );

							evSectors[ j ].startSectors.Delete( typeseg, 1 );
						}

						evSectors[ j ].startSectors.Insert( typeseg, s );

						ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldLoaded(). " .. TEXTCOLOR_DARKGREEN .. "Added" .. LLCOLOR_DEBUG .. " segment #" .. typeseg .. " to \"" .. GetESectorName( j ) .. "\" (sec " .. i .. ", segs.Size() " .. evSectors[ j ].startSectors.Size() .. ")." );
					} else {
						if ( evSectors[ j ].startSectors.Size() ) {
							if ( evSectors[ j ].startSectors[ 0 ] )
								ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Double define for \"" .. GetESectorName( j ) .. "\" segment 0." .. TEXTCOLOR_WHITE .. " [WIP; TODO]." );

							evSectors[ j ].startSectors[ 0 ] = s;
						} else {
							evSectors[ j ].startSectors.Push( s );
						}

						if ( evSectors[ j ].setter ) {
							//ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Cleared setter for \"" .. GetESectorName( j ) .. "\"\c- (linked now to sector " .. evSectors[ j ].startSectors[ 0 ].Index() .. ")." );
							evSectors[ j ].setter.Destroy();
						}
					} // of else of if ( typeseg ) {}

					if ( !evSectors[ j ].setter ) {
						int firstExistingSectorIndex = FindNextExistingSectorIndex( evSectors[ j ] );

						if ( firstExistingSectorIndex != -1 ) {
							vector3 setterPos = ( evSectors[ j ].startSectors[ firstExistingSectorIndex ].centerspot, 0 );

							evSectors[ j ].setter = ZCheckerSectorSetter( Actor.Spawn( "ZCheckerSectorSetter", setterPos ) );
							evSectors[ j ].setter.evSectorDef = evSectors[ j ];
							evSectors[ j ].setter.InitFromPos();

							//ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldLoaded(). Spawned ev-setter for the sector type \"" .. GetESectorName( j ) .. "\"." );
						} else {
							canRecreateEverything = false;
							ZCGlobal.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). Sector type \"" .. GetESectorName( j ) .. "\" has no start sectors." );
							break;
						}
					}

					continueFlag = true;
				} // of if ( evSectorType ~== ESectorStartAliases[ j ] ) {}
			} // of for ( int j = 0; j < S__Quantity; j++ ) {}

			//console.printf( level.Sectors[ i ].Index() .. ". st: " .. evSectorType .. "/" .. isSectorTyped .. ", sdef: " .. level.Sectors[ i ].GetUDMFString( ZCUDMF_SpecialDef ) );

		} // of for ( int i = 0; i < level.sectors.Size(); i++ ) {}


		// Check for existing of each sector:
		for ( int i = 0; i < S__Quantity; i++ ) {
			if ( !evSectors[ i ].startSectors.Size() ) {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). Error: no e-start " .. GetESectorName( i ) );
				canRecreateEverything = false;
			} else if ( !evSectors[ i ].setter ) {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). Error: no sector setter for " .. GetESectorName( i ) );
				canRecreateEverything = false;
			}
		}

		// Create all:
		RecreateEverything();

		Super.WorldLoaded( e );
	} // of override void WorldLoaded( WorldEvent e ) {}

	override void PlayerEntered( PlayerEvent e ) {
		if ( ZCGlobal.IsEverythingLevel() ) {
			PlayerInfo pl = players[ e.PlayerNumber ];

			if ( CVar.GetCVar( "mcm_zchecker_ev_auto_notarget", pl ).GetBool() ) {
				pl.cheats |= CF_NOTARGET;

				if ( e.PlayerNumber == consoleplayer )
					ZCGlobal.Log( LL_Main, "$EVMAP_AUTONOTARGET" );
			}

			if ( CVar.GetCVar( "mcm_zchecker_ev_auto_iddqd", pl ).GetBool() ) {
				pl.cheats |= CF_GODMODE;

				if ( e.PlayerNumber == consoleplayer )
					ZCGlobal.Log( LL_Main, "$EVMAP_AUTOIDDQD" );
			}
		} // of if ( ZCGlobal.IsEverythingLevel() ) {}

		Super.PlayerEntered( e );
	} // of override void PlayerEntered( PlayerEvent e ) {}


	override void NetworkProcess( ConsoleEvent e ) {
		if ( ZCGlobal.IsEverythingLevel() ) {

			if ( e.Name == "zc_evmap_recreate" ) {
				ZCGlobal.Log( LL_Main, "$EVMAP_TOTALRECREATE" );
				RecreateEverything();
			}

		} // of if ( ZCGlobal.IsEverythingLevel() ) {}

		Super.NetworkProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {}

	override void WorldTick() {
		for ( int i = 0; i < MAXPLAYERS; i++ ) {
			if ( playeringame[ i ] && players[ i ].mo && !players[ i ].bot ) {
				PlayerPawn pl = players[ i ].mo;
				FLineTraceData lt;
				pl.LineTrace( pl.angle, pl.radius + 64.0, pl.pitch, TRF_ALLACTORS, pl.player.viewheight, data: lt );

				if ( lt.HitType == TRACE_HitActor && lt.HitActor.GetClass() == "ZCheckerActorInfo" )
					configuration.currentConsoleplayerInfostr = ZCheckerActorInfo( lt.HitActor ).GetInfoString();
				else
					configuration.currentConsoleplayerInfostr = "";
			}
		} // of for ( int i = 0; i < MAXPLAYERS; i++ ) {}

		Super.WorldTick();
	} // of override void WorldTick() {}

	override void RenderOverlay( RenderEvent e ) {
		if ( !PlayerPawn( e.Camera ) )
			return;

		String actorInfostr = configuration.currentConsoleplayerInfostr;

		if ( actorInfostr == "" )
			return;

		if ( !configuration.infostrScaleCVar ) {
			configuration.infostrXCenterCVar = CVar.GetCVar( "mcm_zchecker_ev_infostr_centerx", players[ consoleplayer ] );
			configuration.infostrYCenterCVar = CVar.GetCVar( "mcm_zchecker_ev_infostr_centery", players[ consoleplayer ] );
			configuration.infostrScaleCVar = CVar.GetCVar( "mcm_zchecker_ev_infostr_scale", players[ consoleplayer ] );
		}

		double infostrXCenter = configuration.infostrXCenterCVar.GetFloat() / 100.0;
		double infostrYCenter = configuration.infostrYCenterCVar.GetFloat() / 100.0;
		double infostrScale = 1.0 / configuration.infostrScaleCVar.GetFloat();

		if ( !configuration.zcHandlerPanels ) {
			ZCGlobal tempglobal = ZCGlobal.ClearscopeGet();

			if ( tempglobal ) {
				ZCheckerHandler temphandler = tempglobal.GetHandlerClearscope();

				if ( temphandler && temphandler.panels )
					configuration.zcHandlerPanels = temphandler.panels;
			}
		} // of if ( !configuration.zcHandlerPanels ) {}

		Font rfont = smallfont;

		if ( configuration.zcHandlerPanels ) {
			rfont = configuration.zcHandlerPanels.infopanelsFont;

		} else if ( !configuration.isNoFontWarningShown ) {
			configuration.isNoFontWarningShown = true;
			ZCGlobal.ClearscopeLog( LL_Emergency, GetClassName() .. "::RenderOverlay(). Unable to access the ZChecker handler panels." );

			ZCGlobal tempglobal = ZCGlobal.ClearscopeGet();
			ZCheckerHandler temphandler = ( tempglobal? tempglobal.GetHandlerClearscope() : NULL );
			ZCPanelsStorage temppanels = ( temphandler? temphandler.panels : NULL );
			String DARK  = TEXTCOLOR_DARKGRAY;
			String WHITE = TEXTCOLOR_WHITE;

			ZCGlobal.ClearscopeLog( LL_Main, DARK .. "Data-flow backtrace. (ZCGlobal *)" .. WHITE .. tempglobal .. DARK .. "->(ZCHandler *)" .. WHITE .. temphandler
										  .. DARK .. "->(ZCPanelsStorage *)" .. WHITE .. temppanels .. DARK .. "->(NativeStruct<Font> *)" .. WHITE .. (temppanels? temppanels.infopanelsFont : NULL) .. DARK );
		}


		int height = int( infostrScale * Screen.GetHeight() );
		int width = int( infostrScale * Screen.GetWidth() );
		double stringWidth = rfont.StringWidth( actorInfostr );

		double x = infostrXCenter * width - stringWidth / 2.0;
		double y = infostrYCenter * height;

		// Push the text out from the borders:
		if ( x < 0.0 )
			x = 0.0;
		else if ( x > width - stringWidth )
			x = width - stringWidth;

		Screen.DrawText( rfont, Font.CR_GRAY, x, y, actorInfostr,
				DTA_KeepRatio, true, DTA_VirtualHeight, height, DTA_VirtualWidth, width );

		Super.RenderOverlay( e );
	} // of override void RenderOverlay( RenderEvent e ) {}

} // of class ZCheckerEverythingMapHandler: EventHandler {}


class ZCheckerSectorSetter: Actor {
	const ZCUDMF_Type = ZCheckerEverythingMapHandler.ZCUDMF_Type;
	ZCheckerSectorSetterData evSectorDef;

	vector2 jumpLen;
	int jumpMaxAmount;
	vector2 infoActorOffset;

	int curJumpAmount;

	Default {
		+NOINTERACTION;
		+NOBLOCKMAP;
		FloatBobPhase 0;
	}

	void InitFromPos( void ) {
		bool continueFlag = true;

		if ( !floorsector ) {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::InitFromPos(). " .. LLCOLOR_WARNING .. "Warning: initialization of the sector setter of type \"" .. ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) .. "\" performed outside the map\c-." );
			continueFlag = false;
		} else if ( floorsector.GetUDMFString( ZCUDMF_Type ) != ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) ) {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::InitFromPos(). " .. LLCOLOR_WARNING .. "Warning: sector setter of type \"" .. ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) .. "\" now on sector " .. floorsector.Index() .. " type \"" .. floorsector.GetUDMFString( ZCUDMF_Type ) .. "\"\c-." );
			continueFlag = false;
		}

		if ( continueFlag ) {
			Sector s = floorsector;

			jumpLen = ( s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_JumpX ), s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_JumpY ) );
			infoActorOffset = ( s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_InfoOfsX ), s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_InfoOfsY ) );
			jumpMaxAmount = s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_JumpAmount );
			curJumpAmount = 0;
		}
	} // of void InitFromPos( void ) {}

	override void Tick() {}

	protected bool jumpToNextTypeSegment( void ) {
		bool success = true;

		if ( curJumpAmount >= jumpMaxAmount ) {
			int nextSegment = ZCheckerEverythingMapHandler.FindNextExistingSectorIndex( evSectorDef, evSectorDef.curSegment );

			if ( nextSegment < 0 || nextSegment >= evSectorDef.startSectors.Size() ) {
				success = false;
			} else {
				evSectorDef.curSegment = nextSegment;
				SetOrigin( ( evSectorDef.startSectors[ evSectorDef.curSegment ].centerspot, 0 ), false );
				InitFromPos();
			}
		}

		return success;
	} // of protected bool jumpToNextTypeSegment( void ) {}

	void DoJump( class<Actor> cls ) {
		if ( jumpToNextTypeSegment() ) {
			Actor testeeActor = Actor.Spawn( cls, pos );

			if ( testeeActor ) {
				vector3 infoActorPos = pos + ( infoActorOffset, 0 );

				ZCheckerActorInfo infoActor = ZCheckerActorInfo( Actor.Spawn( "ZCheckerActorInfo", infoActorPos ) );
				infoActor.master = testeeActor;
				infoActor.masterClass = cls;
				infoActor.evSectorDef = evSectorDef;

				infoActor.SetMasterZ();

				SetOrigin( pos + ( jumpLen.x, jumpLen.y, 0 ), false );
				curJumpAmount++;
			} else {
				ZCGlobal.Log( LL_Detailed, GetClassName() .. "::DoJump(). " .. TEXTCOLOR_DARKBROWN .. "Cannot spawn actor \"" .. TEXTCOLOR_WHITE .. cls.GetClassName() .. TEXTCOLOR_DARKBROWN .. "\". It may be abstract or immediately destroyed in the BeginPlay() override." );
			}
		} else {
			ZCGlobal.Log( LL_Main, TEXTCOLOR_DARKGRAY .. GetClassName() .. "::DoJump(). " .. LLCOLOR_WARNING .. "Warning" .. LLCOLOR_MAIN .. ": maximal amount of jumps (" .. jumpMaxAmount .. ") was reached, actor \"" .. cls.GetClassName() .. "\" not spawned." );
		}

	} // of void DoJump( class<Actor> cls ) {}

} // of class ZCheckerSectorSetter: Actor {}



class ZCheckerActorInfo: Actor {
	class<Actor> masterClass;
	String masterInfo;
	vector2 masterOffset;
	ZCheckerSectorSetterData evSectorDef;

	enum EInfoactorStatus {
		IAS_Wrong = 0,	// Frame 'A'.
		IAS_MasterDied,	// Frame 'B'.
		IAS_Ready		// Frame 'C'.
	};

	EInfoactorStatus prevStatus;


	Default {
		-SOLID;
		-SHOOTABLE;
		+NOGRAVITY;
		+DONTSPLASH;
		FloatBobPhase 0;
		Scale 0.5;
		Height 64;
		Radius 30;
		Activation THINGSPEC_Switch;
		+USESPECIAL;
	}

	override void PostBeginPlay() {
		if ( !masterClass ) {
			ZCGlobal.Log( LL_Debug, GetClassName() .. "::PostBeginPlay(). No master class defined, set to self." );
			masterClass = GetClass();
			master = self;
		}

		if ( master ) {
			masterOffset = pos.xy - master.pos.xy;

			masterInfo = master.GetClassName();

			if ( !( master.GetParentClass().GetClassName() == "Actor" ) )
				masterInfo = masterInfo .. "\cf: \c-" .. master.GetParentClass().GetClassName();

			class<Actor> replacee = Actor.GetReplacee( masterClass );

			if ( replacee != masterClass )
				masterInfo = String.Format( ZCGlobal.Locz( "EVMAP_INFOSTR_REPLACES" ), masterInfo, replacee.GetClassName() );

			SetZ( floorZ );
		} else {
			ZCGlobal.Log( LL_Detailed, TEXTCOLOR_DARKGRAY .. "Removing " .. GetClassName() .. " at " .. ZCGlobal.squeezeVector3( pos ) .. ", class \"" .. LLCOLOR_MAIN .. masterClass.GetClassName() .. TEXTCOLOR_DARKGRAY .. "\" in \"" .. ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) .. "\" vanishes." );
			Destroy();
		}

		Super.PostBeginPlay();
	}

	void SetMasterZ( void ) {
		if ( master ) {
			if ( master.bSPAWNCEILING ) {
				master.SetZ( master.ceilingz - master.height );
				master.ClearInterpolation();
				floorclip = -64.0;
			} else if ( master.bNOGRAVITY || master.bNOINTERACTION ) {
				master.AddZ( 16.0 );
				master.ClearInterpolation();
				floorclip = -22.0;
			} else {
				floorclip = -3.5;
			}
		}
	} // of void SetMasterZ( void ) {}

	override void Activate( Actor other ) {
		if ( !PlayerPawn( other ) )
			return;

		if ( !master || ( master.health <= 0 || master.bCORPSE ) ) {
			if ( master )
				master.Destroy();

			master = Spawn( masterClass, ( pos.xy - masterOffset, 0.0 ) );
			ZCConsoleCommand.LogLocalize2Str( LL_Detailed, "EVMAP_RESUMMON", master.GetClassName() );
			SetMasterZ();
		}
	}

	override void Deactivate( Actor other ) {
		Activate( other );
	}

	override void Tick() {
		if ( master is 'Inventory' && Inventory( master ).owner )
			master = NULL;

		EInfoactorStatus curStatus = IAS_Wrong;

		if ( master && master != self ) {
			if ( master.health <= 0 || master.bCORPSE )
				curStatus = IAS_MasterDied;
			else
				curStatus = IAS_Ready;
		}

		if ( curStatus != prevStatus )
			frame = curStatus;

		prevStatus = curStatus;
	}

	String GetInfoString( void ) {
		return masterInfo;
	}

	States {
	Spawn:
		ZCHE A -1 Bright;
		stop;
	}
} // of class ZCheckerActorInfo: Actor {}
