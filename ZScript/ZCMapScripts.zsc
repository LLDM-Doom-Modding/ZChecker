//

struct ZCheckerEverythingMapHandlerConfig {
	// Data-scoped variables. May be changed under both UI and play:
	transient CVar infostrXCenterCVar, infostrYCenterCVar, infostrScaleCVar;
	transient ZCPanelsStorage zcHandlerPanels;
	transient bool isNoFontWarningShown;

	String currentConsoleplayerInfostr;
}

class ZCheckerEverythingMapCategoryData play {
	uint evType;

	Array<Sector> startSectors; // At least one must be presented.
	uint curSegment;
	ZCheckerSectorSetter setter;

	int spawnedActorsAmount;
	int missedActorsAmount;
	Array<ZCheckerCategoryInfoHeader> headerActors;
}

class ZCheckerEverythingMapHandler: EventHandler {
	const ZCUDMF_Type = "user_zcsector_type";	// Category.
	const ZCUDMF_TypeSegment = "user_zcsector_typesegment";	// Current segment index in the category.

	const ZCUDMF_JumpX = "user_zcsector_jump_x";
	const ZCUDMF_JumpY = "user_zcsector_jump_y";
	const ZCUDMF_JumpAmount = "user_zcsector_jumpamount";
	const ZCUDMF_InfoOfsX = "user_zcsector_infoofs_x";
	const ZCUDMF_InfoOfsY = "user_zcsector_infoofs_y";
	const ZCUDMF_CategoryHeaderName = "user_zcsector_categoryheader_name";
	const ZCUDMF_CategoryHeaderOfsX = "user_zcsector_categoryheader_ofsx";
	const ZCUDMF_CategoryHeaderOfsY = "user_zcsector_categoryheader_ofsy";

	const ZCUDMF_SpecialDef = "user_zcsector_specialdef";

	enum ECategoryIdentifiers {
		S__Nothing = -1,

		S_Monsters = 0, S_MonstersLarge, S_MonstersHuge,
		S_Weapons, S_Ammo, S_HealthAndArmor, S_Powerups, S_Keys, S_OtherItems,

		S_DecorSolid, S_DecorSolidLarge, S_DecorShootable,
		S_DecorShootableLarge, S_DecorEthereal, S_DecorEtherealLarge,
		S_DecorNoBlockmap, S_DecorNoInteraction, S_DecorHuge,

		S_Missiles, S_Players, S_SpecialActors,
		// "S_Sound" will not be spawned due to its bNOSECTOR nature.

		S__Quantity
	};

	static const String ECategoryNames[] = { // Case-insensitive.
		"Monsters", "Large monsters", "Huge monsters",
		"Weapons", "Ammo", "Health and armor", "Powerups", "Keys", "Other items", 

		"Decor impassable", "Decor impassable large", "Decor shootable", 
		"Decor shootable large", "Decor ethereal", "Decor ethereal large",
		"Decor NOBLOCKMAP", "Decor NOINTERACTION", "Decor huge",

		"Missiles", "Players", "Special actors"
	};

	ZCheckerEverythingMapCategoryData evSectors[ S__Quantity ];

	bool canRecreateEverything;
	bool logSpawnInfo;
	transient bool isNoFontWarningShown;

	ZCheckerEverythingMapHandlerConfig configuration;


	static String GetESectorName( int which ) {
		String outStr = "";

		if ( which <= S__Nothing || which >= S__Quantity )
			outStr = "<" .. TEXTCOLOR_FIRE .. "unknown: " .. which .. "\c->";
		else
			outStr = ZCheckerEverythingMapHandler.ECategoryNames[ which ];

		return outStr;
	}

	// Main function corresponds to the class directing:
	static ECategoryIdentifiers GetSectorStartForClass( class<Actor> testcls ) {
		ECategoryIdentifiers outValue = S__Nothing;
		readonly<Actor> cls = GetDefaultByType( testcls );

		if ( !cls.bNOSECTOR && !( testcls is 'RandomSpawner' ) ) {
			if ( cls.bISMONSTER ) {
				if ( cls.radius > 384 )
					outValue = S_MonstersHuge;
				else if ( cls.radius > 31.5 )
					outValue = S_MonstersLarge;
				else
					outValue = S_Monsters;
			} else if ( cls.bSPECIAL ) {
				if ( testcls is 'Weapon' || testcls is 'WeaponPiece' )
					outValue = S_Weapons;
				else if ( testcls is 'Ammo' || testcls is 'BackpackItem' )
					outValue = S_Ammo;
				else if ( testcls is 'Armor' || testcls is 'BasicArmor' || testcls is 'BasicArmorBonus' || testcls is 'Health' )
					outValue = S_HealthAndArmor;
				else if ( testcls is 'PowerupGiver' || testcls is 'Powerup' )
					outValue = S_Powerups;
				else if ( testcls is 'Key' || testcls is 'OraclePass' )
					outValue = S_Keys;
				else
					outValue = S_OtherItems;
			} else if ( cls.bMISSILE ) {
				outValue = S_Missiles;
			} else if ( testcls is 'PlayerPawn' ) {
				outValue = S_Players;

				// Skipped all actors with the +NOSECTOR flag set (well, almost):
			} else if (    cls.bACTLIKEBRIDGE || testcls is 'Unknown' || testcls is 'MapMarker'
						|| testcls is 'ItemFog' || testcls is 'PickupFlash' || testcls is 'TeleportFog' 
						|| testcls is 'SecurityCamera' || testcls is 'PatrolPoint' || testcls is 'PatrolSpecial'
						|| testcls is 'InterpolationPoint' || testcls is 'SectorFlagSetter' || testcls is 'ColorSetter'
						|| testcls is 'FadeSetter' || testcls is 'PointPuller' || testcls is 'PointPusher' || testcls is 'PathFollower' ) {
				outValue = S_SpecialActors;

				// Decorations:
			} else if ( cls.bNOBLOCKMAP ) {
				outValue = S_DecorNoBlockmap;
			} else if ( cls.bNOINTERACTION || cls.bNOCLIP ) {
				outValue = S_DecorNoInteraction;
			} else if ( cls.radius > 256 ) {
				outValue = S_DecorHuge;
			} else if ( cls.bSHOOTABLE ) {
				outValue = ( cls.radius > 32? S_DecorShootableLarge : S_DecorShootable );
			} else if ( cls.bSOLID ) {
				outValue = ( cls.radius > 32? S_DecorSolidLarge : S_DecorSolid );
			} else {
				outValue = ( cls.radius > 32? S_DecorEtherealLarge : S_DecorEthereal );
			}
		}

		return outValue;
	} // of static ECategoryIdentifiers GetSectorStartForClass( class<Actor> cls ) {}


	// Next classes forces the game to crash/end the level/etc:
	bool IsClassRestricted( class<Actor> cur ) {
		return (
				// Common dangers:
				cur is "DynamicLight"
			||  cur is "Decal"
			||  cur is "SpecialSpot"
			||  cur is "SpawnShot"
			||  cur is "WeaponPiece"
				// Specific dangers (usually crashing the game):
			||  cur is "ParticleFountain"	// Crashes the game on first tic.
			||  cur is "BossBrain"			// Spawns next to the "ExplosiveBarrel"...
			||  cur == "Bat" 				// Tries to use a NULL "target" field.
			||  cur is "ProgLevelEnder" 	// Just ends the level almost immediately.
			||  cur is "SlideshowStarter" 	// Calls a "level.StartSlideshow()".
			||  cur is "SpectralLightningBigBall1" 	// "Tried to read from address zero. Called from Actor.SpawnSubMissile(); called from SpectralLightningBigBall1.A_SpectralBigBallLightning()".
			||  cur is "LittleFly" 			// Recursive thing search on neighbour sectors (freezes the engine).
		);
	}

	// Test for actors which must be excluded from the automatic actions like total recreation on the ZChecker level:
	bool IsActorRestricted( Actor cur ) {
		return cur && (
			  ( cur is "Inventory" && Inventory( cur ).owner )
			||( cur is "PlayerPawn" && cur.player )
			||  IsClassRestricted( cur.GetClass() )
		);
	}

	// Really just a wrapper around a some extremely rough algorithm (will be rewritten).
	static int FindNextExistingSectorIndex( ZCheckerEverythingMapCategoryData evSector, int fromIndex = -1 ) {
		if ( !evSector )
			return -1;

		int firstExistingSectorIndex = -1;

		for ( int k = fromIndex + 1; k < evSector.startSectors.Size(); k++ ) {
			if ( evSector.startSectors[ k ] ) {
				firstExistingSectorIndex = k;
				break;
			}
		}

		return firstExistingSectorIndex;
	}


	private void logCreatingActor( String msg ) {
		if ( logSpawnInfo )
			ZCGlobal.ClearscopeLog( LL_Main, TEXTCOLOR_DARKGRAY .. "RecreateEverything(): " .. LLCOLOR_MAIN .. msg );
	}

	// Clears all previous spawned actors excluding forbidden and summons all of them again:
	void RecreateEverything( void ) {
		if ( !canRecreateEverything ) {
			ZCConsoleCommand.LogLocalize2Str( LL_Emergency, "EVMAP_INITERROR", GetClassName() );
			return;
		}

		ThinkerIterator it = ThinkerIterator.Create( "Actor" );
		Actor curActor;

		// Destroys everything on the map:
		while ( curActor = Actor( it.Next() ) ) {
			if ( !IsActorRestricted( curActor ) )
				curActor.Destroy();
		}

		for ( int i = 0; i < S__Quantity; i++ ) {
			ZCheckerEverythingMapCategoryData curCategory = evSectors[ i ];
			int startSectorsSize = curCategory.startSectors.Size();

			// Resets general category data:
			curCategory.spawnedActorsAmount = 0;
			curCategory.missedActorsAmount = 0;
			curCategory.headerActors.Clear();

			if ( startSectorsSize != 0 ) {
				int firstExistingSectorIndex = FindNextExistingSectorIndex( evSectors[ i ] );

				curCategory.curSegment = 0;
				curCategory.setter.xypos = curCategory.startSectors[ firstExistingSectorIndex ].centerspot;
				curCategory.setter.ResetJumps();

				// Category header actors spawning and primal initializing:
				bool categoryInfoHeaderFound = false;

				for ( int j = 0; j < startSectorsSize; j++ ) {
					Sector s = curCategory.startSectors[ j ];

					vector2 categoryInfoOffset = (
								s.GetUDMFInt( ZCUDMF_CategoryHeaderOfsX ),
								s.GetUDMFInt( ZCUDMF_CategoryHeaderOfsY )
							);

					if ( categoryInfoOffset.Length() > 0.5 ) {
						categoryInfoHeaderFound = true;

						ZCheckerCategoryInfoHeader categoryHeader = ZCheckerCategoryInfoHeader( Actor.Spawn( "ZCheckerCategoryInfoHeader", (s.centerspot + categoryInfoOffset, s.floorplane.ZAtPoint( s.centerspot )) ) );

						if ( categoryHeader ) {
							curCategory.headerActors.Push( categoryHeader );
							categoryHeader.evSectorDef = curCategory;
							categoryHeader.headerActorStartOffset = categoryInfoOffset;
							categoryHeader.categoryDescription = s.GetUDMFString( ZCUDMF_CategoryHeaderName );
						}
					}
				} // of for ( int j = 0; j < startSectorsSize; j++ ) {}

				if ( !categoryInfoHeaderFound && level.maptime == 0 )
					ZCGlobal.Log( LL_APIMessage, LLCOLOR_DARK .. "Info header actor for category \"" .. LLCOLOR_MAIN .. GetESectorName( i ) .. LLCOLOR_DARK .. "\" not spawned because its offset is omitted or zero." );

			} // of if ( startSectorsSize != 0 ) {}

		} // of for ( int i = 0; i < S__Quantity; i++ ) {}


		bool spawnReplaced = CVar.FindCVar( "mcm_zchecker_ev_spawnreplaced" ).GetBool();
		bool spawnStealth = CVar.FindCVar( "mcm_zchecker_ev_spawnstealth" ).GetBool();
		bool spawnInvis = CVar.FindCVar( "mcm_zchecker_ev_spawninvisible" ).GetBool();
		bool spawnPlayerChunks = CVar.FindCVar( "mcm_zchecker_ev_spawnplrchunks" ).GetBool();
		bool spawnCorruptedSprites = CVar.FindCVar( "mcm_zchecker_ev_spawncorruptedsprites" ).GetBool();
		bool spawnTNT1A0 = CVar.FindCVar( "mcm_zchecker_ev_spawntnt1a0" ).GetBool();
		bool spawnMissedSprites = CVar.FindCVar( "mcm_zchecker_ev_spawnmissingsprites" ).GetBool();
		bool skipRestrictedReplacements = CVar.FindCVar( "mcm_zchecker_ev_restrictreplacements" ).GetBool();

		int spriteTNT1A0 = Actor.GetSpriteIndex( "TNT1A0" );
		logSpawnInfo = CVar.FindCVar( "mcm_zchecker_ev_logspawninfo" ).GetBool();


		// Recreate everything:
		for ( int i = 0; i < AllActorClasses.Size(); i++ ) {
			class<Actor> cls = AllActorClasses[ i ];

			bool skipactor = false;

			if ( IsClassRestricted( cls ) ) {
				skipactor = true;

				if ( logSpawnInfo )
					ZCGlobal.Log( LL_Debug, GetClassName() .. "::RecreateEverything(). Class \"" .. cls.GetClassName() .. "\" is restricted." );

			} else if ( skipRestrictedReplacements ) {
				class<Actor> clsReplacee = Actor.GetReplacee( cls );

				if ( clsReplacee != cls && IsClassRestricted( clsReplacee ) ) {
					skipactor = true;
					logCreatingActor( String.Format( ZCGlobal.Locz( "EVMAPSPAWN_REPLRESTRICTEDSKIP" ), cls.GetClassName(), clsReplacee.GetClassName() ) );
				}
			}

			if ( !skipactor ) {
				bool spriteCheckSuccess = spawnTNT1A0 && spawnCorruptedSprites;

				State st = GetDefaultByType( cls ).SpawnState;
				String stSpriteName = "TNT1A0";
				String stSpriteName4;
				SpriteID stInternalSprite;
				String stInternalSpriteName;

				if ( !spriteCheckSuccess && st ) {
					int statesCountdown = 0;

					stSpriteName = TexMan.GetName( st.GetSpriteTexture( 0 ) );
					stSpriteName4 = stSpriteName.Left( 4 );
					stInternalSprite = st.sprite; // "st.sprite" stores an non-altered sprite.
					stInternalSpriteName = "" .. stInternalSprite;

					// Skipping some "TNT1A0" Decorate-style initialization states:
					while ( st.NextState && ( !spawnTNT1A0 && stSpriteName == "TNT1A0" || !spawnCorruptedSprites && stSpriteName4 != stInternalSpriteName ) && statesCountdown < 7 ) {
						st = st.NextState;
						statesCountdown++;

						stSpriteName = TexMan.GetName( st.GetSpriteTexture( 0 ) );
						stSpriteName4 = stSpriteName.Left( 4 );
						stInternalSprite = st.sprite;
						stInternalSpriteName = "" .. stInternalSprite;
					}

					// A verdict:
					if ( stSpriteName4 == "TNT1" ) {
						// Empty or missing sprite:
						if ( stInternalSprite == spriteTNT1A0 )
							spriteCheckSuccess = spawnTNT1A0;
						else
							spriteCheckSuccess = spawnMissedSprites;

					} else {
						// Valid sprite or sprite with a corrupted name:
						spriteCheckSuccess = ( spawnCorruptedSprites || stSpriteName4 == stInternalSpriteName );
					}
				} // of if ( !spriteCheckSuccess && st ) {}


				if ( !spriteCheckSuccess ) {
					if ( stInternalSprite == spriteTNT1A0 )
						logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_EMPTYSPRITESKIP" ), cls.GetClassName(), stSpriteName ) );
					else if ( stSpriteName4 == "TNT1" )
						logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_MISSPRITESKIP" ), cls.GetClassName(), stInternalSpriteName ) );
					else
						logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_CORRUPSPRITESKIP" ), cls.GetClassName(), stInternalSpriteName, stSpriteName ) );

				} else if ( ( GetDefaultByType( cls ).bSTEALTH && !spawnStealth ) || ( GetDefaultByType( cls ).bINVISIBLE && !spawnInvis ) ) {
					logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_INVISSKIP" ), cls.GetClassName() ) );

				} else if ( !spawnReplaced && Actor.GetReplacement( cls ) != cls ) {
					logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_REPLACEDSKIP" ), cls.GetClassName() ) );

				} else if ( !spawnPlayerChunks && cls is "PlayerChunk" ) {
					logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_PLCHUNKSKIP" ), cls.GetClassName() ) );

				} else {
					ECategoryIdentifiers clsType = GetSectorStartForClass( cls );

					if ( clsType != S__Nothing ) {
						logCreatingActor( String.Format( ZCGlobal.Loc( "EVMAPSPAWN_SUCCESS" ), cls.GetClassName(), stSpriteName ) );

						ZCheckerEverythingMapCategoryData curCategory = evSectors[ clsType ];

						if ( curCategory.setter ) {
							if ( curCategory.setter.DoJump( cls ) )
								curCategory.spawnedActorsAmount++;
							else
								curCategory.missedActorsAmount++;
						}

					} else if ( logSpawnInfo ) {
						ZCGlobal.Log( LL_Debug, GetClassName() .. "::RecreateEverything(). Class \"" .. cls.GetClassName() .. "\" cannot be assigned to any category and thus skipped." );
					}
				}
			} // of if ( !skipactor ) {}

		} // of for ( int i = 0; i < AllActorClasses.Size(); i++ ) {}


		// Category header actors initialization finishing:
		for ( int i = 0; i < S__Quantity; i++ ) {
			ZCheckerEverythingMapCategoryData curCategory = evSectors[ i ];

			for ( int j = 0; j < curCategory.headerActors.Size(); j++ ) {
				ZCheckerCategoryInfoHeader categoryHeader = curCategory.headerActors[ j ];

				categoryHeader.spawnedActorsAmount = curCategory.spawnedActorsAmount;
				categoryHeader.missedActorsAmount = curCategory.missedActorsAmount;
				categoryHeader.InitCategoryHeader();
			}
		}


	} // of void RecreateEverything( void ) {}


	override void OnRegister() {
		SetOrder( ZCheckerMapHandlerOrder );
		Super.OnRegister();
	}

	override void WorldLoaded( WorldEvent e ) {
		if ( !ZCGlobal.IsEverythingLevel() ) {
			Super.WorldLoaded( e );

			Destroy();
			return;
		}

		for ( int i = 0; i < S__Quantity; i++ ) {
			evSectors[ i ] = new( 'ZCheckerEverythingMapCategoryData' );
			evSectors[ i ].evType = i;
		}

		canRecreateEverything = true;

		// Finding special sectors and spawning ev-setters:
		for ( int i = 0; i < level.sectors.Size() && canRecreateEverything; i++ ) {
			String evSectorType = level.Sectors[ i ].GetUDMFString( ZCUDMF_Type );

			bool isSectorTyped = ( evSectorType != "" );
			bool isSectorCategorized = !isSectorTyped;

			// Setting up every e-start sector type:
			for ( int j = 0; !isSectorCategorized && j < S__Quantity; j++ ) {
				if ( evSectorType ~== ECategoryNames[ j ] ) {

					Sector s = level.Sectors[ i ];

					int typeseg = s.GetUDMFInt( ZCUDMF_TypeSegment );
					ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldLoaded(). Found segment #" .. typeseg .. " for \"" .. evSectorType .. "\" (sector " .. i .. ")." );

					// TODO: rewrite this block of code to something decent!
					if ( typeseg ) {
						if ( typeseg < 0 || typeseg > 0xFF )
							ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Custom value \"" .. ZCUDMF_TypeSegment .. " = " .. typeseg .. "\" in sector " .. i .. " not in range [0; 255]." );

						if ( typeseg < evSectors[ j ].startSectors.Size() ) {
							if ( evSectors[ j ].startSectors[ typeseg ] )
								ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Double define for \"" .. GetESectorName( j ) .. "\" segment " .. typeseg .. ". \c-Set linked sector from " .. evSectors[ j ].startSectors[ typeseg ].Index() .. " to " .. s.Index() );

							evSectors[ j ].startSectors.Delete( typeseg, 1 );
						}

						evSectors[ j ].startSectors.Insert( typeseg, s );

						ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldLoaded(). " .. TEXTCOLOR_DARKGREEN .. "Added" .. LLCOLOR_DEBUG .. " segment #" .. typeseg .. " to \"" .. GetESectorName( j ) .. "\" (sec " .. i .. ", segs.Size() " .. evSectors[ j ].startSectors.Size() .. ")." );
					} else {
						if ( evSectors[ j ].startSectors.Size() ) {
							if ( evSectors[ j ].startSectors[ 0 ] )
								ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Double define for \"" .. GetESectorName( j ) .. "\" segment 0." .. TEXTCOLOR_WHITE .. " [WIP; TODO]." );

							evSectors[ j ].startSectors[ 0 ] = s;
						} else {
							evSectors[ j ].startSectors.Push( s );
						}

						if ( evSectors[ j ].setter ) {
							//ZCGlobal.Log( LL_Main, GetClassName() .. "::WorldLoaded(). " .. LLCOLOR_EMERGENCY .. "Cleared setter for \"" .. GetESectorName( j ) .. "\"\c- (linked now to sector " .. evSectors[ j ].startSectors[ 0 ].Index() .. ")." );
							evSectors[ j ].setter.Destroy();
						}
					} // of else of if ( typeseg ) {}

					if ( !evSectors[ j ].setter ) {
						int firstExistingSectorIndex = FindNextExistingSectorIndex( evSectors[ j ] );

						if ( firstExistingSectorIndex != -1 ) {
							ZCheckerSectorSetter newsetter = new( 'ZCheckerSectorSetter' );

							newsetter.evSectorDef = evSectors[ j ];
							newsetter.xypos = evSectors[ j ].startSectors[ firstExistingSectorIndex ].centerspot;
							newsetter.InitFromPos();

							evSectors[ j ].setter = newsetter;

							//ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldLoaded(). Spawned ev-setter for the sector type \"" .. GetESectorName( j ) .. "\"." );
						} else {
							canRecreateEverything = false;
							ZCGlobal.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). Sector type \"" .. GetESectorName( j ) .. "\" has no start sectors." );
							break;
						}
					}

					isSectorCategorized = true;
				} // of if ( evSectorType ~== ECategoryNames[ j ] ) {}
			} // of for ( int j = 0; j < S__Quantity; j++ ) {}


			//   There's a message "Info header actor for category \"%s\" not 
			// spawned because its offset is omitted or zero" in the
			// self::RecreateEverything(), so a expression like
			// "if ( isSectorTyped && !isSectorCategorized ) {}" just will be 
			// redundant.

			if ( isSectorTyped && !isSectorCategorized ) {
				ZCGlobal.Log( LL_Main, String.Format(
						LLCOLOR_WARNING .. "Warning: " .. LLCOLOR_NORMAL .. "sector #%i " .. LLCOLOR_WARNING .. "has unknown value \"%s\" " .. LLCOLOR_NORMAL .. "in UDMF field \"%s\".",
						i, evSectorType, ZCUDMF_Type
					) );
			}

			//console.printf( level.Sectors[ i ].Index() .. ". st: " .. evSectorType .. "/" .. isSectorTyped .. ", sdef: " .. level.Sectors[ i ].GetUDMFString( ZCUDMF_SpecialDef ) );

		} // of for ( int i = 0; i < level.sectors.Size(); i++ ) {}


		for ( int i = 0; i < S__Quantity; i++ ) {
			ZCheckerEverythingMapCategoryData curCategory = evSectors[ i ];
			int startSectorsSize = curCategory.startSectors.Size();

			// Existance checking of each sector category:
			if ( startSectorsSize ) {
				if ( !evSectors[ i ].setter ) {
					ZCGlobal.Log( LL_Emergency, GetClassName() .. "::WorldLoaded(). Error: no sector setter for category \"" .. GetESectorName( i ) .. "\"" );
					canRecreateEverything = false;
				}
			} else {
				ZCGlobal.Log( LL_APIMessage, GetClassName() .. "::WorldLoaded(). Category \"" .. GetESectorName( i ) .. "\" not found." );
			}
		} // of for ( int i = 0; i < S__Quantity; i++ ) {}


		// Create all:
		RecreateEverything();

		Super.WorldLoaded( e );
	} // of override void WorldLoaded( WorldEvent e ) {}

	override void PlayerEntered( PlayerEvent e ) {
		if ( ZCGlobal.IsEverythingLevel() ) {
			PlayerInfo pl = players[ e.PlayerNumber ];

			if ( CVar.GetCVar( "mcm_zchecker_ev_auto_notarget", pl ).GetBool() ) {
				pl.cheats |= CF_NOTARGET;

				if ( e.PlayerNumber == consoleplayer )
					ZCGlobal.Log( LL_Main, "$EVMAP_AUTONOTARGET" );
			}

			if ( CVar.GetCVar( "mcm_zchecker_ev_auto_iddqd", pl ).GetBool() ) {
				pl.cheats |= CF_GODMODE;

				if ( e.PlayerNumber == consoleplayer )
					ZCGlobal.Log( LL_Main, "$EVMAP_AUTOIDDQD" );
			}
		} // of if ( ZCGlobal.IsEverythingLevel() ) {}

		Super.PlayerEntered( e );
	} // of override void PlayerEntered( PlayerEvent e ) {}


	override void NetworkProcess( ConsoleEvent e ) {
		if ( ZCGlobal.IsEverythingLevel() ) {

			if ( e.Name == "zc_evmap_recreate" ) {
				ZCGlobal.Log( LL_Main, "$EVMAP_TOTALRECREATE" );
				RecreateEverything();
			}

		} // of if ( ZCGlobal.IsEverythingLevel() ) {}

		Super.NetworkProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {}

	override void WorldTick() {
		for ( int i = 0; i < MAXPLAYERS; i++ ) {
			if ( playeringame[ i ] && players[ i ].mo && !players[ i ].bot ) {
				PlayerPawn pl = players[ i ].mo;
				FLineTraceData lt;
				pl.LineTrace( pl.angle, pl.radius + 64.0, pl.pitch, TRF_ALLACTORS, pl.player.viewheight, data: lt );

				if ( lt.HitType == TRACE_HitActor ) {
					class<Actor> hitActorClass = lt.HitActor.GetClass();

					if ( hitActorClass == "ZCheckerActorInfo" )
						configuration.currentConsoleplayerInfostr = ZCheckerActorInfo( lt.HitActor ).GetInfoString();
					else if ( hitActorClass == "ZCheckerCategoryInfoHeader" )
						configuration.currentConsoleplayerInfostr = ZCheckerCategoryInfoHeader( lt.HitActor ).GetInfoString();

				} else {
					configuration.currentConsoleplayerInfostr = "";
				}
			}
		} // of for ( int i = 0; i < MAXPLAYERS; i++ ) {}

		Super.WorldTick();
	} // of override void WorldTick() {}

	override void RenderOverlay( RenderEvent e ) {
		if ( !PlayerPawn( e.Camera ) )
			return;

		String actorInfostr = configuration.currentConsoleplayerInfostr;

		if ( actorInfostr == "" )
			return;

		if ( !configuration.infostrScaleCVar ) {
			configuration.infostrXCenterCVar = CVar.GetCVar( "mcm_zchecker_ev_infostr_centerx", players[ consoleplayer ] );
			configuration.infostrYCenterCVar = CVar.GetCVar( "mcm_zchecker_ev_infostr_centery", players[ consoleplayer ] );
			configuration.infostrScaleCVar = CVar.GetCVar( "mcm_zchecker_ev_infostr_scale", players[ consoleplayer ] );
		}

		double infostrXCenter = configuration.infostrXCenterCVar.GetFloat() / 100.0;
		double infostrYCenter = configuration.infostrYCenterCVar.GetFloat() / 100.0;
		double infostrScale = 1.0 / configuration.infostrScaleCVar.GetFloat();

		if ( !configuration.zcHandlerPanels ) {
			ZCGlobal tempglobal = ZCGlobal.ClearscopeGet();

			if ( tempglobal ) {
				ZCheckerHandler temphandler = tempglobal.GetHandlerClearscope();

				if ( temphandler && temphandler.panels )
					configuration.zcHandlerPanels = temphandler.panels;
			}
		} // of if ( !configuration.zcHandlerPanels ) {}

		Font rfont = smallfont;

		if ( configuration.zcHandlerPanels ) {
			rfont = configuration.zcHandlerPanels.infopanelsFont;

		} else if ( !configuration.isNoFontWarningShown ) {
			configuration.isNoFontWarningShown = true;
			ZCGlobal.ClearscopeLog( LL_Emergency, GetClassName() .. "::RenderOverlay(). Unable to access the ZChecker handler panels." );

			ZCGlobal tempglobal = ZCGlobal.ClearscopeGet();
			ZCheckerHandler temphandler = ( tempglobal? tempglobal.GetHandlerClearscope() : NULL );
			ZCPanelsStorage temppanels = ( temphandler? temphandler.panels : NULL );
			String DARK  = TEXTCOLOR_DARKGRAY;
			String WHITE = TEXTCOLOR_WHITE;

			ZCGlobal.ClearscopeLog( LL_Main, DARK .. "Data-flow backtrace. (ZCGlobal *)" .. WHITE .. tempglobal .. DARK .. "->(ZCHandler *)" .. WHITE .. temphandler
										  .. DARK .. "->(ZCPanelsStorage *)" .. WHITE .. temppanels .. DARK .. "->(NativeStruct<Font> *)" .. WHITE .. (temppanels? temppanels.infopanelsFont : NULL) .. DARK );
		}


		int height = int( infostrScale * Screen.GetHeight() );
		int width = int( infostrScale * Screen.GetWidth() );
		double stringWidth = rfont.StringWidth( actorInfostr );

		double x = infostrXCenter * width - stringWidth / 2.0;
		double y = infostrYCenter * height;

		// Push the text out from the borders:
		if ( x < 0.0 )
			x = 0.0;
		else if ( x > width - stringWidth )
			x = width - stringWidth;

		Screen.DrawText( rfont, Font.CR_GRAY, x, y, actorInfostr,
				DTA_KeepRatio, true, DTA_VirtualHeight, height, DTA_VirtualWidth, width );

		Super.RenderOverlay( e );
	} // of override void RenderOverlay( RenderEvent e ) {}

} // of class ZCheckerEverythingMapHandler: EventHandler {}


class ZCheckerSectorSetter play {
	const ZCUDMF_Type = ZCheckerEverythingMapHandler.ZCUDMF_Type;
	ZCheckerEverythingMapCategoryData evSectorDef;

	vector2 xypos;

	vector2 jumpLen;
	int jumpMaxAmount;
	double actorsAngle;

	vector2 infoActorOffset;

	private int curJumpAmount;
	private Sector floorsector;


	void ResetJumps( void ) {
		curJumpAmount = 0;
	}

	void InitFromPos( void ) {
		bool continueFlag = true;

		floorsector = Sector.PointInSector( xypos );

		if ( !floorsector ) {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::InitFromPos(). " .. LLCOLOR_WARNING .. "Warning: initialization of the sector setter of type \"" .. ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) .. "\" performed outside the map\c-." );
			continueFlag = false;
		} else if ( floorsector.GetUDMFString( ZCUDMF_Type ) != ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) ) {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::InitFromPos(). " .. LLCOLOR_WARNING .. "Warning: sector setter of type \"" .. ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) .. "\" now on sector " .. floorsector.Index() .. " type \"" .. floorsector.GetUDMFString( ZCUDMF_Type ) .. "\"\c-." );
			continueFlag = false;
		}

		if ( continueFlag ) {
			Sector s = floorsector;

			jumpLen = ( s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_JumpX ), s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_JumpY ) );
			actorsAngle = atan2( jumpLen.y, jumpLen.x );

			infoActorOffset = ( s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_InfoOfsX ), s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_InfoOfsY ) );

			jumpMaxAmount = s.GetUDMFInt( ZCheckerEverythingMapHandler.ZCUDMF_JumpAmount );
			curJumpAmount = 0;
		}
	} // of void InitFromPos( void ) {}

	protected bool jumpToNextTypeSegment( void ) {
		bool success = true;

		if ( curJumpAmount >= jumpMaxAmount ) {
			int nextSegment = ZCheckerEverythingMapHandler.FindNextExistingSectorIndex( evSectorDef, evSectorDef.curSegment );

			if ( nextSegment < 0 || nextSegment >= evSectorDef.startSectors.Size() ) {
				success = false;
			} else {
				evSectorDef.curSegment = nextSegment;
				xypos = evSectorDef.startSectors[ evSectorDef.curSegment ].centerspot;
				InitFromPos();
			}
		}

		return success;
	} // of protected bool jumpToNextTypeSegment( void ) {}

	bool DoJump( class<Actor> cls ) {
		bool successspawn = true;

		if ( jumpToNextTypeSegment() ) {
			vector3 pos = (xypos, floorsector.floorplane.ZAtPoint( xypos ));
			Actor testeeActor = Actor.Spawn( cls, pos );

			if ( testeeActor ) {
				vector3 infoActorPos = pos + ( infoActorOffset, 0 );

				ZCheckerActorInfo infoActor = ZCheckerActorInfo( Actor.Spawn( "ZCheckerActorInfo", infoActorPos ) );
				infoActor.master = testeeActor;
				infoActor.masterClass = cls;
				infoActor.evSectorDef = evSectorDef;

				infoActor.SetMasterZ();

				testeeActor.angle = actorsAngle;
				xypos += ( jumpLen.x, jumpLen.y );
				curJumpAmount++;
			} else {
				ZCGlobal.Log( LL_Detailed, GetClassName() .. "::DoJump(). " .. TEXTCOLOR_DARKBROWN .. "Cannot spawn actor \"" .. TEXTCOLOR_WHITE .. cls.GetClassName() .. TEXTCOLOR_DARKBROWN .. "\". It may be abstract or immediately destroyed in the BeginPlay() override." );
				successspawn = false;
			}
		} else {
			ZCGlobal.Log( LL_Main, TEXTCOLOR_DARKGRAY .. GetClassName() .. "::DoJump(). " .. LLCOLOR_WARNING .. "Warning" .. LLCOLOR_MAIN .. ": maximal amount of jumps (" .. jumpMaxAmount .. ") was reached, actor \"" .. cls.GetClassName() .. "\" not spawned." );
			successspawn = false;
		}

		return successspawn;
	} // of bool DoJump( class<Actor> cls ) {}

} // of class ZCheckerSectorSetter play {}



class ZCheckerActorInfo: Actor {
	class<Actor> masterClass;
	String masterInfo;
	vector2 masterOffset;
	ZCheckerEverythingMapCategoryData evSectorDef;

	enum EInfoactorStatus {
		IAS_Wrong = 0,		// + 23 == frame 'X'.
		IAS_MasterDied,		// + 23 == frame 'Y'.
		IAS_Ready			// + 23 == frame 'Z'.
	};

	EInfoactorStatus prevStatus;


	Default {
		-SOLID;
		-SHOOTABLE;
		+NOGRAVITY;
		+DONTSPLASH;
		FloatBobPhase 0;
		Scale 0.5;
		Height 64;
		Radius 30;
		Activation THINGSPEC_Switch;
		+USESPECIAL;
	}

	override void PostBeginPlay() {
		if ( !masterClass ) {
			ZCGlobal.Log( LL_Debug, GetClassName() .. "::PostBeginPlay(). No master class defined, set to self." );
			masterClass = GetClass();
			master = self;
		}

		if ( master ) {
			masterOffset = pos.xy - master.pos.xy;

			masterInfo = master.GetClassName();

			if ( !( master.GetParentClass().GetClassName() == "Actor" ) )
				masterInfo = masterInfo .. "\cf: \c-" .. master.GetParentClass().GetClassName();

			class<Actor> replacee = Actor.GetReplacee( masterClass );

			if ( replacee != masterClass )
				masterInfo = String.Format( ZCGlobal.Locz( "EVMAP_INFOSTR_REPLACES" ), masterInfo, replacee.GetClassName() );

			SetZ( floorZ );
		} else {
			ZCGlobal.Log( LL_Detailed, TEXTCOLOR_DARKGRAY .. "Removing " .. GetClassName() .. " at " .. ZCGlobal.squeezeVector3( pos ) .. ", class \"" .. LLCOLOR_MAIN .. masterClass.GetClassName() .. TEXTCOLOR_DARKGRAY .. "\" in \"" .. ZCheckerEverythingMapHandler.GetESectorName( evSectorDef.evType ) .. "\" vanishes." );
			Destroy();
		}

		Super.PostBeginPlay();
	}

	void SetMasterZ( void ) {
		if ( master ) {
			if ( master.bSPAWNCEILING ) {
				master.SetZ( master.ceilingz - master.height );
				master.ClearInterpolation();
				floorclip = -64.0;
			} else if ( master.bNOGRAVITY || master.bNOINTERACTION ) {
				master.AddZ( 16.0 );
				master.ClearInterpolation();
				floorclip = -22.0;
			} else {
				floorclip = -3.5;
			}
		}
	} // of void SetMasterZ( void ) {}

	override void Activate( Actor other ) {
		if ( !PlayerPawn( other ) )
			return;

		if ( !master || ( master.health <= 0 || master.bCORPSE ) ) {
			if ( master )
				master.Destroy();

			master = Spawn( masterClass, ( pos.xy - masterOffset, 0.0 ) );
			ZCConsoleCommand.LogLocalize2Str( LL_Detailed, "EVMAP_RESUMMON", master.GetClassName() );
			SetMasterZ();
		}
	}

	override void Deactivate( Actor other ) {
		Activate( other );
	}

	override void Tick() {
		if ( master is 'Inventory' && Inventory( master ).owner )
			master = NULL;

		EInfoactorStatus curStatus = IAS_Wrong;

		if ( master && master != self ) {
			if ( master.health <= 0 || master.bCORPSE )
				curStatus = IAS_MasterDied;
			else
				curStatus = IAS_Ready;
		}

		if ( curStatus != prevStatus )
			frame = curStatus + 23; // Sprite frames 'X', 'Y' and 'Z'.

		prevStatus = curStatus;
	} // of override void Tick() {}

	String GetInfoString( void ) {
		return masterInfo;
	}

	States {
	Spawn:
		_ZC# X -1 Bright;
		Stop;
	}
} // of class ZCheckerActorInfo: Actor {}


class ZCheckerCategoryInfoHeader: Actor {
	String categoryDescription;
	vector2 headerActorStartOffset;
	int spawnedActorsAmount;
	int missedActorsAmount;
	ZCheckerEverythingMapCategoryData evSectorDef;

	Default {
		-SOLID;
		-SHOOTABLE;
		+NOGRAVITY;
		+DONTSPLASH;
		FloatBobPhase 0;
		RenderStyle "Translucent";
		Alpha 0.33;
		Height 64;
		Radius 30;
	}

	override void Tick() {}

	void InitCategoryHeader( void ) {
		frame = ( evSectorDef? evSectorDef.evType : ZCheckerEverythingMapHandler.S__Nothing );

		if ( categoryDescription == "" ) {
			if ( frame > ZCheckerEverythingMapHandler.S__Nothing && frame < ZCheckerEverythingMapHandler.S__Quantity ) {
				categoryDescription = ZCheckerEverythingMapHandler.GetESectorName( frame );
			} else {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::InitCategoryHeader(). Actor at " .. ZCGlobal.squeezeVector3( pos ) .. ": wrong ev-setter index \"" .. evSectorDef.evType .. "\"." );
				categoryDescription = TEXTCOLOR_FIRE .. "Unknown category index \"" .. evSectorDef.evType .. "\"";
			}
		}

		if ( frame != ZCheckerEverythingMapHandler.S__Nothing ) {
			categoryDescription = String.Format( ZCGlobal.Locz( "EVMAPCATEGORY_PREFIX" ), categoryDescription );

			if ( missedActorsAmount == 0 ) {
				if ( spawnedActorsAmount != 0 )
					categoryDescription.AppendFormat( ZCGlobal.Locz( "EVMAPCATEGORY_NORMALSPAWN" ), spawnedActorsAmount );
				else
					categoryDescription.AppendFormat( ZCGlobal.Locz( "EVMAPCATEGORY_EMPTYSPAWN" ) );

			} else {
				categoryDescription.AppendFormat( ZCGlobal.Locz( "EVMAPCATEGORY_PARTIALSPAWN" ), spawnedActorsAmount, spawnedActorsAmount + missedActorsAmount );
			}
		} // of if ( frame != ZCheckerEverythingMapHandler.S__Nothing ) {}
	} // of void InitCategoryHeader( void ) {}

	String GetInfoString( void ) {
		return categoryDescription;
	}

	States {
	Spawn:
		_ZC# A -1 Bright;
		Stop;
	}
} // of class ZCheckerCategoryInfoHeader: Actor {}
