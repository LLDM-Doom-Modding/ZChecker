class ZCListThinkersCommand: ZCConsoleCommand {
	const ZCSTAT_ERROR = -2;
	const ZCSTAT_LIST = -1;

	int zcStatNumType;
	String helpListStr;
	String helpListValuesColor;

	override String GetCommand() {
		return "zc_listthinkers";
	}

	override String GetHelpNameString() {
		return "zclistthinkers <type>|help|l[ist]";
	}

	override String GetHelpDescString() {
		return "List all loaded thinkers of type <type>. Possible values will be listed if argument is \"help\", \"list\" or just \"l\".";
	}

	override bool HandleArguments() {
		zcStatNumType = ZCSTAT_ERROR;
		if ( ccmd.args.Size() != 1 )
			return false;

		String origarg = ccmd.args[ 0 ];

		if ( origarg ~== "help" || origarg ~== "list" || origarg ~== "l" ) {
			zcStatNumType = ZCSTAT_LIST;
			return true;
		}

		String arg = origarg;

		// Truncating the "s" plural postfix:
		if ( origarg.Mid( origarg.Length() - 1, 1 ) == "s" )
			arg = origarg.Left( origarg.Length() - 1 );

		if ( arg ~== "default" || arg ~== "def" || arg ~== "actor" )
			zcStatNumType = Thinker.STAT_DEFAULT;
		else if ( arg ~== "decal" )
			zcStatNumType = Thinker.STAT_DECAL;
		else if ( arg ~== "autodecal" || arg ~== "decalsauto" || arg ~== "decalauto" )
			zcStatNumType = Thinker.STAT_AUTODECAL;
		else if ( arg ~== "corpsepointer" || arg ~== "hexencorpse" )
			zcStatNumType = Thinker.STAT_CORPSEPOINTER;
		else if ( arg ~== "travelling" || arg ~== "travellingactor" )
			zcStatNumType = Thinker.STAT_TRAVELLING;
		else if ( arg ~== "static" || origarg ~== "s" )
			zcStatNumType = Thinker.STAT_STATIC;
		else if ( arg ~== "scroller" )
			zcStatNumType = Thinker.STAT_SCROLLER;
		else if ( arg ~== "player" )
			zcStatNumType = Thinker.STAT_PLAYER;
		else if ( arg ~== "bosstarget" )
			zcStatNumType = Thinker.STAT_BOSSTARGET;
		else if ( arg ~== "lightning" )
			zcStatNumType = Thinker.STAT_LIGHTNING;
		else if ( arg ~== "decalthinker" )
			zcStatNumType = Thinker.STAT_DECALTHINKER;
		else if ( arg ~== "inventory" || arg ~== "inv" )
			zcStatNumType = Thinker.STAT_INVENTORY;
		else if ( arg ~== "sectorlight" || arg ~== "seclight" )
			zcStatNumType = Thinker.STAT_LIGHT;
		else if ( arg ~== "sectorlighttransfer" || arg ~== "seclighttr" )
			zcStatNumType = Thinker.STAT_LIGHTTRANSFER;
		else if ( arg ~== "earthquake" )
			zcStatNumType = Thinker.STAT_EARTHQUAKE;
		else if ( arg ~== "mapmarker" || arg ~== "marker" || arg ~== "automapmarker" )
			zcStatNumType = Thinker.STAT_MAPMARKER;
		else if ( arg ~== "dynlight" || arg ~== "dl" )
			zcStatNumType = Thinker.STAT_DLIGHT;
		else if ( arg ~== "sectoreffect" || arg ~== "seceffect" )
			zcStatNumType = Thinker.STAT_SECTOREFFECT;
		else if ( arg ~== "actormover" || arg ~== "mover" )
			zcStatNumType = Thinker.STAT_ACTORMOVER;
		else if ( arg ~== "script" || origarg ~== "acs" || arg ~== "acsscript" )
			zcStatNumType = Thinker.STAT_SCRIPTS;
		else if ( arg ~== "bot" )
			zcStatNumType = Thinker.STAT_BOT;
		else if ( str2int_Ptr( ccmd.args[ 0 ], +zcStatNumType ) ) {
			bool inlimits = ( zcStatNumType >= 0 && zcStatNumType <= Thinker.MAX_STATNUM );

			if ( !inlimits )
				ZCGlobal.Log( LL_Main, "StatNum is out of limits. Must be in range [0; " .. Thinker.MAX_STATNUM .. "]." );

			return inlimits;
		}

		return ( zcStatNumType != ZCSTAT_ERROR );
	}

	protected void AddListSection( String sectionname, String nodescolor ) {
		helpListValuesColor = nodescolor;
		helpListStr = helpListStr .. "\n" .. nodescolor .. "<" .. sectionname .. ">" .. CCMDCOLOR_DESC .. ": ";
	}

	protected void AddListValue( String node ) {
		node.Replace( "|", TEXTCOLOR_DARKGRAY .. "|" .. helpListValuesColor );
		helpListStr = helpListStr .. helpListValuesColor .. node .. CCMDCOLOR_DESC .. "; ";
	}

	override void DoCommand() {
		if ( zcStatNumType == ZCSTAT_LIST ) {
			helpListStr = helpListValuesColor = "";

			AddListSection( "Actors", TEXTCOLOR_SAPPHIRE );
			AddListValue( "default|def|actors" );
			AddListValue( "dynlights|dl" );
			AddListValue( "inventory|inv" );
			AddListValue( "mapmarkers|markers|automapmarkers" );
			AddListValue( "bosstargets" );
			AddListSection( "Static", TEXTCOLOR_TEAL );
			AddListValue( "static|s" );
			AddListValue( "info|information" );
			AddListValue( "decals" );
			AddListValue( "autodecals|decalsauto" );
			AddListValue( "corpsepointers|hexencorpses" );
			AddListValue( "travelling|travellingactors" );
			AddListSection( "Sectors", TEXTCOLOR_BRICK );
			AddListValue( "sectorlights|seclights" );
			AddListValue( "sectoreffects|seceffects" );
			AddListValue( "sectorlighttransfers|seclighttr" );
			AddListSection( "Other thinkers", TEXTCOLOR_DARKGREEN );
			AddListValue( "scripts|acs|acsscripts" );
			AddListValue( "lightnings" );
			AddListValue( "players" );
			AddListValue( "bots" );
			AddListValue( "actormovers|movers" );
			AddListValue( "earthquakes" );
			AddListValue( "scrollers" );
			AddListValue( "decalthinkers" );

			console.printf( "Possible types (plural is optional): \n" .. helpListStr .. "or a digit for the non-standard StatNums." );
		} else if ( zcStatNumType >= 0 && zcStatNumType <= Thinker.MAX_STATNUM ) {
			ThinkerIterator it = ThinkerIterator.Create( "Thinker", zcStatNumType );
			Thinker curThinker;

			uint thinkersAmount = 0;

			while ( curThinker = it.Next( false ) ) {
				thinkersAmount++;
				console.printf( " \c-\"" .. curThinker.GetClassName() .. "\" " .. TEXTCOLOR_DARKGRAY .. "(parent class \"\c-" .. ( curThinker.GetParentClass()? curThinker.GetParentClass().GetClassName() .. "\"" : "NULL" ) .. TEXTCOLOR_DARKGRAY .. ")" );
			}

			console.printf( "Total " .. thinkersAmount .. " thinkers of enum type " .. zcStatNumType .. "." );
		} else {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::DoCommand(). False StatNum " .. zcStatNumType );
		}
	}
} // of class ZCListThinkersCommand: ZCConsoleCommand {}


/*
class ZCACSTrackingThinker: Thinker {
	Array<Thinker> prevTicACS;

	override void PostBeginPlay() {
		ZCGlobal.Log( LL_Main, GetClassName() .. "::PostBeginPlay(). Warning: unstable and WIP command." );

		//ChangeStatNum( STAT_USER );
		prevTicACS.Clear();

		ThinkerIterator it = ThinkerIterator.Create( "Thinker", STAT_SCRIPTS );
		Thinker curThinker;

		while ( curThinker = it.Next( true ) )
			prevTicACS.Push( curThinker );

		ZCGlobal.Log( LL_Main, GetClassName() .. "::PostBeginPlay(). ACS thinkers amount: " .. prevTicACS.Size() );

		Super.PostBeginPlay();
	}

	override void Tick() {
		ThinkerIterator it = ThinkerIterator.Create( "Thinker", STAT_SCRIPTS );
		Thinker curThinker;

		int startedACSAmount = 0;
		int finishedACSAmount = 0;

		int prevTicACSIndex = 0;

		while ( curThinker = it.Next( true ) ) {
			if ( prevTicACSIndex >= prevTicACS.Size() ) {
				prevTicACS.Push( curThinker );
				startedACSAmount++;
			} else if ( curThinker != prevTicACS[ prevTicACSIndex ] ) {
				prevTicACS.Delete( prevTicACSIndex, 1 );
				finishedACSAmount++;
				prevTicACSIndex--;
			}

			prevTicACSIndex++;
		}

		if ( startedACSAmount != 0 || finishedACSAmount != 0 )
			ZCGlobal.Log( LL_Main, "ACS tracker. Started " .. startedACSAmount .. ", finished " .. finishedACSAmount );

		Super.Tick();
	}
}

class ZCACSTrackingCommand: ZCConsoleCommand {
	int zcACSTrackingEnable;
	ZCACSTrackingThinker tracker;

	override String GetCommand() {
		return "zc_acstracking";
	}

	override String GetHelpNameString() {
		return "zcacstrack <bool: 0/false/reset or 1/true/set>";
	}

	override String GetHelpDescString() {
		return "Tracks ACS calls (as much as possible). " .. TEXTCOLOR_RED .. "Turned out to be an unnecessary command because there's only one ACS Thinker for all scripts.";
	}

	override bool HandleArguments() {
		return ( initCCMD.args.Size() == 1 ) && ( -1 != ( zcACSTrackingEnable = getBoolArg( 0 ) ) );
	}

	override void DoCommand() {
		//ZCACSTrackingThinker( ThinkerIterator.Create( "ZCACSTrackingThinker", STAT_SCRIPTS ).Next() );

		if ( zcACSTrackingEnable == 0 && tracker ) {
			tracker.Destroy();
		} else if ( zcACSTrackingEnable == 1 && !tracker ) {
			tracker = new( "ZCACSTrackingThinker" );
		}
	}
} // of class ZCACSTrackingCommand: ZCConsoleCommand {}
*/
