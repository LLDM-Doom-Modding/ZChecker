class ZCListThinkersCommand: ZCConsoleCommand {
	const ZCSTAT_ERROR = -2;
	const ZCSTAT_LIST = -1;

	int zcStatNumType;
	String helpListStr;
	String helpListValuesColor;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_listthinkers",
			"zclistthinkers <type>|h[elp]|l[ist]",
			"List all loaded thinkers of type <type>. Possible values will be listed if argument is \"help\", \"list\" or just \"h\" or \"l\"."
		);
	}

	override bool HandleArguments() {
		zcStatNumType = ZCSTAT_ERROR;
		if ( ccmd.args.Size() != 1 )
			return false;

		String origarg = ccmd.args[ 0 ];
		origarg.ToLower();

		if ( origarg == "help" || origarg == "h" || origarg == "list" || origarg == "l" ) {
			zcStatNumType = ZCSTAT_LIST;
			return true;
		}

		String arg = origarg;

		// Truncating the "s" plural postfix:
		if ( origarg.Mid( origarg.Length() - 1, 1 ) == "s" )
			arg = origarg.Left( origarg.Length() - 1 );

		if ( arg == "default" || arg == "def" || arg == "actor" || arg == "a" )
			zcStatNumType = Thinker.STAT_DEFAULT;
		else if ( arg == "decal" || arg == "dec" )
			zcStatNumType = Thinker.STAT_DECAL;
		else if ( arg == "autodecal" || arg == "decalsauto" || arg == "decalauto" || arg == "da" || arg == "ad" )
			zcStatNumType = Thinker.STAT_AUTODECAL;
		else if ( arg == "corpsepointer" || arg == "hexencorpse" )
			zcStatNumType = Thinker.STAT_CORPSEPOINTER;
		else if ( arg == "travelling" || arg == "trinv" )
			zcStatNumType = Thinker.STAT_TRAVELLING;
		else if ( arg == "static" || origarg == "st" || origarg == "s" )
			zcStatNumType = Thinker.STAT_STATIC;
		else if ( arg == "info" || arg == "information" )
			zcStatNumType = Thinker.STAT_INFO;
		else if ( arg == "scroller" )
			zcStatNumType = Thinker.STAT_SCROLLER;
		else if ( arg == "player" || arg == "pl" )
			zcStatNumType = Thinker.STAT_PLAYER;
		else if ( arg == "bosstarget" )
			zcStatNumType = Thinker.STAT_BOSSTARGET;
		else if ( arg == "lightning" )
			zcStatNumType = Thinker.STAT_LIGHTNING;
		else if ( arg == "decalthinker" || arg == "dect" )
			zcStatNumType = Thinker.STAT_DECALTHINKER;
		else if ( arg == "inventory" || arg == "inv" || arg == "i" )
			zcStatNumType = Thinker.STAT_INVENTORY;
		else if ( arg == "sectorlight" || arg == "seclight" || arg == "sl" )
			zcStatNumType = Thinker.STAT_LIGHT;
		else if ( arg == "sectorlighttransfer" || arg == "slt" )
			zcStatNumType = Thinker.STAT_LIGHTTRANSFER;
		else if ( arg == "earthquake" || arg == "quake" )
			zcStatNumType = Thinker.STAT_EARTHQUAKE;
		else if ( arg == "mapmarker" || arg == "marker" || arg == "automapmarker" || arg == "automap" )
			zcStatNumType = Thinker.STAT_MAPMARKER;
		else if ( arg == "dynlight" || arg == "dl" )
			zcStatNumType = Thinker.STAT_DLIGHT;
		else if ( arg == "sectoreffect" || arg == "seceffect" || arg == "sectormover" || arg == "secmover" || arg == "secmov" || arg == "se" || arg == "sm" )
			zcStatNumType = Thinker.STAT_SECTOREFFECT;
		else if ( arg == "actormover" || arg == "mover" )
			zcStatNumType = Thinker.STAT_ACTORMOVER;
		else if ( origarg == "acs" || arg == "acsscript" )
			zcStatNumType = Thinker.STAT_SCRIPTS;
		else if ( arg == "bot" )
			zcStatNumType = Thinker.STAT_BOT;

		else if ( str2int_Ptr( ccmd.args[ 0 ], +zcStatNumType ) ) {
			bool inlimits = ( zcStatNumType >= 0 && zcStatNumType <= Thinker.MAX_STATNUM );

			if ( !inlimits )
				ZCGlobal.Log( LL_Main, "StatNum is out of limits. Must be in range [0; " .. Thinker.MAX_STATNUM .. "]." );

			return inlimits;
		}

		return ( zcStatNumType != ZCSTAT_ERROR );
	}

	protected void AddListSection( String sectionname, String nodescolor ) {
		helpListValuesColor = nodescolor;
		helpListStr = helpListStr .. "\n" .. nodescolor .. "<" .. sectionname .. ">" .. CCMDCOLOR_DESC .. ": ";
	}

	protected void AddListValue( String node ) {
		node.Replace( "|", TEXTCOLOR_DARKGRAY .. "|" .. helpListValuesColor );
		node.Replace( "[", TEXTCOLOR_DARKGRAY .. "[" .. helpListValuesColor );
		node.Replace( "]", TEXTCOLOR_DARKGRAY .. "]" .. helpListValuesColor );
		helpListStr = helpListStr .. helpListValuesColor .. node .. CCMDCOLOR_DESC .. "; ";
	}

	override void DoCommand() {
		if ( zcStatNumType == ZCSTAT_LIST ) {
			helpListStr = helpListValuesColor = "";

			AddListSection( "Actors", TEXTCOLOR_SAPPHIRE );
			AddListValue( "a[ctors]|def[ault]" );
			AddListValue( "dynlights|dl" );
			AddListValue( "i[nv[entory]]" );
			AddListValue( "mapmarkers|markers|automap[markers]" );
			AddListValue( "bosstargets" );
			AddListSection( "Static", TEXTCOLOR_TEAL );
			AddListValue( "static|s" );
			AddListValue( "info[rmation]" );
			AddListValue( "decals|dec" );
			AddListValue( "autodecals|decalsauto|da|ad" );
			AddListValue( "corpsepointers|hexencorpses" );
			AddListValue( "travelling|trinv" );
			AddListSection( "Sectors", TEXTCOLOR_BRICK );
			AddListValue( "sec[tor]mov[ers]|sec[tor]effects|sm|se" );
			AddListValue( "sec[tor]lights|sl" );
			AddListValue( "sectorlighttransfers|slt" );
			AddListSection( "Other thinkers", TEXTCOLOR_DARKGREEN );
			AddListValue( "acs|acsscripts" );
			AddListValue( "lightnings" );
			AddListValue( "pl[ayers]" );
			AddListValue( "bots" );
			AddListValue( "[actor]movers" );
			AddListValue( "[earth]quakes" );
			AddListValue( "scrollers" );
			AddListValue( "decalthinkers|dect" );

			console.printf( "Possible types (plural is optional): \n" .. helpListStr .. "\nOr a digit for the non-standard StatNums " ..
							"(for user-defined: " .. TEXTCOLOR_SAPPHIRE .. Thinker.STAT_USER .. CCMDCOLOR_DESC .. ".." .. TEXTCOLOR_SAPPHIRE .. Thinker.STAT_USER_MAX .. CCMDCOLOR_DESC .. ")." );
		} else if ( zcStatNumType >= 0 && zcStatNumType <= Thinker.MAX_STATNUM ) {
			ThinkerIterator it = ThinkerIterator.Create( "Thinker", zcStatNumType );
			Thinker curThinker;

			uint thinkersAmount = 0;

			while ( curThinker = it.Next( false ) ) {
				thinkersAmount++;
				// It seems like there's no way to check if a Thinker class
				//is accesible via ZScript (like 'ImpactDecal'). So this
				//interesting functional will potentially never be released.

				String extrainfo = "";

				if ( curThinker is "Actor" ) {
					Actor curActor = Actor( curThinker );

					if ( curActor is "Inventory" && Inventory( curActor ).owner ) {
						Actor invowner = Inventory( curActor ).owner;
						extrainfo = "inv.owner is " .. LLCOLOR_MAIN .. invowner.GetClassName() ..
							( invowner.bNOSECTOR? "(+NOSECTOR)" : TEXTCOLOR_DARKGRAY .. " at " .. ZCGlobal.squeezeVector3( invowner.pos ) );

					} else if ( curActor.bNOSECTOR ) {
						extrainfo = "(+NOSECTOR)";
					} else {
						extrainfo = "at " .. ZCGlobal.squeezeVector3( curActor.pos );
					}
				}

				console.printf( "  " .. TEXTCOLOR_WHITE .. "%-10s" .. TEXTCOLOR_GRAY .. ": %s" .. ( extrainfo != ""? TEXTCOLOR_DARKGRAY .. ", " .. extrainfo : "" ),
								curThinker.GetClassName(),
								( curThinker.GetParentClass()? curThinker.GetParentClass().GetClassName() .. "" : TEXTCOLOR_BRICK .. "<no parent>" ) );
			}

			console.printf( "Total " .. thinkersAmount .. " thinkers of enum type " .. zcStatNumType .. "." );
		} else {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::DoCommand(). False StatNum " .. zcStatNumType );
		}
	}
} // of class ZCListThinkersCommand: ZCConsoleCommand {}


/*
class ZCACSTrackingThinker: Thinker {
	Array<Thinker> prevTicACS;

	override void PostBeginPlay() {
		ZCGlobal.Log( LL_Main, GetClassName() .. "::PostBeginPlay(). Warning: unstable and WIP command." );

		//ChangeStatNum( STAT_USER );
		prevTicACS.Clear();

		ThinkerIterator it = ThinkerIterator.Create( "Thinker", STAT_SCRIPTS );
		Thinker curThinker;

		while ( curThinker = it.Next( true ) )
			prevTicACS.Push( curThinker );

		ZCGlobal.Log( LL_Main, GetClassName() .. "::PostBeginPlay(). ACS thinkers amount: " .. prevTicACS.Size() );

		Super.PostBeginPlay();
	}

	override void Tick() {
		ThinkerIterator it = ThinkerIterator.Create( "Thinker", STAT_SCRIPTS );
		Thinker curThinker;

		int startedACSAmount = 0;
		int finishedACSAmount = 0;

		int prevTicACSIndex = 0;

		while ( curThinker = it.Next( true ) ) {
			if ( prevTicACSIndex >= prevTicACS.Size() ) {
				prevTicACS.Push( curThinker );
				startedACSAmount++;
			} else if ( curThinker != prevTicACS[ prevTicACSIndex ] ) {
				prevTicACS.Delete( prevTicACSIndex, 1 );
				finishedACSAmount++;
				prevTicACSIndex--;
			}

			prevTicACSIndex++;
		}

		if ( startedACSAmount != 0 || finishedACSAmount != 0 )
			ZCGlobal.Log( LL_Main, "ACS tracker. Started " .. startedACSAmount .. ", finished " .. finishedACSAmount );

		Super.Tick();
	}
}

class ZCACSTrackingCommand: ZCConsoleCommand {
	int zcACSTrackingEnable;
	ZCACSTrackingThinker tracker;

	override void InitCCMD() {
		SetupCCMDInterface(
			"zc_acstracking",
			"zcacstrack <bool: 0/false/reset or 1/true/set>",
			"Tracks ACS calls (as much as possible). " .. TEXTCOLOR_RED .. "Turned out to be an unnecessary command because there's only one ACS Thinker for all scripts."
		);
	}

	override bool HandleArguments() {
		return ( initCCMD.args.Size() == 1 ) && ( -1 != ( zcACSTrackingEnable = getBoolArg( 0 ) ) );
	}

	override void DoCommand() {
		//ZCACSTrackingThinker( ThinkerIterator.Create( "ZCACSTrackingThinker", STAT_SCRIPTS ).Next() );

		if ( zcACSTrackingEnable == 0 && tracker ) {
			tracker.Destroy();
		} else if ( zcACSTrackingEnable == 1 && !tracker ) {
			tracker = new( "ZCACSTrackingThinker" );
		}
	}
} // of class ZCACSTrackingCommand: ZCConsoleCommand {}
*/
