class ZCHelpCommand: ZCConsoleCommand {
	bool verboseHelp;
	ZCConsoleCommand infoclass;

	override String GetCommand() {
		return "zc_help";
	}

	override String GetHelpNameString() {
		return "zchelp [<command> | a[ll]|-a|-v]";
	}

	override String GetHelpDescString() {
		return "This help. If argument is provided, displays complete help.";
	}

	override bool HandleArguments() {
		verboseHelp = false;
		infoclass = NULL;
		bool outValue = ( ccmd.args.Size() == 0 );

		if ( ccmd.args.Size() == 1 ) {
			String arg = ccmd.args[ 0 ];
			arg.ToLower();

			if ( arg == "a" || arg == "all" || arg == "-a" || arg == "-v" ) {
				verboseHelp = outValue = true;
			} else {

				if ( arg.Left( 2 ) == "zc" )
					arg = arg.Mid( 2, arg.Length() - 1 );

				for ( int i = 0; i < ccmd.handler.zcConsoleHandleClasses.Size() && !outValue; i++ ) {
					ZCConsoleCommand curccmd = ZCConsoleCommand( ccmd.handler.zcConsoleHandleClasses[ i ] );

					if ( curccmd ) {
						Array<String> aliases;
						curccmd.GetHelpNameString().Split( aliases, ";", TOK_SKIPEMPTY );

						for ( int j = 0; j < aliases.Size(); j++ ) {
							String curalias = aliases[ j ];
							int firstSpaceIndex = curalias.IndexOf( " " );

							if ( firstSpaceIndex >= 0 )
								curalias.Truncate( firstSpaceIndex );
							if ( curalias.Length() > 2 )
								curalias = curalias.Mid( 2, curalias.Length() - 1 );

							ZCGlobal.Log( LL_Debug, GetClassName() .. "::HandleArguments(). Arg \"" .. arg .. "\" compare alias \"" .. curalias .. "\"." );

							if ( arg ~== curalias ) {
								ZCGlobal.Log( LL_Debug, GetClassName() .. "::HandleArguments(). Usage search for \"" .. arg .. "\": found CCMD " .. curccmd.GetClassName() .. "." );
								infoclass = curccmd;
								outValue = true;
								break;
							}
						} // of for ( int j = 0; j < aliases.Size(); j++ ) {}

					} // of if ( curccmd ) {}
				} // of for ( int i = 0; i < ccmd.handler.zcConsoleHandleClasses.Size(); i++ ) {}

				ZCGlobal.Log( LL_Main | LL_NoDot, ( outValue
						? TEXTCOLOR_TEAL .. "ZChecker help: " .. TEXTCOLOR_SAPPHIRE .. " === Visual " .. TEXTCOLOR_DARKRED .. "separator ==="
						: TEXTCOLOR_TEAL .. "ZChecker help: " .. TEXTCOLOR_FIRE .. "cannot find ZChecker console command " .. LLCOLOR_MAIN .. "\"" .. ccmd.args[ 0 ] .. "\"."
					) );
			}
		}

		return outValue;
	}

	override void DoCommand( void ) {
		// Description and credits:
		if ( verboseHelp ) {
			console.printf( TEXTCOLOR_SAPPHIRE .. "ZChecker " .. TEXTCOLOR_BLUE .. "v" .. ZCheckerVersion
					.. "\c- by " .. TEXTCOLOR_WHITE .. "JSO_x\c- a.k.a. " .. TEXTCOLOR_WHITE .. "Morthimer McMare\c-.\n\n" );
		}

		if ( infoclass ) {
			console.printf( infoclass.GetHelpString() );
		} else {
			console.printf( TEXTCOLOR_WHITE .. "Available commands, " .. ( verboseHelp ? "complete list" : "common used" ) .. ":\n\n" );

			ZCConsoleClass curCC = NULL; // Also separators.

			for ( int i = 0; curCC = ccmd.handler.GetZCConsoleClass( i ); i++ )
				if ( verboseHelp || ( curCC.zcFlags & CCF_Important ) )
					console.printf( curCC.GetHelpString() .. "\n\n" );
		}
	}
} // of class ZCHelpCommand: ZCConsoleCommand {}


class ZCAddCommand: ZCConsoleCommand {
	enum ESpecialAddTypes {
		SAT_Error = 0,
		SAT_Normal,
		SAT_Self,
		SAT_Weapon,
		SAT_Force
	};

	ESpecialAddTypes zcSpecialAddType;
	int zcPos;

	override String GetCommand() {
		return "zc_add";
	}

	override String GetHelpNameString() {
		return "zcadd [self|weap[on]|force] [<pos>];zcaddself [<pos>];zcaddweap [<pos>];zcaddf [<pos>]";
	}

	override String GetHelpDescString() {
		return "Add a linetarget/current player/current weapon/non-solid linetarget into list. [<pos>] is a place number to set to; if omitted, first empty slot will be used.";
	}

	override bool HandleArguments() {
		zcSpecialAddType = SAT_Normal;

		// For 0 args: zcPos == "-1" (to check it later).
		bool outValue = ( ccmd.args.Size() == 0 );
		zcPos = -1;

		// Next lines ("if {}" block) are hard to understand, but they're right.
		if ( ccmd.args.Size() > 0 && ccmd.args.Size() <= 2 ) {
			String arg0 = ccmd.args[ 0 ];

			zcSpecialAddType = SAT_Error;

			if ( arg0 ~== "self" )
				zcSpecialAddType = SAT_Self;
			else if ( arg0 ~== "weap" || arg0 ~== "weapon" )
				zcSpecialAddType = SAT_Weapon;
			else if ( arg0 ~== "force" )
				zcSpecialAddType = SAT_Force;

			if ( zcSpecialAddType != SAT_Error ) {
				// "zcadd self|weap[on]|force [pos]":

				if ( ccmd.args.Size() == 2 ) {
					if ( str2int_Ptr( ccmd.args[ 1 ], +zcPos ) )
						outValue = checkTesteePlace( --zcPos );
				} else {
					outValue = true;
				}
			} else {
				// "zcadd [pos]":

				zcSpecialAddType = SAT_Normal;
				if ( str2int_Ptr( arg0, +zcPos ) )
					outValue = checkTesteePlace( --zcPos );
			}
		} // of if ( ccmd.args.Size() > 0 && ccmd.args.Size() <= 2 ) {

		// Find next free testee place ("-1" if not found):
		if ( outValue && zcPos == -1 ) {
			for ( int i = 0; i < MaxTestee && zcPos == -1; i++ )
				if ( ccmd.handler.Testee[ i ].mo == NULL )
					zcPos = i;
		}

		return outValue;
	}

	override void DoCommand( void ) {
		if ( zcPos != -1 ) {
			PlayerInfo player = players[ ccmd.e.Player ];

			ZCheckerField field = ccmd.handler.Testee[ zcPos ];

			switch ( zcSpecialAddType ) {
				case SAT_Normal:
					Actor linetracedActor = LinetraceActor( player.mo );

	                if ( linetracedActor ) {
						field.mo = linetracedActor;
						ZCGlobal.Log( LL_Detailed, "Added actor " .. field.mo.GetClassName() .. " <" .. field.mo .. ">." );
					}
					break;
				case SAT_Self:
					field.mo = player.mo;
					ZCGlobal.Log( LL_Detailed, "Added PlayerPawn actor " .. field.mo.GetClassName() .. " <" .. field.mo .. ">." );
					break;
				case SAT_Weapon:
					if ( player.ReadyWeapon ) {
						field.mo = player.ReadyWeapon;
						ZCGlobal.Log( LL_Detailed, "Added StateProvider actor " .. field.mo.GetClassName() .. " <" .. field.mo .. ">." );
					} else {
						ZCGlobal.Log( LL_Main, "No weapon, cannot add." );
					}
					break;
				case SAT_Force:
					ZCGlobal.Log( LL_Main, "[Work-in-progress command, may behave strangely]." );

					ThinkerIterator it = ThinkerIterator.Create( "Actor" );
					Actor locatedActor = NULL, cur = NULL;

					while ( ( cur = Actor( it.Next() ) ) ) {
						// Skip next actor if it:
						//1) A caller (player) himself;
						//2) Is not in the player field of view; and
						//3) Is an item in someone's inventory.
						if ( cur == player.mo || ( abs( player.mo.AngleTo( cur ) - player.mo.angle ) >= 45.0 ) || ( Inventory( cur ) && Inventory( cur ).owner ) )
							continue;

						// Grab the potential testee actor if the line of 
						//sight intersects or touches its radius (circle).
						// Funny, but right now I haven't written the 
						//Z-exclusion despite of the realisation easiness.
						vector2 plpos = player.mo.pos.xy;
						vector2 curpos = cur.pos.xy;
						double k = tan( player.mo.angle );
						double r = cur.radius;

						double kk = k * k;
						double rr = r * r;
						vector2 plpos2 = ( plpos.x * plpos.x, plpos.y * plpos.y );
						vector2 curpos2 = ( curpos.x * curpos.x, curpos.y * curpos.y );

						//sqrt( k^2 r^2 - k^2 x_c^2 - k^2 x_p^2 + 2 k^2 x_c x_p + 2 k (x_p - x_c) y_p + 2 y_c (k (x_c - x_p) + y_p) + r^2 - y_c^2 - y_p^2 )
						double underSqrt = ( kk * rr - kk * curpos2.x - kk * plpos2.x + 2 * kk * curpos.x * plpos.x + 2 * k * ( plpos.x - curpos.x ) * plpos.y + 2 * curpos.y * ( k * ( curpos.x - plpos.x ) + plpos.y ) );

						if ( ZCGlobal.Get().zcCurLogLevel >= LL_Debug ) {
							ZCGlobal.Log( LL_Debug, "Cur " .. TEXTCOLOR_OLIVE .. cur.GetClassName() .. LLCOLOR_DEBUG .. ": " ..
									String.Format( "plr.pos %s, cur.pos %s, plr.angle %.3f, k %.3f, cur.radius %.3f;  = sqrt( " .. TEXTCOLOR_GRAY .. "%+.3f" .. LLCOLOR_DEBUG .. " ), prev& " .. locatedActor,
									ZCGlobal.squeezeVector2( plpos ), ZCGlobal.squeezeVector2( curpos ), player.mo.angle, k, r, underSqrt )
								);
						}

						if ( underSqrt >= 0 && ( !locatedActor || ( cur.Distance3D( player.mo ) < locatedActor.Distance3D( player.mo ) ) ) ) {
							locatedActor = cur;
							ZCGlobal.Log( LL_Debug, GetClassName() .. "::DoCommand(). Force. " .. TEXTCOLOR_GREEN .. "Actor updated to " .. cur.GetClassName() );
						}
					}

	                if ( locatedActor ) {
						field.mo = locatedActor;
						ZCGlobal.Log( LL_Detailed, "Added an arbitrary actor " .. field.mo.GetClassName() .. " <" .. field.mo .. ">." );
					} else {
						ZCGlobal.Log( LL_Detailed, "Cannot find any suitable actors." );
					}
					break;
				default:
					ZCGlobal.Log( LL_Emergency, GetClassName() .. "::DoCommand(). Unknown add type \"" .. zcSpecialAddType .. "\"." );
					break;
			}

			if ( field.mo ) {
				SetInternalZCheckerString( "$last", field.mo.GetClassName() );
				ccmd.handler.UpdateInternalClassnameByField( zcPos );
			}

		} else {
			ZCGlobal.Log( LL_Normal, "Cannot add target to list, insuffienty place. Try set target to list directly with \"zcadd [1.." .. MaxTestee .. "]\"." );
		} // of else of if ( zcPos != -1 ) {}
	}
} // of class ZCAddCommand: ZCConsoleCommand {}

class ZCRemCommand: ZCConsoleCommand {
	int zcPos;

	override String GetCommand() {
		return "zc_rem";
	}

	override String GetHelpNameString() {
		return "zcrem [<pos>]";
	}

	override String GetHelpDescString() {
		return "Remove testee(s) from <pos> or from whole list if omitted.";
	}

	override bool HandleArguments() {
		zcPos = -1;
		bool outValue = ( ccmd.args.Size() == 0 );

		if ( ccmd.args.Size() == 1 ) {
			if ( str2int_Ptr( ccmd.args[ 0 ], +zcPos ) )
				outValue = checkTesteePlace( --zcPos );
		}

		return outValue;
	}

	override void DoCommand( void ) {
		if ( zcPos != -1 ) {
			Actor testee = ccmd.handler.Testee[ zcPos ].mo;
			if ( testee ) {
				ZCGlobal.Log( LL_Detailed, "Removed actor \"" .. testee.GetClassName() .. "\" <" .. testee .. "> from position " .. zcPos + 1 .. "." );
				ccmd.handler.Testee[ zcPos ].mo = NULL;

				ccmd.handler.UpdateInternalClassnameByField( zcPos );
			} else {
				ZCGlobal.Log( LL_Detailed, "Cannot remove, there's no actor in position " .. zcPos + 1 .. "." );
			}
		} else {
			for ( int i = 0; i < MaxTestee; i++ )
				ccmd.handler.Testee[ i ].mo = NULL;

			ZCGlobal.Log( LL_Detailed, "All actors cleared from the hotbar." );
		}
	}
} // of class ZCRemCommand: ZCConsoleCommand {}

class ZCInfoPanelControlAliasNode {
	String aliasname;
	Actor thing;
}

class ZCInfoPanelControlCommand: ZCConsoleCommand {
	const GRAY = TEXTCOLOR_GRAY;
	const DARKGRAY = TEXTCOLOR_DARKGRAY;

	enum EPanelControlTypes {
		PCT_Error = 0,
		PCT_Save,
		PCT_Load,
		PCT_Move,
		PCT_Copy,
		PCT_Info
	};

	EPanelControlTypes zcPanelControlType;
	int zcPos, zcNewPos;
	String zcAliasName;

	Array<ZCInfoPanelControlAliasNode> aliases;

	private int FindAliasIndex( String aliasname ) {
		int outValue = -1;

		if ( aliasname != "" ) {
			for ( int i = 0; i < aliases.Size(); i++ ) {
				if ( aliases[ i ].aliasname == aliasname ) {
					outValue = i;
					break;
				}
			}
		}

		return outValue;
	} // of private int FindAliasIndex( String aliasname ) {}

	override String GetCommand() {
		return "zc_infopanelcontrol";
	}

	override String GetHelpNameString() {
		return "zcpanel <pos> m[ove] <newpos>;zcpanel <pos> c[opy] <newpos>;zcpanel <pos> save|store|load <aliasname>;zcpanel info [<pos>];zcpanel <pos> info";
	}

	override String GetHelpDescString() {
		return "Perform keen control with information panels.\n  Possible placeholders for the <string value> (first symbol must be \"%%\" or \"$\"): \"$self\" (caller itself), \"$lt\"|\"$linetarget\" (caller's linetarget), \"$target\" (caller's target field), \"$master\" (its master), \"$tracer\" (its tracer).";
	}

	override bool HandleArguments() {
		zcPos = zcNewPos = -1;
		zcAliasName = "";
		zcPanelControlType = PCT_Error;

		int ccmdArgsSize = ccmd.args.Size();
		bool outValue = false;

		if ( ccmdArgsSize == 1 && ccmd.args[ 0 ] ~== "info" ) {
			zcPanelControlType = PCT_Info;
			outValue = true;

		} else if ( ccmdArgsSize == 2 ) {
			zcPanelControlType = PCT_Info;

			for ( int i = 0; i < 2; i++ ) {
				if ( ccmd.args[ i ] ~== "info" && str2int_Ptr( ccmd.args[ i ^ 1 ], +zcPos ) ) {
					outValue = checkTesteePlace( --zcPos );
					break;
				}
			}

		} else if ( ccmdArgsSize == 3 ) {
			String argOperation = ccmd.args[ 1 ];
			argOperation.ToLower();
			bool parsingError = false;
			bool parsePosArg = true;
			bool parsePosNewArg = false;

			if ( argOperation == "save" || argOperation == "store" || argOperation == "load" ) {
				zcAliasName = ccmd.args[ 2 ];
				zcPanelControlType = ( argOperation == "load"? PCT_Load : PCT_Save );
			} else if ( argOperation == "move" || argOperation == "m" || argOperation == "copy" || argOperation == "c" ) {
				parsePosNewArg = true;
				zcPanelControlType = ( argOperation.Left( 1 ) == "c"? PCT_Copy : PCT_Move );
			} else {
				parsePosArg = false;
			}

			if ( parsePosArg ) {
				if ( str2int_Ptr( ccmd.args[ 0 ], +zcPos ) )
					outValue = checkTesteePlace( --zcPos );

				if ( parsePosNewArg && outValue && str2int_Ptr( ccmd.args[ 2 ], +zcNewPos ) )
					outValue = checkTesteePlace( --zcNewPos );
			}
		}

		return outValue;
	}

	override void DoCommand( void ) {
		if ( zcPos != -1 ) {
			ZCheckerHandler handler = ccmd.handler;

			switch ( zcPanelControlType ) {
			case PCT_Save:
				if ( handler.Testee[ zcPos ].mo ) {
					int index = FindAliasIndex( zcAliasName );
					bool continueFlag = true;

					if ( index != -1 ) {
						if ( aliases[ index ].thing ) {
							ZCGlobal.Log( LL_Main, "Alias \"" .. zcAliasName .. "\" already exists and linked to the actor." );
							continueFlag = false;
						} else {
							ZCGlobal.Log( LL_Detailed, "Relinking the \"" .. zcAliasName .. "\" alias (its original actor destroyed)." );
						}
					} 

					if ( continueFlag ) {
						ZCInfoPanelControlAliasNode aliasnode = ZCInfoPanelControlAliasNode( new( 'ZCInfoPanelControlAliasNode' ) );

						aliasnode.aliasname = zcAliasName;
						aliasnode.thing = handler.Testee[ zcPos ].mo;
						aliases.Push( aliasnode );

						ZCGlobal.Log( LL_Detailed, "Saved actor " .. ccmd.handler.Testee[ zcPos ].mo.GetClassName() .. " <" .. ccmd.handler.Testee[ zcPos ].mo .. "> as \"" .. zcAliasName .. "\"." );
					}
				} else {
					ZCGlobal.Log( LL_Main, "No actor linked to the panel " .. ( zcPos + 1 ) );
				}
				break;
			case PCT_Load:
				int index = FindAliasIndex( zcAliasName );

				if ( index != -1 ) {
					if ( aliases[ index ].thing ) {
						handler.Testee[ zcPos ].mo = aliases[ index ].thing;
						ccmd.handler.UpdateInternalClassnameByField( zcPos );

						ZCGlobal.Log( LL_Detailed, "Loaded actor " .. ccmd.handler.Testee[ zcPos ].mo.GetClassName() .. " <" .. ccmd.handler.Testee[ zcPos ].mo .. "> with alias \"" .. zcAliasName .. "\"." );
					} else {
						ZCGlobal.Log( LL_Detailed, "Cannot load, actor with alias \"" .. zcAliasName .. "\" destroyed." );
					}
				} else {
					ZCGlobal.Log( LL_Main, "Alias name \"" .. zcAliasName .. "\" does not exist." );
				}
				break;
			case PCT_Move:
			case PCT_Copy:
				if ( handler.Testee[ zcPos ].mo ) {
					if ( zcNewPos != -1 )
						handler.Testee[ zcNewPos ].mo = handler.Testee[ zcPos ].mo;

					if ( zcPanelControlType == PCT_Move )
						handler.Testee[ zcPos ].mo = NULL;

					ccmd.handler.UpdateInternalClassnameByField( zcPos );
					ccmd.handler.UpdateInternalClassnameByField( zcNewPos );
				} else {
					ZCGlobal.Log( LL_Main, "No actor in position " .. ( zcPos + 1 ) );
				}
				break;
			case PCT_Info:
				Actor mo = handler.Testee[ zcPos ].mo;

				if ( mo ) {
					ZCGlobal.Log( LL_Debug, "ccmd.handler.Testee[ " .. zcPos .. " ]: " .. handler.Testee[ zcPos ] .. "." );

					ZCGlobal.ClearscopeLog( LL_Main, DARKGRAY .. "Actor in position " .. GRAY .. ( zcPos + 1 ) .. DARKGRAY .. " is " .. GRAY .. mo.GetClassName() .. DARKGRAY .. " <" .. mo .. ">" );

					class parentClass = mo.GetParentClass();

					while ( parentClass != NULL ) {
						ZCGlobal.ClearscopeLog( LL_Main, DARKGRAY .. "  Inherited from " .. GRAY .. parentClass.GetClassName() .. DARKGRAY .. " <" .. parentClass .. ">" );
						parentClass = parentClass.GetParentClass();
					}

				} else {
					ZCGlobal.ClearscopeLog( LL_Main, "There's no actor in position " .. ( zcPos + 1 ) );
				}
				break;
			default:
				ZCGlobal.Log( LL_Emergency, "Unknown panel control type " .. zcPanelControlType .. " (with position " .. zcPos .. ")" );
				break;
			}
		} else if ( zcPanelControlType == PCT_Info ) {
			if ( aliases.Size() == 0 ) {
				ZCGlobal.ClearscopeLog( LL_Main, DARKGRAY .. "No actors aliases created now" );
			} else {
				ZCGlobal.ClearscopeLog( LL_Main | LL_NoDot, TEXTCOLOR_SAPPHIRE .. "Actors aliases " .. GRAY .. "(total " .. aliases.Size() .. "): " );

				for ( int i = 0; i < aliases.Size(); i++ ) {
					if ( aliases[ i ].thing )
						ZCGlobal.ClearscopeLog( LL_Main, DARKGRAY .. "  \"" .. GRAY .. aliases[ i ].aliasname .. DARKGRAY .. "\" linked to the " .. GRAY .. aliases[ i ].thing.GetClassName() .. DARKGRAY .. " <" .. aliases[ i ].thing .. "> at pos " .. ZCGlobal.squeezeVector3( aliases[ i ].thing.pos ) );
					else
						ZCGlobal.ClearscopeLog( LL_Main, DARKGRAY .. "  \"" .. GRAY .. aliases[ i ].aliasname .. DARKGRAY .. "\" is unlinked" );
				}
			}
		} else {
			ZCGlobal.Log( LL_Emergency, "Unknown panel control type " .. zcPanelControlType .. " (with no defined position)." );
		}
	}
} // of class ZCInfoPanelControlCommand: ZCConsoleCommand {}



class ZCVariablesControlCommand: ZCConsoleCommand {
	const GRAY = TEXTCOLOR_GRAY;
	const DARKGRAY = TEXTCOLOR_DARKGRAY;

	enum EVarsControlTypes {
		VCT_Error = 0,
		VCT_Set,
		VCT_Delete,
		VCT_Info,
		VCT_InfoForStdoutFile,
		VCT_LoadFromFile
	};

	EVarsControlTypes zcSubcommand;

	override String GetCommand() {
		return "zc_variablescontrol";
	}

	override String GetHelpNameString() {
		return "zcvarsctl set|new <$varname> <string_value_or_placeholder>;zcvarsctl del[ete]|rm|rem[ove] <$varname>|all;zcvarsctl l[ist]|i[nfo] [stdout|porcelain];zcvarsctl loadfrom <included_filename>";
	}

	override String GetHelpDescString() {
		return "Perform control on internal ZChecker string variables; identifiers must be started with \"$\" or \"%\".\n  Possible placeholders for the <string value> (first symbol must be \"%%\" or \"$\"): \"$self\" (caller itself), \"$lt\"|\"$linetarget\" (caller's linetarget), \"$target\" (caller's target field), \"$master\" (its master), \"$tracer\" (its tracer).";
	}

	override bool HandleArguments() {
		int ccmdArgsSize = ccmd.args.Size();
		zcSubcommand = VCT_Error;

		if ( ccmdArgsSize == 3 && ( ccmd.args[ 0 ] ~== "set" || ccmd.args[ 0 ] ~== "new" ) ) {
			zcSubcommand = VCT_Set;
		} else if ( ccmdArgsSize > 0 && ccmdArgsSize < 3 ) {
			String argOperation = ccmd.args[ 0 ];
			argOperation.ToLower();

			if ( ccmdArgsSize > 1 && argOperation == "del" || argOperation == "delete" || argOperation == "rm" || argOperation == "rem" || argOperation == "remove" ) {
				zcSubcommand = VCT_Delete;

			} else if ( argOperation == "l" || argOperation == "list" || argOperation == "i" || argOperation == "info" ) {
				if ( ccmdArgsSize == 2 ) {
					argOperation = ccmd.args[ 1 ];
					argOperation.ToLower();

					if ( argOperation == "stdout" || argOperation == "porcelain" )
						zcSubcommand = VCT_InfoForStdoutFile;
				} else {
					zcSubcommand = VCT_Info;
				}

			} else if ( argOperation == "loadfrom" ) {
				zcSubcommand = VCT_LoadFromFile;
			}
		}

		return ( zcSubcommand != VCT_Error );
	}

	override void DoCommand( void ) {
		ZCGlobal global = ZCGlobal.Get();

		switch ( zcSubcommand ) {
			case VCT_Set:
				String internalVarName = ccmd.args[ 1 ];
				String newVarValue = ccmd.args[ 2 ];

				if ( SetInternalZCheckerString( internalVarName, newVarValue ) )
					ZCGlobal.Log( LL_Main, "Internal variable \"" .. TEXTCOLOR_LIGHTBLUE .. internalVarName.Left( 63 ) .. LLCOLOR_MAIN .. "\" is " .. TEXTCOLOR_GREEN .. "set" .. LLCOLOR_MAIN .. " to \"" .. GetInternalZCheckerString( internalVarName ) .. "\"." );
				break;
			case VCT_Delete:
				String arg1 = ccmd.args[ 1 ];

				if ( arg1 ~== "all" )
					global.ClearAllZCheckerStrings();
				else
					global.DeleteZCheckerString( arg1 );

				break;
			case VCT_Info:
				ZCGlobal.ClearscopeLog( LL_Main | LL_NoDot, TEXTCOLOR_SAPPHIRE .. "Internal variables " .. GRAY .. "(total " .. global.internalStrings.Size() .. "): " );

				for ( int i = 0; i < global.internalStrings.Size(); i++ ) {
					ZCInternalStringDictionaryCell curcell = global.internalStrings[ i ];
					ZCGlobal.ClearscopeLog( LL_Main, DARKGRAY .. "  \"" .. GRAY .. curcell.key .. DARKGRAY .. "\" == \"" .. GRAY .. curcell.value .. DARKGRAY .. "\"." );
				}
				break;
			case VCT_InfoForStdoutFile:
				String curtime = MSTime() .. "";

				// For compatibility. It is advisable to also use a "SystemTime.Format()".
				console.printf( "\n# Configuration file automatically generated by ZChecker v" .. ZCheckerVersion .. ".\n\n" );

				for ( int i = 0; i < global.internalStrings.Size(); i++ ) {
					ZCInternalStringDictionaryCell curnode = global.internalStrings[ i ];

					console.printf( curnode.key .. "=" .. curnode.value );
				}

				console.printf( "\n" );
				break;
			case VCT_LoadFromFile:
				ZCGlobal.Log( LL_Main, DARKGRAY .. "(Load from file command not released yet)." );
				break;
			default:
				ZCGlobal.Log( LL_Emergency, "Unknown control type " .. zcSubcommand .. "." );
				break;
		}
	}

} // of class ZCVariablesControlCommand: ZCConsoleCommand {}
