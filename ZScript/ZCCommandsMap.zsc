//
// Handling of the "zcev*" commands:
//

class ZCEvmapCommand: ZCConsoleCommand {
	protected void InitEvmapCCMD( String helpheader, String helpdesc, int extraflags = CCF_None, class<ZCTooltipClass> helptooltip = NULL ) {
		zcFlags = CCF_NonblockingFailure;
		if ( !!extraflags )
			zcFlags |= extraflags;

		SetupCCMDInterface( "zc_ev", helpheader, helpdesc, helptooltip );
	}

	override void InitCCMD() {
		InitEvmapCCMD(
			"zcev add|new|goto|pause|optimize|recreate|reload;zcev map[2]|level[2]",
			"Operates with world on the Everything map. Exceptions are \"map\"/\"level\" commands, which warps player to the \"map everything\" and \"map everything_simpled\".",
			CCF_Unreleased
		);
	}


	protected bool testForEverythingLevel( void ) {
		bool isEverythingLevel = ZCGlobal.IsEverythingLevel();

		if ( !isEverythingLevel )
			ZCGlobal.Log( LL_Main, "Cannot use command not on Everything map." );

		return isEverythingLevel;
	}

	protected bool testForShortArg( String strstart ) {
		return ( ccmd.args[ 0 ].Left( strstart.Length() ) == strstart );
	}

	protected int complexArgsTest( String strstart ) { // Just for convenience.
		int ccmdArgsSize = ccmd.args.Size();

		return ( ccmdArgsSize && testForShortArg( strstart )? ccmdArgsSize : 0 );
	}

	protected void SetNonblockingUsageMessage( void ) {
		ccmd.SetUsageMessageNonblockingCCMD( self );
	}
} // of class ZCEvmapCommand: ZCConsoleCommand {}



class ZCEvmapCommand_goto: ZCEvmapCommand {
	String zcDestinationWord; // Actor class, category or a "start" keyword.

	override bool HandleArguments() {
		bool outValue = false;
		int ccmdArgsSize = complexArgsTest( "g" );

		if ( ccmdArgsSize && testForEverythingLevel() ) {
			if ( ccmdArgsSize == 2 ) {
				zcDestinationWord = ParseSpecialActorName( ccmd.args[ 1 ] );
				outValue = true;
			} else {
				SetNonblockingUsageMessage();
			}
		}

		return outValue;
	}

	protected void gotoCCMDPlayerTeleport( vector3 newpos, double newangle ) {
		PlayerPawn player = players[ ccmd.e.Player ].mo;

		player.SetOrigin( newpos, false );
		player.SetZ( player.floorz );
		player.angle = newangle;
		player.vel.xy = (0.0, 0.0);
	}

	override void DoCommand( void ) {
		if ( classnameParseStatus == CPS_RegexFailed )
			return;

		if ( zcDestinationWord == "s" || zcDestinationWord == "start" ) {
			// From "TelOtherFX1::P_TeleportToPlayerStarts()":
			Vector3 dest;
			double destAngle;

			[ dest, destAngle ] = G_PickPlayerStart( 0, PPS_NOBLOCKINGCHECK );
			gotoCCMDPlayerTeleport( dest, destAngle );

		} else {
			ThinkerIterator it = ThinkerIterator.Create( "ZCheckerActorInfo" );
			ZCheckerActorInfo curActor;

			class<Actor> destActorClass = zcDestinationWord;

			if ( !destActorClass ) {
				ZCGlobal.Log( LL_Normal, "\"" .. zcDestinationWord .. "\" is not an Actor class." );
			} else {
				while ( ( curActor = ZCheckerActorInfo( it.Next( true ) ) ) && ( curActor.masterClass != destActorClass ) );

				if ( curActor ) {
					double newPlayerAngle = ( curActor.master? curActor.AngleTo( curActor.master, true ) : atan2( -curActor.masterOffset.y, -curActor.masterOffset.x ) );
					gotoCCMDPlayerTeleport( curActor.pos, newPlayerAngle );
					ZCGlobal.Log( LL_Detailed, "Found actor " .. curActor.masterClass.GetClassName() .. " at " .. curActor.pos .. "." );
				} else {
					ZCGlobal.Log( LL_Normal, "Actor \"" .. zcDestinationWord .. "\" does not exist on this map." );
				}
			}
		}
	} // of override void DoCommand( void ) {}

	override void InitCCMD() {
		InitEvmapCCMD(
			"zcev goto <class>|start;zcevg <class>|start",
			"On the Everything map, go to the specific actor definition/to start"
		);
	}
} // of class ZCEvmapCommand_goto: ZCEvmapCommand {}


class ZCEvmapCommand_add: ZCEvmapCommand {
	override void InitCCMD() {
		InitEvmapCCMD(
			"zcev add [<class=linetarget>] [<amount=1>] [safe];zcev new [<class=linetarget>] [<amount=1>] [safe]",
			"Summon <amount> actors of type <class/linetarget> on the Everything map arena. Keyword \"safe\" means summoning without collision.",
			CCF_Unreleased
		);
	}
} // of class ZCEvmapCommand_add: ZCEvmapCommand {}


class ZCEvmapCommand_recreate: ZCEvmapCommand_goto {
	override void InitCCMD() {
		InitEvmapCCMD(
			"zcev recreate|reload;zcevre",
			"Delete and recreate again all actors on the Everything map, like on start"
		);
	}

	override bool HandleArguments() {
		bool outValue = false;
		int ccmdArgsSize = complexArgsTest( "re" );

		if ( ccmdArgsSize && testForEverythingLevel() ) {
			if ( ccmdArgsSize == 1 )
				outValue = true;
			else
				SetNonblockingUsageMessage();
		}

		return outValue;
	}
	override void DoCommand( void ) {
		EventHandler.SendNetworkEvent( "zcheckermap_recreate" );
	}
} // of class ZCEvmapCommand_recreate: ZCEvmapCommand_goto {}


class ZCEvmapCommand_pause: ZCEvmapCommand {
	override void InitCCMD() {
		InitEvmapCCMD(
			"zcev pause;zcev optimize",
			"Unload all actors from the main location on the Everything map",
			CCF_Unreleased
		);
	}
} // of class ZCEvmapCommand_pause: ZCEvmapCommand {}

class ZCEvmapCommand_warptomap: ZCEvmapCommand {
	override void InitCCMD() {
		InitEvmapCCMD(
			"zcev map|launch;zcev map2|launch2",
			"Warp to map \"Everything\" when no digit provided or to map \"Everything_simpled\" in other case."
		);
	}

	override bool HandleArguments() {
		bool outValue = false;
		int ccmdArgsSize = complexArgsTest( "map" );

		if ( ccmdArgsSize == 0 )
			ccmdArgsSize = complexArgsTest( "level" );

		if ( ccmdArgsSize ) {
			if ( ccmdArgsSize == 1 )
				outValue = true;
			else
				SetNonblockingUsageMessage();
		}

		return outValue;
	}
	override void DoCommand( void ) {
		// [McM] Compatibility. Again.
		//LevelLocals.ChangeLevel( "Everything", 0, 0 );

		int isSimplified = !!( ccmd.args[ 0 ].IndexOf( "2" ) != -1 );

		ACS_ExecuteAlways( -int( 'ZChecker_WarpToEverything' ), 0, isSimplified );
		console.HideConsole();
	}
} // of class ZCEvmapCommand_warptomap: ZCEvmapCommand {}
