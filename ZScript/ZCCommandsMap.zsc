//
// Handling of the "zcev*" commands:
//

class ZCEvmapCommand: ZCConsoleCommand {
	protected void InitEvmapCCMD( String helpheader, String helpdesc, class<ZCTooltipClass> helptooltip = NULL ) {
		zcFlags = CCF_NonblockingFailure;
		SetupCCMDInterface( "zc_ev", helpheader, helpdesc, helptooltip );
	}

	override void InitCCMD() {
		InitEvmapCCMD(
			"$ZCEV_HELP_TITLE",
			"$ZCEV_HELP_DESC"
		);
	}


	protected bool testForEverythingLevel( void ) {
		bool isEverythingLevel = ZCGlobal.IsEverythingLevel();

		if ( !isEverythingLevel )
			ZCGlobal.Log( LL_Main, "$ZCEV_NOTEVMAP" );

		return isEverythingLevel;
	}

	protected bool testForShortArg( String strstart ) {
		return ( ccmd.args[ 0 ].Left( strstart.Length() ) == strstart );
	}

	protected int complexArgsTest( String strstart ) { // Just for convenience.
		int ccmdArgsSize = ccmd.args.Size();

		return ( ccmdArgsSize && testForShortArg( strstart )? ccmdArgsSize : 0 );
	}

	protected void SetNonblockingUsageMessage( void ) {
		ccmd.SetUsageMessageNonblockingCCMD( self );
	}
} // of class ZCEvmapCommand: ZCConsoleCommand {}



class ZCEvmapCommand_goto: ZCEvmapCommand {
	String zcDestinationWord; // Actor class, category or a "start" keyword.

	override void InitCCMD() {
		InitEvmapCCMD(
			"$ZCEVGOTO_HELP_TITLE",
			"$ZCEVGOTO_HELP_DESC"
		);
	}

	override bool HandleArguments() {
		bool outValue = false;
		int ccmdArgsSize = complexArgsTest( "g" );

		if ( ccmdArgsSize && testForEverythingLevel() ) {
			if ( ccmdArgsSize == 2 ) {
				zcDestinationWord = ParseSpecialActorName( ccmd.args[ 1 ] );
				outValue = true;
			} else {
				SetNonblockingUsageMessage();
			}
		}

		return outValue;
	}

	protected void gotoCCMDPlayerTeleport( vector3 newpos, double newangle ) {
		PlayerPawn pl = players[ ccmd.e.Player ].mo;

		pl.SetOrigin( newpos, false );
		pl.SetZ( pl.floorz );
		pl.angle = newangle;
		pl.vel.xy = (0.0, 0.0);
		pl.player.vel = (0.0, 0.0);
	}

	override void DoCommand( void ) {
		if ( classnameParseStatus == CPS_RegexFailed )
			return;

		if ( zcDestinationWord == "s" || zcDestinationWord == "start" ) {
			// From "TelOtherFX1::P_TeleportToPlayerStarts()":
			Vector3 dest;
			double destAngle;

			[ dest, destAngle ] = G_PickPlayerStart( 0, PPS_NOBLOCKINGCHECK );
			gotoCCMDPlayerTeleport( dest, destAngle );

		} else {
			ThinkerIterator it = ThinkerIterator.Create( "ZCheckerActorInfo" );
			ZCheckerActorInfo curActor;

			class<Actor> destActorClass = zcDestinationWord;

			if ( !destActorClass ) {
				LogLocalize2Str( LL_Normal, "ZCEVGOTO_NOTACTOR", zcDestinationWord );
			} else {
				while ( ( curActor = ZCheckerActorInfo( it.Next( true ) ) ) && ( curActor.masterClass != destActorClass ) );

				if ( curActor ) {
					double newPlayerAngle = ( curActor.master? curActor.AngleTo( curActor.master, true ) : atan2( -curActor.masterOffset.y, -curActor.masterOffset.x ) );
					gotoCCMDPlayerTeleport( curActor.pos, newPlayerAngle );
					ZCGlobal.Log( LL_Detailed, String.Format( ZCGlobal.Locz( "ZCEVGOTO_SUCCESS" ), curActor.masterClass.GetClassName(), "" .. curActor.pos ) );
				} else {
					// No this actor at the map.
					LogLocalize2Str( LL_Normal, "ZCEVGOTO_NOTFOUND", zcDestinationWord );
				}
			}
		}
	} // of override void DoCommand( void ) {}
} // of class ZCEvmapCommand_goto: ZCEvmapCommand {}

class ZCEvmapCommand_recreate: ZCEvmapCommand_goto {
	override void InitCCMD() {
		InitEvmapCCMD(
			"$ZCEVRE_HELP_TITLE",
			"$ZCEVRE_HELP_DESC"
		);
	}

	override bool HandleArguments() {
		bool outValue = false;
		int ccmdArgsSize = complexArgsTest( "re" );

		if ( ccmdArgsSize && testForEverythingLevel() ) {
			if ( ccmdArgsSize == 1 )
				outValue = true;
			else
				SetNonblockingUsageMessage();
		}

		return outValue;
	}
	override void DoCommand( void ) {
		EventHandler.SendNetworkEvent( "zc_evmap_recreate" );
	}
} // of class ZCEvmapCommand_recreate: ZCEvmapCommand_goto {}

class ZCEvmapCommand_warptomap: ZCEvmapCommand {
	override void InitCCMD() {
		InitEvmapCCMD(
			"$ZCEVMAPWARP_HELP_TITLE",
			"$ZCEVMAPWARP_HELP_DESC"
		);
	}

	override bool HandleArguments() {
		bool outValue = false;
		int ccmdArgsSize = complexArgsTest( "map" );

		if ( ccmdArgsSize == 0 )
			ccmdArgsSize = complexArgsTest( "lev" );

		if ( ccmdArgsSize ) {
			if ( ccmdArgsSize == 1 )
				outValue = true;
			else
				SetNonblockingUsageMessage();
		}

		return outValue;
	}
	override void DoCommand( void ) {
		// [McM] Compatibility. Again.
		//LevelLocals.ChangeLevel( "Everything", 0, 0 );

		int isSimplified = !!( ccmd.args[ 0 ].IndexOf( "2" ) != -1 );

		ACS_ExecuteAlways( -int( 'ZChecker_WarpToEverything' ), 0, isSimplified );
		console.HideConsole();
	}
} // of class ZCEvmapCommand_warptomap: ZCEvmapCommand {}
