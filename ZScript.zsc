version "3.3.0"

// For all code files:
//   Tab size          - 4 spaces.
//   Indentation style - in general a "one true brace".
//   Spaces style      - generous/rife.

// General, base, utility and miscellaneous code:
#include "ZScript/ZCUtils.zsc"
#include "ZScript/ZCDataStructures.zsc"
#include "ZScript/ZCBaseClasses.zsc"
#include "ZScript/ZCMenus.zsc"
#include "ZScript/ZCMapScripts.zsc"

// Console classes and CCMDs:
#include "ZScript/ZCCommandsGeneral.zsc"
#include "ZScript/ZCCommandsActorAlter.zsc"
#include "ZScript/ZCCommandsMap.zsc"
#include "ZScript/ZCCommandsMiscControl.zsc"
#include "ZScript/ZCTooltipClasses.zsc"

// Informational panels classes:
#include "ZScript/ZCInfoPanelMain.zsc"
#include "ZScript/ZCInfoPanelPointers.zsc"
#include "ZScript/ZCInfoPanelGeometry.zsc"
#include "ZScript/ZCInfoPanelOther.zsc"


const ZCheckerVersion = "0.74";


// AutoAmbient: 0x7FAA0004;
// Weathremum:  0x7FAA0007.
const ZCheckerHandlerOrder = -0x7FAA0005; // Proposed to call it before (almost) everything else.
const ZCheckerMapHandlerOrder = 0x7FAA0006;

const MaxTestee = 3; // Will rename someday...

const ZCHECKER_AGRS_SEPARATOR = "@@";



class ZCheckerHandler: StaticEventHandler {
	ZCGlobal globalclass;
	ZCPanelsStorage panels;
	ZCheckerHandlerDatascopeVariables datascoped;

	Array<ZCConsoleClass> zcConsoleHandleClasses;

	Array<ZCInternalActorNameCell> allActorNames;

	// In current structure it's impossible to avoid unloading pointers to 
	//actors from memory on level reloading. Found this too late for a 
	//simple fix.
	ZCheckerField Testee[ MaxTestee ];

	ZCheckerCCMDInfo zcCCMDInfo;

	bool handlerInitSuccess;
	String zcConfigFile;
	int zcConfigCurLineIndex;


	ZCConsoleClass GetZCConsoleClass( int index ) {
		ZCConsoleClass ccmd = NULL;

		if ( index >= 0 && index < zcConsoleHandleClasses.Size() ) {
			ccmd = zcConsoleHandleClasses[ index ];
			//ZCGlobal.Log( LL_Debug, GetClassName() .. "::GetZCConsoleClass(). CCMD #" .. index .. " is <" .. zcConsoleHandleClasses[ index ] .. ">." );
		}

		return ccmd;
	} // of ZCConsoleClass GetZCConsoleClass( int index ) {}

	/*ZCConsoleClass LocateZCConsoleClass( class<ZCConsoleClass> cls ) {
		ZCConsoleClass found = NULL;

		for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {
			if ( zcConsoleHandleClasses[ i ].GetClass() == cls ) {
				found = zcConsoleHandleClasses[ i ];
				break;
			}
		}

		return found;
	} // of ZCConsoleClass LocateZCConsoleClass( class<ZCConsoleClass> cls ) {}*/

	void UpdateInternalClassnameByField( uint fieldnum ) {
		if ( fieldnum < MaxTestee ) {
			String newClassname = "";

			if ( Testee[ fieldnum ].mo )
				newClassname = Testee[ fieldnum ].mo.GetClassName();

			globalclass.SetZCheckerString( "$" .. ( fieldnum + 1 ), newClassname );
		}
	}

	private bool addConsoleClass( class<ZCConsoleClass> classname, bool importantFlag = false ) {
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::addConsoleClass(). Trying to add \"" .. ( classname? classname.GetClassName() .. "" : "<NULL>" ) .. "\"." );

		if ( classname ) {
			ZCConsoleClass newCCMD = ZCConsoleClass.Create( classname, importantFlag );
			zcConsoleHandleClasses.Push( newCCMD );

			bool important = newCCMD.zcFlags & ZCConsoleClass.CCF_Important;
			newCCMD.OnLoad();
			newCCMD.zcFlags = ( newCCMD.zcFlags & ~newCCMD.CCF_Important ) | ( newCCMD.CCF_Important * !!important );
		}

		return !!classname;
	}
	private void addConsoleSeparator( bool importantFlag = false ) {
		zcConsoleHandleClasses.Push( ZCConsoleClass.Create( 'ZCConsoleSeparator', importantFlag ) );
	}

	private play bool addInfoPanelClass( class<ZCBaseInfoPanelPart> classname ) {
		if ( classname ) {
			ZCBaseInfoPanelPart newPanelPart = NULL;

			if ( classname is "ZCBaseInfoPanelPart_PlayScope" ) {
				ZCGlobal.Log( LL_Debug, GetClassName() .. "::addInfoPanelClass(). Trying to add a " .. TEXTCOLOR_DARKGREEN .. "play-scoped " .. LLCOLOR_DEBUG .. "\"" .. classname.GetClassName() .. "\"." );
				newPanelPart = ZCBaseInfoPanelPart_PlayScope.CreatePlayScope( classname, self );
			} else {
				ZCGlobal.Log( LL_Debug, GetClassName() .. "::addInfoPanelClass(). Trying to add \"" .. classname.GetClassName() .. "\"." );
				newPanelPart = ZCBaseInfoPanelPart.Create( classname, self );
			}

			panels.defaultPanels.Push( newPanelPart );
		} else {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::addInfoPanelClass(). No class<ZCBaseInfoPanelPart> defined." );
		}

		return !!classname;
	}


	private void handleConfigFileNewlines( String newlineTypeComment, String replaceeNewlineSeq ) {
		ZCGlobal.Log( LL_Debug, "New lines type for file \"ZChecker.cfg\" recognized as " .. newlineTypeComment );

		if ( replaceeNewlineSeq != "\n" )
			zcConfigFile.Replace( replaceeNewlineSeq, "\n" );
	}

	private bool checkKeywordArgsAmount( uint argsAmount, String keyword, uint rightAmount, String argsDescription ) {
		if ( argsAmount != rightAmount ) {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::checkKeywordArgsAmount(). Wrong arguments for keyword \"" .. keyword .. "\" at line " .. zcConfigCurLineIndex .. ": has " .. argsAmount .. ", must be " .. rightAmount .. " (" .. TEXTCOLOR_RED .. "\"" .. argsDescription .. "\"" .. LLCOLOR_EMERGENCY .. ")." );
			handlerInitSuccess = false;
			return false;
		}

		return true;
	}

	private void printConfigWarning( String message ) {
		ZCGlobal.Log( LL_Emergency, GetClassName() .. "::IncludeConsoleClasses(). " .. message .. " at line " .. zcConfigCurLineIndex .. "." );
		handlerInitSuccess = false;
	}

	protected void ParseConfigFile( void ) {
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::IncludeConsoleClasses(). Parsing a *.cfg file; creating CCMD handlers and info panel classes..." );

        int zcConfigFileHandler = Wads.FindLump( "zchecker.cfg" );

        if ( zcConfigFileHandler != -1 ) {
            zcConfigFile = Wads.ReadLump( zcConfigFileHandler );
            Array<String> zcConfigLines;

            zcConfigFile.ToLower();
			ENewlineTypes newlinesType = ZCGlobal.GetTextNewlinesType( zcConfigFile );

			switch ( newlinesType ) {
				case ZCNL_Unix: handleConfigFileNewlines( "*nix (LF)", "\n" ); break;
				case ZCNL_DOS: handleConfigFileNewlines( "DOS/Windows (CR/LF)", "\r\n" ); break;
				case ZCNL_Mac: handleConfigFileNewlines( "MacOS (CR)", "\r" ); break;
				case ZCNL_DOSReversed: handleConfigFileNewlines( "DOS reversed (LF/CR)", "\n\r" ); break;
				default:
					ZCGlobal.Log( LL_Debug, TEXTCOLOR_YELLOW .. "Cannot recognize new lines type, using *nix" .. LLCOLOR_DEBUG .. "." );
					newlinesType = ZCNL_Unix;
					break;
			}

			zcConfigFile.Split( zcConfigLines, "\n" );


			int zcConfigLinesSize = zcConfigLines.Size();

			// Fixing a non-POSIX end-of-file marker:
			if ( zcConfigLinesSize ) {
				String lastline = zcConfigLines[ zcConfigLinesSize - 1 ];

				if ( lastline.CharCodeAt( lastline.Length() - 1 ) == 0 )
					zcConfigLines[ zcConfigLinesSize - 1 ] = lastline.Left( lastline.Length() - 1 );
			}

			zcConfigCurLineIndex = 1;

			for ( int i = 0; i < zcConfigLinesSize; i++, zcConfigCurLineIndex++ ) {
				String curLine = zcConfigLines[ i ];

				// Comments and extra spaces delete:
				int IndexOfCommentStart = curLine.IndexOf( "#" );
				if ( IndexOfCommentStart != -1 )
					curLine.Truncate( IndexOfCommentStart );

				curLine = ZCGlobal.TruncateStringBySpaces( curLine );

				// Try to unparse current line if it isn't empty or remove it elsewere:
				if ( curLine != "" ) {
					Array<String> curLineWords;

					curLineWords.Clear();
					curLine.Replace( "\t", " " );
					curLine.Split( curLineWords, " ", TOK_SKIPEMPTY );

					int argsamount = ( curLineWords.Size() - 1 );

					if ( curLineWords[ 0 ] == "ccmd" || curLineWords[ 0 ] == "addccmd" || curLineWords[ 0 ] == "plaintext" || curLineWords[ 0 ] == "addtext" || curLineWords[ 0 ] == "addplaintext" ) {
						if ( argsamount == 1 ) {
							if ( !addConsoleClass( curLineWords[ 1 ], false ) )
								printConfigWarning( "Wrong ZCConsoleClass class \"" .. curLineWords[ 1 ] .. "\"" );
						} else if ( argsamount == 2 && curLineWords[ 2 ] == "important" ) {
							if ( !addConsoleClass( curLineWords[ 1 ], true ) )
								printConfigWarning( "Wrong ZCConsoleClass class \"" .. curLineWords[ 1 ] .. "\"" );
						} else {
							checkKeywordArgsAmount( argsamount, curLineWords[ 0 ], 1, "class<ZCConsoleClass> [important]" );
						}

					} else if ( curLineWords[ 0 ] == "ccmdsep" || curLineWords[ 0 ] == "addccmdsep" || curLineWords[ 0 ] == "ccmdseparator" || curLineWords[ 0 ] == "addccmdseparator" ) {
						addConsoleSeparator( argsamount == 1 && curLineWords[ 1 ] == "important" );

					} else if ( curLineWords[ 0 ] == "panel" || curLineWords[ 0 ] == "addpanel" || curLineWords[ 0 ] == "infopanel" || curLineWords[ 0 ] == "addinfopanel" ) {
						if ( checkKeywordArgsAmount( argsamount, curLineWords[ 0 ], 1, "class<ZCBaseInfoPanelPart>" ) )
							if ( !addInfoPanelClass( curLineWords[ 1 ] ) )
								printConfigWarning( "Wrong PanelInfo class \"" .. curLineWords[ 1 ] .. "\"" );

					} else {
						printConfigWarning( "Unknown keyword \"" .. curLineWords[ 0 ] .. "\"" );
					}

				} else {
					zcConfigLines.Delete( i, 1 );
					zcConfigLinesSize--;
					i--;
				} // of else of if ( curLine != "" ) {}

			} // of for ( int i = 0; i < zcConfigLines.Size(); i++, zcConfigCurLineIndex++ ) {}
		} else {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::IncludeConsoleClasses(). Cannot find file \"ZChecker.cfg\"." );
			handlerInitSuccess = false;
		} // of else of if ( zcConfigFileHandler != -1 ) {}

	} // of protected void ParseConfigFile( void ) {}

	protected void InitAllActorNames( void ) {
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::InitAllActorNames(). Creating storage cells for actor names..." );

		for ( int i = 0; i < ZCInternalActorNameCell.ARRAY_Quantity; i++ )
			allActorNames.Push( ZCInternalActorNameCell.Create( i ) );

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::InitAllActorNames(). Saving actor names by first char..." );

		for ( int i = 0; i < AllActorClasses.Size(); i++ ) {
			String curclass = AllActorClasses[ i ].GetClassName();
			int index = ZCInternalActorNameCell.GetClassnameCellIndex( curclass );

			allActorNames[ index ].orignames.Push( curclass );
			curclass.ToLower();
			allActorNames[ index ].names.Push( curclass ); // To speed up a comparing process.
		}

		if ( ZCGlobal.Get().zcCurLogLevel >= LL_Debug ) {
			for ( int i = 0; i< ZCInternalActorNameCell.ARRAY_Quantity; i++ ) {
				ZCInternalActorNameCell nameCell = allActorNames[ i ];
				int nameCellSize = nameCell.names.Size();

				ZCGlobal.ClearscopeLog( LL_Debug, GetClassName() .. "::InitAllActorNames(). " .. String.Format(
										"allActorNames[%2i] quantity: %3i." .. ( nameCellSize > 0? " First is \"" .. nameCell.names[ 0 ] .. "\"." : "" ), i, nameCellSize ) );
			}
		} // of if ( ZCGlobal.Get().zcCurLogLevel >= LL_Debug ) {}
	} // of protected void InitAllActorNames( void ) {}



	override void OnRegister() {
		handlerInitSuccess = true;
		SetOrder( ZCheckerHandlerOrder );

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::OnRegister(). ZChecker v" .. ZCheckerVersion .. " initializes..." );

		panels = ZCPanelsStorage.Create();

		for ( int i = 0; i < MaxTestee; i++ )
			Testee[ i ] = ZCheckerField.Create( i );

		zcCCMDInfo = new( 'ZCheckerCCMDInfo' );
		zcCCMDInfo.handler = self;

		ParseConfigFile();
		InitAllActorNames();

		ZCGlobal.Log( LL_Detailed, String.Format( "ZChecker v%s initialized %s. Total %i console commands, %i info panels.",
									ZCheckerVersion, ( handlerInitSuccess? "successfully" : TEXTCOLOR_RED .. "with warnings" .. LLCOLOR_MAIN ),
									zcConsoleHandleClasses.Size(), panels.defaultPanels.Size() ) );

		Super.OnRegister();
	}

	// Method to update all of the field meta-information:
	private clearscope Actor UpdateTesteeField( int fieldindex ) {
		Actor curTestee = NULL;

		if ( Testee[ fieldindex ] && Testee[ fieldindex ].mo )
			curTestee = Testee[ fieldindex ].mo;

		// Updating info actors type. Usually it's better not to cross the 
		//ui, data and play scopes in one method...
		if ( curTestee is "StateProvider" && PlayerPawn( Inventory( curTestee ).owner ) ) {
			Testee[ fieldindex ].mo = curTestee = PlayerPawn( Inventory( curTestee ).owner ).player.ReadyWeapon;
			Testee[ fieldindex ].actorType = IAT_StateProvider;
		} else {
			Testee[ fieldindex ].actorType = IAT_Normal;
		}

		return curTestee;
	}




	override void RenderOverlay( RenderEvent e ) {
		// Pointers to the all of the used CVars are pre-cached in this method.

		Array<ZCBaseInfoPanelPart> infoPanelParts;
		PlayerInfo pl = players[ consoleplayer ];

		panels.UpdateFont();

		for ( int iCurInfoPanel = 0; iCurInfoPanel < panels.curPanels.Size(); iCurInfoPanel++ ) {
			ZCInfoPanelNode panelnode = panels.curPanels.nodes[ iCurInfoPanel ];

			if ( panelnode.panelCVar && panelnode.panelCVar.GetBool() )
				infoPanelParts.Push( panelnode.panel );
		}

		if ( !datascoped.infopanelStartXCVar ) {
			PlayerInfo pl = players[ consoleplayer ];

			datascoped.infopanelStartXCVar = CVar.GetCVar( "mcm_zchecker_infopanel_startx", pl );
			datascoped.infopanelStartYCVar = CVar.GetCVar( "mcm_zchecker_infopanel_starty", pl );
			datascoped.infopanelScaleCVar = CVar.GetCVar( "mcm_zchecker_infopanel_scale", pl );
			datascoped.infopanelOffsetXCVar = CVar.GetCVar( "mcm_zchecker_infopanel_offsetx", pl );
			datascoped.infopanelPartsSpaceYCVar = CVar.GetCVar( "mcm_zchecker_infopanelparts_y_gap", pl );

			datascoped.infopanelDimEnabledCVar = CVar.GetCVar( "mcm_zchecker_infopanel_dimenabled", pl );
			datascoped.infopanelDimColorCVar = CVar.GetCVar( "mcm_zchecker_infopanel_dimcolor", pl );
			datascoped.infopanelDimAlphaCVar = CVar.GetCVar( "mcm_zchecker_infopanel_dimalpha", pl );
			datascoped.infopanelDimBorderWidthCVar = CVar.GetCVar( "mcm_zchecker_infopanel_dimborderwidth", pl );
		}

		double infopanelStartX = datascoped.infopanelStartXCVar.GetFloat();
		double infopanelStartY = datascoped.infopanelStartYCVar.GetFloat();
		double infopanelScale = datascoped.infopanelScaleCVar.GetFloat();
		double infopanelOffsetX = datascoped.infopanelOffsetXCVar.GetFloat();
		double infopanelPartsSpaceY = datascoped.infopanelPartsSpaceYCVar.GetFloat();

		// Thanks to m8f for the "drawTextCenter()" function code from his "Hellscape Navigator".
		double bordersXMargin = 4.0;
		double scale = 1.0 / infopanelScale;

		int height = int( scale * Screen.GetHeight() );
		int width = int( scale * Screen.GetWidth() );

		int fontSymbolHeight = panels.infopanelsFont.GetHeight() + 1;

		for ( int i = 0; i < MaxTestee; i++ ) {
			Actor curTestee = UpdateTesteeField( i );

			if ( !curTestee )
				continue;

			double starty = infopanelStartY * 0.01 * height;
			double y = starty;
			double x = infopanelStartX * 0.01 + i * infopanelOffsetX * 0.01;
			x *= width;

			double maxStringWidth = 0.0;


			// Forming a full informational panel:
			Array<String> panelsstr;
			Array<double> panelsheights;
			panelsstr.Clear();
			panelsheights.Clear();

			for ( int j = 0; j < infoPanelParts.Size(); j++ ) {
				String outStr;

				if ( infoPanelParts[ j ].IsPlayScope() )
					outStr = ZCBaseInfoPanelPart_PlayScope( infoPanelParts[ j ] ).InternalGetInfo_clearscope( i );
				else
					outStr = infoPanelParts[ j ].GetInfo( curTestee, Testee[ i ] );

				if ( outStr == "" )
					continue;


				panelsstr.Push( "\c-" .. outStr .. "\n" );

				double stringWidth = panels.infopanelsFont.StringWidth( outStr );

				// Push the text out from the borders:
				if ( x < bordersXMargin )
					x = bordersXMargin;
				else if ( x > width - stringWidth - bordersXMargin )
					x = width - stringWidth - bordersXMargin;

				if ( maxStringWidth < stringWidth )
					maxStringWidth = stringWidth;
			}

			// Printing infopanels parts:
			int panelsstrAmount = panelsstr.Size();
			double endy = y;

			for ( int j = 0; j < panelsstrAmount; j++ ) {
				// Adding an Y-offset for the next panel part:
				int newlinesAmount = 0;
				int nextNewlinePos = -1;

				while ( -1 != ( nextNewlinePos = panelsstr[ j ].IndexOf( "\n", nextNewlinePos + 1 ) ) )
					newlinesAmount++;

				double panelheight = fontSymbolHeight * ( newlinesAmount + infopanelPartsSpaceY );
				panelsheights.Push( panelheight );
				endy += panelheight;
			}

			// Dimming background:
			bool infopanelDimEnabled = datascoped.infopanelDimEnabledCVar.GetBool();

			if ( infopanelDimEnabled && panelsstrAmount ) {
				Color dimColor = Color( datascoped.infopanelDimColorCVar.GetInt() );
				double dimAlpha = datascoped.infopanelDimAlphaCVar.GetFloat();
				double dimBorderWitdh = datascoped.infopanelDimBorderWidthCVar.GetFloat() * fontSymbolHeight;

				int dimX = int( ( x - dimBorderWitdh ) / scale );
				int dimY = int( ( starty - dimBorderWitdh ) / scale );
				int dimWidth = int( ( maxStringWidth + dimBorderWitdh * 2 ) / scale );
				int dimHeight = int( ( endy - starty - fontSymbolHeight * infopanelPartsSpaceY + dimBorderWitdh * 2 ) / scale );

				Screen.Dim( dimColor, dimAlpha, dimX, dimY, dimWidth, dimHeight );
			}

			// Printing out infopanel parts:
			for ( int j = 0; j < panelsstrAmount; j++ ) {
				Screen.DrawText( panels.infopanelsFont, Font.CR_GRAY, x, y, panelsstr[ j ],
								DTA_KeepRatio, true, DTA_VirtualWidth, width, DTA_VirtualHeight, height );

				y += panelsheights[ j ];
			}
		} // of for ( int i = 0; i < MaxTestee; i++ ) {}

		Super.RenderOverlay( e );
	} // of override void RenderOverlay( RenderEvent e ) {}


	private String neteventArgColored( int value ) {
		return ( value == 0? TEXTCOLOR_DARKBROWN : TEXTCOLOR_CREAM ) .. value;
	}

	override void NetworkProcess( ConsoleEvent e ) {
		bool isDebugLoggingLevel = ( ZCGlobal.Get().zcCurLogLevel >= LL_Debug );

		// ZChecker CCMDs parsing:
		String ccmdName = zcCCMDInfo.InitFromEvent( e );

		if ( ccmdName ~== "zc_update_panels_order" ) {
			if ( zcCCMDInfo.args.Size() == 1 ) {
				panels.panelsstr = zcCCMDInfo.args[ 0 ];
				panels.UpdatePanels();
				panels.InitSetPanelsorderCVars( zcCCMDInfo.args[ 0 ] );
			} else {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::NetworkProcess(). Updating panels order netevent has wrong amount of arguments (must be 1, got " .. zcCCMDInfo.args.Size() .. ")." );
				ZCGlobal.Log( LL_Main, GetClassName() .. "::NetworkProcess(). Name: \"" .. TEXTCOLOR_TAN .. e.Name .. "\c-\"." );
			}

			Super.NetworkProcess( e );
			return;
		} // of if ( ccmdName ~== "zc_update_panels_order" ) {}

		if ( multiplayer && ccmdName ~== "zc_multiplayer_synctest" ) {
			if ( e.args[ 1 ] != consoleplayer ) {
				if ( zcCCMDInfo.args.Size() == 1 ) {
					uint testeePos = uint( e.args[ 0 ] );
					uint srcPlayer = uint( e.args[ 1 ] );

					bool argerror = false;

					if ( testeePos >= MaxTestee ) {
						argerror = true;
						ZCGlobal.Log( LL_Emergency, GetClassName() .. "::NetworkProcess(). Multiplayer sync netevent: wrong position " .. testeePos .. " to compare." );
					}

					if ( srcPlayer >= MAXPLAYERS ) {
						argerror = true;
						ZCGlobal.Log( LL_Emergency, GetClassName() .. "::NetworkProcess(). Multiplayer sync netevent: wrong source player #" .. srcPlayer .. "." );
					}

					if ( !argerror )
						Testee[ testeePos ].asyncwith = ( ( Testee[ testeePos ].hashsync[ srcPlayer ] == zcCCMDInfo.args[ 0 ] )? 0 : srcPlayer + 1 );

				} else {
					ZCGlobal.Log( LL_Emergency, GetClassName() .. "::NetworkProcess(). Multiplayer sync netevent has wrong amount of arguments (must be 1, got " .. zcCCMDInfo.args.Size() .. ")." );
					ZCGlobal.Log( LL_Main, GetClassName() .. "::NetworkProcess(). Name: \"" .. TEXTCOLOR_TAN .. e.Name .. "\c-\"." );
				}
			}

			Super.NetworkProcess( e );
			return;
		} // of if ( multiplayer && ccmdName ~== "zc_multiplayer_synctest" ) {}

		// Just a debug NetworkProcess() output:
		if ( isDebugLoggingLevel ) {
			String debugstr = GetClassName() .. "::NetworkProcess(). CCMD: \"" .. ccmdName .. "\"";

			if ( zcCCMDInfo.args.Size() != 0 ) {
				for ( int i = 0; i < zcCCMDInfo.args.Size(); i++ )
					debugstr.AppendFormat( " [" .. TEXTCOLOR_DARKGREEN .. "#%i: \"%s\"" .. LLCOLOR_DEBUG .. "]", i + 1, zcCCMDInfo.args[ i ] );
			} else {
				debugstr = debugstr .. ", no arguments.";
			}

			ZCGlobal.ClearscopeLog( LL_Debug, debugstr );
		}

		int interceptNeteventsMode = clamp( CVar.GetCVar( "mcm_zchecker_specinfo_netevents", players[ e.Player ] ).GetInt(), 0, 3 );
		int nonblockingCommandsAmount = 0;

		// Polling ZChecker CCMD handlers by stored netevent name:
		for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {
			if ( !( zcConsoleHandleClasses[ i ] is 'ZCConsoleCommand' ) )
				continue; // Skipping tooltips and other plaintext classes.

			ZCConsoleCommand curCCMD = ZCConsoleCommand( zcConsoleHandleClasses[ i ] );

			if ( ccmdName ~== curCCMD.ccmdInterfaceData.neteventName ) {
				curCCMD.ccmd = zcCCMDInfo;

				if ( nonblockingCommandsAmount == 0 )
					ZCGlobal.Log( LL_Debug, GetClassName() .. "::NetworkProcess(). Maximal amount of arguments (excluding name): " .. zcCCMDInfo.argsamount );

				if ( curCCMD.zcFlags & ( curCCMD.CCF_NonblockingSuccess | curCCMD.CCF_NonblockingFailure ) ) {
					if ( nonblockingCommandsAmount == 0 )
						ZCGlobal.Log( LL_Debug, GetClassName() .. "::NetworkProcess(). " .. TEXTCOLOR_OLIVE .. "Requested a non-blocking execution" .. LLCOLOR_DEBUG .. "." );

					zcCCMDInfo.nonblockingCommands.Push( curCCMD );
					nonblockingCommandsAmount++;
				} else {
					if ( curCCMD.HandleArguments() )
						curCCMD.DoCommand();
					else
						ZCGlobal.Log( LL_Normal | LL_NoPrefix, TEXTCOLOR_YELLOW .. "Usage" .. LLCOLOR_MAIN .. ":\n" .. curCCMD.GetHelpString() );

					interceptNeteventsMode = 0;
					break;
				}
			}
		} // of for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {}

		if ( nonblockingCommandsAmount != zcCCMDInfo.nonblockingCommands.Size() && isDebugLoggingLevel )
			ZCGlobal.Log( LL_Debug, GetClassName() .. "::NetworkProcess(). " .. TEXTCOLOR_BRICK .. "Non-blocking commands array size changed" .. LLCOLOR_DEBUG .. ": was " .. nonblockingCommandsAmount .. ", new " .. zcCCMDInfo.nonblockingCommands.Size() );

		nonblockingCommandsAmount = zcCCMDInfo.nonblockingCommands.Size();

		if ( nonblockingCommandsAmount != 0 ) {
			if ( isDebugLoggingLevel ) {
				String debugstr = GetClassName() .. "::NetworkProcess(). Non-blocking handling of ";

				for ( int i = 0; i < nonblockingCommandsAmount; i++ )
					debugstr.AppendFormat( "\"" .. TEXTCOLOR_BLUE .. zcCCMDInfo.nonblockingCommands[ i ].GetClassName() .. LLCOLOR_DEBUG .. "\"; " );

				ZCGlobal.ClearscopeLog( LL_Debug, debugstr .. "with total amount of " .. nonblockingCommandsAmount .. " commands." );
			} // of if ( isDebugLoggingLevel ) {}

			bool printUsage = true;
			int curCCMDIndex = 0;

			zcCCMDInfo.SetUsageMessageNonblockingCCMD( zcCCMDInfo.nonblockingCommands[ 0 ] );

			for ( ; curCCMDIndex < nonblockingCommandsAmount; curCCMDIndex++ ) {
				ZCConsoleCommand curCCMD = zcCCMDInfo.nonblockingCommands[ curCCMDIndex ];

				if ( curCCMD.HandleArguments() ) {
					curCCMD.DoCommand();
					printUsage = false;

					if ( !( curCCMD.zcFlags & curCCMD.CCF_NonblockingSuccess ) )
						break;
				} else {
					if ( !( curCCMD.zcFlags & curCCMD.CCF_NonblockingFailure ) )
						break;
				}
			}

			if ( printUsage && zcCCMDInfo.usageNonblockingCommand )
				ZCGlobal.Log( LL_Normal | LL_NoPrefix, TEXTCOLOR_YELLOW .. "Usage" .. LLCOLOR_MAIN .. ":\n" .. zcCCMDInfo.usageNonblockingCommand.GetHelpString() );

			interceptNeteventsMode = 0;
			zcCCMDInfo.nonblockingCommands.Clear();
		} // of if ( nonblockingCommandsAmount != 0 ) {}

		if ( e.name == "zcheckermap_recreate" || e.name == "zcheckermap_pause_level_part" )
			interceptNeteventsMode = 0;

		if ( interceptNeteventsMode ) {
			String outStr = "";

			if ( interceptNeteventsMode == 3 )
				outStr = TEXTCOLOR_GRAY .. ( e.IsManual? "Manual" : "System" ) .. TEXTCOLOR_DARKGRAY .. " netevent ";
			else
				outStr = TEXTCOLOR_DARKGRAY .. "Netevent ";

			// Compatibility between all *ZDoom versions:
			int compatTicRate = max( Thinker.Tics2Seconds( 350000 ), 1 );
			compatTicRate = int( 350000 / compatTicRate );

			if ( interceptNeteventsMode >= 2 )
				outStr.AppendFormat( "at %s.%02i ", level.TimeFormatted(), int( floor( ( level.time % compatTicRate ) / double( compatTicRate ) * 100.0 ) ) );

			String ARGSSEP = TEXTCOLOR_DARKGRAY .. "/" .. TEXTCOLOR_CREAM;

			outStr.AppendFormat( "\"" .. TEXTCOLOR_LIGHTBLUE .. e.Name .. " " .. TEXTCOLOR_CREAM .. "%s%s%s%s%s" .. TEXTCOLOR_DARKGRAY .. "\"",
								neteventArgColored( e.args[ 0 ] ), ARGSSEP, neteventArgColored( e.args[ 1 ] ), ARGSSEP, neteventArgColored( e.args[ 2 ] ) );

			if ( interceptNeteventsMode == 3 )
				outStr = outStr .. " from player #" .. TEXTCOLOR_WHITE .. e.Player;

			ZCGlobal.Log( LL_Normal, outStr );
		} // of if ( interceptNeteventsMode ) {}


		Super.NetworkProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {}


	override void WorldTick() {
		if ( ( gamestate == GS_LEVEL || gamestate == GS_DEMOSCREEN ) && !( level.maptime % 5 ) )
			globalclass.UpdateLogLevel();

		// ACS works only in the play scope.
		panels.TickSetPanelsorderCVars();

		for ( int i = 0; i < panels.curPanels.PlayscopedSize(); i++ ) {
			ZCBaseInfoPanelPart_PlayScope playpanel = ZCBaseInfoPanelPart_PlayScope( panels.curPanels.playnodes[ i ].panel );

			for ( int j = 0; j < MaxTestee; j++ ) {
				Actor curTestee = UpdateTesteeField( j );

				if ( curTestee )
					playpanel.playscopedInfo[ j ] = playpanel.GetInfo_play( curTestee, Testee[ j ] );
			}
		}

		Super.WorldTick();

		// Test for asynchronous actors:
		int playernum = ( level.maptime % MAXPLAYERS );

		if ( multiplayer && playeringame[ playernum ] ) {
			if ( playernum == consoleplayer ) {
				for ( int i = 0; i < MaxTestee; i++ ) {
					// Warning! Hash may generate a format specifier ("%s" etc). Do not use any "printf()" output!
					String hash = Testee[ i ].GetHash();
					EventHandler.SendNetworkEvent( "zc_multiplayer_synctest" .. ZCHECKER_AGRS_SEPARATOR .. hash, i, consoleplayer );
				}
			} else {
				for ( int i = 0; i < MaxTestee; i++ )
					Testee[ i ].UpdateHash( playernum );
			}

			//for ( int i = 0; i < MaxTestee; i++ )
			//	console.printf( GetClassName() .. "::WorldTick(). ZCheckerField[ " .. i .. " ]: \"" .. Testee[ i ].GetHash() .. "\"" );
		}
	} // of override void WorldTick() {}

	override void WorldLoaded( WorldEvent e ) {
		globalclass = ZCGlobal.Get();
		globalclass.InitZCheckerHandler( self );

		globalclass.SetZCheckerString( "$1", "" );
		globalclass.SetZCheckerString( "$2", "" );
		globalclass.SetZCheckerString( "$3", "" );
		globalclass.SetZCheckerString( "$last", "" );

		if ( panels.panelsorderChanged )
			panels.UpdatePanels( true );

		Super.WorldLoaded( e );
	}

} // of class ZCheckerHandler: StaticEventHandler {}

