version "3.3.0"

#include "ZScript/ZCMapScripts.zsc"
#include "ZScript/ZCBaseClasses.zsc"
#include "ZScript/ZCMenus.zsc"

#include "ZScript/ZCCommandsGeneral.zsc"
#include "ZScript/ZCCommandsActorAlter.zsc"
#include "ZScript/ZCCommandsInfo.zsc"
#include "ZScript/ZCCommandsMap.zsc"

#include "ZScript/ZCInfoPanelMain.zsc"
#include "ZScript/ZCInfoPanelPointers.zsc"
#include "ZScript/ZCInfoPanelOther.zsc"


const MaxTestee = 3;
const ZCheckerVersion = "0.69";

// AutoAmbient: 0x7FAA0004.
const ZCheckerHandlerOrder = 0x7FAA0005;
const ZCheckerMapHandlerOrder = 0x7FAA0006;



enum EZCheckerLogLevels {
	LL_Emergency = 0,
	LL_General = 1,
	LL_Detailed,
	LL_Debug,

	LL_Common = LL_General,
	LL_Normal = LL_General,
	LL_Main = LL_General,
	LL_Extended = LL_Detailed,
	LL_Critical = LL_Emergency,

	LL_FlagsMask	= 0xFFF0,
	LL_NoDot		= 0x4000,
	LL_NoPrefix		= 0x8000
};

const LLCOLOR_MAIN = "\c-";
const LLCOLOR_DEBUG = TEXTCOLOR_DARKGRAY;
const LLCOLOR_EMERGENCY = TEXTCOLOR_FIRE;


enum EZCheckerInfoActorType {
	IAT_Normal = 0,
	IAT_StateProvider
};

enum ENewlineTypes {
	ZCNL_Unknown = 0,
	ZCNL_DOS,			// 0x0D, 0x0A
	ZCNL_Unix,			// 0x0A
	ZCNL_Mac,			// 0x0D
	ZCNL_DOSReversed	// 0x0A, 0x0D
};

const CCMDCOLOR_TITLE = TEXTCOLOR_GREEN;
const CCMDCOLOR_TITLEWIP = TEXTCOLOR_DARKGRAY;
const CCMDCOLOR_DESC = "\c-";

const LETTER_A_UPPER = 65;
const LETTER_Z_UPPER = 90;
const LETTER_A_LOWER = 97;
const LETTER_Z_LOWER = 122;


class ZCInternalStringDictionaryCell {
	String cell;
	String value;
}

class ZCInternalActorNameCell {
	const ARRAY_Quantity = 28;

	int firstchar; // "0" is '_', "1" is 'a', "26" is 'z', "27" is other char (if any...).
	Array<String> names;		// Lowercased;
	Array<String> orignames; 	// Original.

	static ZCInternalActorNameCell Create( int initFirstchar ) {
		ZCInternalActorNameCell newcell = new( 'ZCInternalActorNameCell' );
		newcell.firstchar = initFirstchar;

		return newcell;
	}

	// First character. "0" is '_', "1" is 'a', "26" is 'z' and "27" is other char (if any).
	static clearscope int GetClassnameCellIndex( String clsname ) {
		int outIndex = 27;

		if ( clsname != "" ) {
			int firstchar = clsname.CharCodeAt( 0 );

			// Converting to uppercase:
			if ( firstchar >= LETTER_A_LOWER && firstchar <= LETTER_Z_LOWER )
				firstchar &= ~0x20; //LETTER_A_LOWER + LETTER_A_UPPER;

			if ( firstchar == 0x5F )
				outIndex = 0; // '_'.
			else if ( firstchar >= LETTER_A_UPPER && firstchar <= LETTER_Z_UPPER )
				outIndex = firstchar - LETTER_A_UPPER + 1; // 'A'..'Z'.
		}

		return outIndex;
	}
} // of class ZCInternalActorNameCell {}

class ZCGlobal: Thinker {
	ZCheckerHandler zcHandler;
	int zcCurLogLevel;

	Array<ZCInternalStringDictionaryCell> internalStrings;

	/* === ZChecker utils === */

	void UpdateLogLevel( void ) {
		zcCurLogLevel = CVar.FindCVar( "mcm_zchecker_loglevel" ).GetInt();
	}

	static play ZCGlobal Get( void ) {
		ZCGlobal it = ZCGlobal( ThinkerIterator.Create( "ZCGlobal", STAT_STATIC ).Next() );

		if ( !it ) {
			// Creating and initializating a singleton global object:
			it = new( "ZCGlobal" );
			it.ChangeStatNum( STAT_STATIC );
			it.UpdateLogLevel();
			it.internalStrings.Clear();
		}

		return it;
	} // of static play ZCGlobal Get( void ) {}

	void InitZCheckerHandler( ZCheckerHandler inithandler ) {
		zcHandler = inithandler;
	} // of void InitZCheckerHandler( ZCheckerHandler inithandler ) {}

	/*static play ZCheckerHandler GetZCHandler( void ) {
		return ZCGlobal.Get().zcHandler;
	}*/


	// Prints well-decorated information string:
	static clearscope void ClearscopeLog( EZCheckerLogLevels loglevel, String text ) {
		String logPrefix = "";

		if ( !( loglevel & LL_NoPrefix ) ) {
			switch ( loglevel & ~LL_FlagsMask ) {
				case LL_Debug:
					logPrefix = LLCOLOR_DEBUG .. "[ZC Debug] ";
					break;
				case LL_Emergency:
					logPrefix = TEXTCOLOR_RED .. "[ZChecker emergency] " .. LLCOLOR_EMERGENCY;
					break;
				default:
					logPrefix = TEXTCOLOR_GRAY .. "[ZC] " .. LLCOLOR_MAIN;
					break;
			} // of switch ( loglevel & ~LL_NoPrefix ) {
		} // of if ( !( loglevel & LL_NoPrefix ) ) {

		if ( !( loglevel & LL_NoDot ) ) {
			String lastch = text.Mid( text.Length() - 1 );

			if ( !( lastch == "." || lastch == "!" || lastch == "?" || lastch == ":" || lastch == ";" ) )
				text = text .. ".";
		}

		console.printf( logPrefix .. text );
	} // of static clearscope void ClearscopeLog( EZCheckerLogLevels loglevel, String text ) {}

	// A play-scope wrapper around a data-scope method (mostly used):
	static play void Log( EZCheckerLogLevels loglevel, String text ) {
		if ( ZCGlobal.Get().zcCurLogLevel >= ( loglevel & ~LL_FlagsMask ) )
			ClearscopeLog( loglevel, text );
	}

	static ui void UILog( EZCheckerLogLevels loglevel, String text ) {
		ZCGlobal it = ZCGlobal( ThinkerIterator.Create( "ZCGlobal", STAT_STATIC ).Next() );

		if ( it && ( it.zcCurLogLevel >= ( loglevel & ~LL_FlagsMask ) ) )
			ClearscopeLog( loglevel, text );
	}

	// Test for the special ZChecker level:
	static clearscope bool IsEverythingLevel( void ) {
		// Got from "mapchecksum everything" CCMD:
		//return level.GetChecksum() ~== "8FBB774BE1D239B5C7CB514DF9B41A2E" || ( CVar.FindCVar( "mcm_zchecker_forceevmap" ).GetBool() );

		return ( level.mapname ~== "EVERYTHING" ) || ( level.mapname ~== "EVERYTHING_SIMPLED" )
			|| ( CVar.FindCVar( "mcm_zchecker_ev_forcemap" ).GetBool() );
	}



	/* === ZChecker operating on the internal and saves-through variables === */

	// Fixing an ancient ZScript bug...
	static clearscope void SetUserCVarString( String cvarName, String cvarValue ) {
		CVar usercvar = CVar.GetCVar( cvarName, players[ consoleplayer ] );

		if ( usercvar ) {
			CVar metastring = CVar.FindCVar( "mcm_zchecker_internal_metastring" );
			metastring.SetString( cvarName );
			usercvar.SetString( cvarValue );

			ACS_Execute( -int( 'ZChecker_SetUserCVar' ), 0, consoleplayer );
		}
	}

	clearscope String GetZCheckerString( String zcname ) {
		String outStr = "";

		for ( int i = 0; i < internalStrings.Size(); i++ ) {
			//console.printf( "#" .. i .. ": dict[ '" .. internalStrings[ i ].cell .. "' ] == '" .. internalStrings[ i ].value .. "'. Arg is " .. zcname );
			if ( internalStrings[ i ].cell == zcname ) {
				outStr = internalStrings[ i ].value;
				break;
			}
		}

		return outStr;
	}

	play bool SetZCheckerString( String zcname, String zcvalue ) {
		if ( zcname.CharAt( 0 ) != "$" ) {
			ZCGlobal.Log( LL_Main, GetClassName() .. "::SetZCheckerString(). " .. TEXTCOLOR_YELLOW .. "Internal variable name must start with \"$\" or \"%\"" .. LLCOLOR_MAIN .. " (got \"" .. TEXTCOLOR_RED .. zcname .. LLCOLOR_MAIN .. "\")." );
			return false;
		}

		ZCInternalStringDictionaryCell dictcell = NULL;

		for ( int i = 0; i < internalStrings.Size(); i++ ) {
			if ( internalStrings[ i ].cell == zcname ) {
				dictcell = internalStrings[ i ];
				break;
			}
		}

		if ( !dictcell ) {
			dictcell = new( 'ZCInternalStringDictionaryCell' );
			dictcell.cell = zcname;

			internalStrings.Push( dictcell );
		}

		dictcell.value = zcvalue;

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::SetZCheckerString(). Dict[ \"" .. zcname .. "\" ] == \"" .. GetZCheckerString( zcname ) .. "\"." );

		return true;
	}


	/* === General (other) utils === */

    static clearscope String squeezeVector2( vector2 vec ) {
        return "(" .. int( vec.x ) .. ", " .. int( vec.y ) .. ")";
    }

	static clearscope String squeezeVector2dec2( vector2 vec ) {
		return String.Format( "(%.2f, %.2f)", vec.x, vec.y );
	}

    static clearscope String squeezeVector3( vector3 vec ) {
        return "(" .. int( vec.x ) .. ", " .. int( vec.y ) .. ", " .. int( vec.z ) .. ")";
    }

	static double, double vector3ToAnglePitch( vector3 vec ) {
		return atan2( vec.y, vec.x ), -90.0 * sin( vec.z );
	}

	static vector3 anglePitchToVector3( double angle, double pitch ) {
		double cosangle = cos( angle );
		double cospitch = cos( pitch );

		return ( cosangle * cospitch, sin( angle ) * cospitch, sin( pitch ) );
	}

	static String ObjectName( Object obj ) {
		return ( obj? obj.GetClassName() .. "" : "" );
	}

	static String ClassName( class cls ) {
		return ( cls? cls.GetClassName() .. "" : "" );
	}

	// Remove all first and all last spaces and tabs in the string.
	static String TruncateStringBySpaces( String str ) {

		uint code = str.CharCodeAt( 0 );
		while ( ( code == 9 || code == 11 || code == 32 ) && str.Length() ) {
			str = str.Mid( 1 );
			code = str.CharCodeAt( 0 );
		}

		uint len = str.Length() - 1;
		code = str.CharCodeAt( len );
		while ( ( code == 9 || code == 11 || code == 32 ) /* && ( len + 1 ) */ ) {
			str = str.Left( len );
			len = str.Length() - 1;
			code = str.CharCodeAt( len );
		}

		return str;
	}
} // of class ZCGlobal: Thinker {}




class ZCheckerHandler: StaticEventHandler {
	ZCGlobal globalclass;

	Array<ZCConsoleClass> zcConsoleHandleClasses;
	Array<ZCBaseInfoPanelPart> zcInfoPanelClasses;
	Array<ZCBaseInfoPanelPart> zcDefaultInfoPanelClasses;

	Array<ZCInternalActorNameCell> allActorNames;
	Array<String> lastUsedActorNames; // Cache.

	// It's impossible to avoid unloading actors (and pointers to them) from 
	//memory on level reloading. Or I just don't know something.
	ZCheckerField Testee[ MaxTestee ];

	ZCheckerCCMDInfo zcCCMDInfo;
	transient Font zcInfoPanelFont;

	String zcConfigFile;

	transient CVar panelsorder;
	bool panelsorderChanged;


	ZCConsoleClass GetZCConsoleClass( int index ) {
		ZCConsoleClass ccmd = NULL;

		if ( index >= 0 && index < zcConsoleHandleClasses.Size() ) {
			ccmd = zcConsoleHandleClasses[ index ];
			//ZCGlobal.Log( LL_Debug, GetClassName() .. "::GetZCConsoleClass(). CCMD #" .. index .. " is <" .. zcConsoleHandleClasses[ index ] .. ">." );
		}

		return ccmd;
	} // of ZCConsoleClass GetZCConsoleClass( int index ) {}

	void UpdateInternalClassnameByField( uint fieldnum ) {
		if ( fieldnum < MaxTestee ) {
			String newClassname = "";

			if ( Testee[ fieldnum ].mo )
				newClassname = Testee[ fieldnum ].mo.GetClassName();

			globalclass.SetZCheckerString( "$" .. ( fieldnum + 1 ), newClassname );
		}
	}

	private bool addConsoleClass( class<ZCConsoleClass> classname, bool importantFlag = false ) {
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::addConsoleClass(). Trying to add \"" .. ( classname? classname.GetClassName() .. "" : "<NULL>" ) .. "\"." );

		if ( classname ) {
			ZCConsoleClass newCCMD = ZCConsoleClass.Create( classname, importantFlag );
			zcConsoleHandleClasses.push( newCCMD );
			newCCMD.PostBeginPlay();
		}

		return !!classname;
	}
	private void addConsoleSeparator( bool importantFlag = false ) {
		zcConsoleHandleClasses.push( ZCConsoleClass.Create( 'ZCConsoleSeparator', importantFlag ) );
	}

	private bool addInfoPanelClass( class<ZCBaseInfoPanelPart> classname ) {
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::addInfoPanelClass(). Trying to add \"" .. ( classname? classname.GetClassName() .. "" : "<NULL>" ) .. "\"." );

		if ( classname ) {
			ZCBaseInfoPanelPart newPanelPart = ZCBaseInfoPanelPart.Create( classname, self );
			zcDefaultInfoPanelClasses.push( newPanelPart );
		}

		return !!classname;
	}


	static ENewlineTypes GetTextNewlinesType( String text ) {
		ENewlineTypes nltype = ZCNL_Unknown;

		if ( text != "" ) {
			int curPos = 0;
			int textLength = text.Length();

			while ( nltype == ZCNL_Unknown && curPos < textLength ) {
				if ( text.CharCodeAt( curPos ) == 0x0D )
					nltype = ( ++curPos < textLength && text.CharCodeAt( curPos ) == 0x0A )? ZCNL_DOS : ZCNL_Mac;
				else if ( text.CharCodeAt( curPos ) == 0x0A )
					nltype = ( ++curPos < textLength && text.CharCodeAt( curPos ) == 0x0D )? ZCNL_DOSReversed : ZCNL_Unix;

				curPos++;
			}

		} // of if ( text != "" ) {}

		return nltype;
	} // of static ENewlineTypes GetTextNewlinesType( String text ) {}

	private void handleConfigFileNewlines( String newlineTypeComment, String replaceeNewlineSeq ) {
		ZCGlobal.Log( LL_Debug, "New lines type for file \"ZChecker.cfg\" recognized as " .. newlineTypeComment );

		if ( replaceeNewlineSeq != "\n" )
			zcConfigFile.Replace( replaceeNewlineSeq, "\n" );
	}

	private bool checkKeywordArgsAmount( uint argsAmount, String keyword, uint rightAmount, String argsDescription ) {
		if ( argsAmount != rightAmount ) {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::checkKeywordArgsAmount(). Wrong amount of arguments for keyword \"" .. keyword .. "\": has " .. argsAmount .. ", must be " .. rightAmount .. " (" .. argsDescription .. ")." );
			return false;
		}

		return true;
	}

	void IncludeConsoleClasses( void ) {
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::IncludeConsoleClasses(). Creating CCMD handlers and info panel classes..." );

        int zcConfigFileHandler = Wads.FindLump( "zchecker.cfg" );

        if ( zcConfigFileHandler != -1 ) {
            zcConfigFile = Wads.ReadLump( zcConfigFileHandler );
            Array<String> zcConfigLines;

            zcConfigFile.ToLower();
			ENewlineTypes newlinesType = GetTextNewlinesType( zcConfigFile );

			switch ( newlinesType ) {
				case ZCNL_Unix: handleConfigFileNewlines( "*nix (LF)", "\n" ); break;
				case ZCNL_DOS: handleConfigFileNewlines( "DOS/Windows (CR/LF)", "\r\n" ); break;
				case ZCNL_Mac: handleConfigFileNewlines( "MacOS (CR)", "\r" ); break;
				case ZCNL_DOSReversed: handleConfigFileNewlines( "DOS reversed (LF/CR)", "\n\r" ); break;
				default:
					ZCGlobal.Log( LL_Debug, TEXTCOLOR_YELLOW .. "Cannot recognize new lines type, using *nix" .. LLCOLOR_DEBUG .. "." );
					newlinesType = ZCNL_Unix;
					break;
			}

            zcConfigFile.Replace( "\r\n", "\n" );
            zcConfigFile.Split( zcConfigLines, "\n" );

			uint curLineIndex = 1;

            for ( int i = 0; i < zcConfigLines.Size(); i++, curLineIndex++ ) {
                String curLine = zcConfigLines[ i ];

                // Comments and extra spaces delete:
                int IndexOfCommentStart = curLine.IndexOf( "#" );
                if ( IndexOfCommentStart != -1 )
                    curLine.Truncate( IndexOfCommentStart );

				curLine = ZCGlobal.TruncateStringBySpaces( curLine );

                // Try to unparse current line if it isn't empty or remove it elsewere:
                if ( curLine != "" ) {
	                Array<String> curLineWords;

					curLineWords.Clear();
		            curLine.Replace( "\t", " " );
		            curLine.Split( curLineWords, " ", TOK_SKIPEMPTY );

					int argsamount = ( curLineWords.Size() - 1 );

                    if ( curLineWords[ 0 ] == "ccmd" || curLineWords[ 0 ] == "addccmd" ) {
						if ( argsamount == 1 ) {
							if ( !addConsoleClass( curLineWords[ 1 ], false ) )
								ZCGlobal.Log( LL_Emergency, GetClassName() .. "::IncludeConsoleClasses(). Wrong ConsoleCommand class \"" .. curLineWords[ 1 ] .. "\"." );
						} else if ( argsamount == 2 && curLineWords[ 2 ] == "important" ) {
							if ( !addConsoleClass( curLineWords[ 1 ], true ) )
								ZCGlobal.Log( LL_Emergency, GetClassName() .. "::IncludeConsoleClasses(). Wrong ConsoleCommand class \"" .. curLineWords[ 1 ] .. "\"." );
						} else {
							checkKeywordArgsAmount( argsamount, curLineWords[ 0 ], 1, "class<ZCConsoleClass> [important]" );
						}

					} else if ( curLineWords[ 0 ] == "ccmdsep" || curLineWords[ 0 ] == "addccmdsep" || curLineWords[ 0 ] == "ccmdseparator" || curLineWords[ 0 ] == "addccmdseparator" ) {
						addConsoleSeparator( argsamount == 1 && curLineWords[ 1 ] == "important" );

                    } else if ( curLineWords[ 0 ] == "panel" || curLineWords[ 0 ] == "addpanel" || curLineWords[ 0 ] == "infopanel" || curLineWords[ 0 ] == "addinfopanel" ) {
						if ( checkKeywordArgsAmount( argsamount, curLineWords[ 0 ], 1, "class<ZCBaseInfoPanelPart>" ) )
							if ( !addInfoPanelClass( curLineWords[ 1 ] ) )
								ZCGlobal.Log( LL_Emergency, GetClassName() .. "::IncludeConsoleClasses(). Wrong PanelInfo class \"" .. curLineWords[ 1 ] .. "\"." );

                    } else {
						ZCGlobal.Log( LL_Emergency, GetClassName() .. "::IncludeConsoleClasses(). Unknown keyword \"" .. curLineWords[ 0 ] .. "\"." );
					}

                } else {
                    zcConfigLines.Delete( i, 1 );
                    i--;
                } // of else of if ( curLine != "" ) {}

            } // of for ( int i = 0; i < zcConfigLines.Size(); i++, curLineIndex++ ) {}
        } else {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::IncludeConsoleClasses(). Cannot find file \"ZChecker.cfg\"." );
		} // of else of if ( zcConfigFileHandler != -1 ) {}

	} // of void IncludeConsoleClasses( void ) {}

	void InitAllActorNames( void ) {
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::InitAllActorNames(). Creating storage cells for actor names..." );

		for ( int i = 0; i < ZCInternalActorNameCell.ARRAY_Quantity; i++ )
			allActorNames.Push( ZCInternalActorNameCell.Create( i ) );

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::InitAllActorNames(). Saving actor names by first char..." );

		for ( int i = 0; i < AllActorClasses.Size(); i++ ) {
			String curclass = AllActorClasses[ i ].GetClassName();
			int index = ZCInternalActorNameCell.GetClassnameCellIndex( curclass );

			allActorNames[ index ].orignames.Push( curclass );
			curclass.ToLower();
			allActorNames[ index ].names.Push( curclass ); // To speed up a comparing process.
		}

		if ( ZCGlobal.Get().zcCurLogLevel >= LL_Debug ) {
			for ( int i = 0; i< ZCInternalActorNameCell.ARRAY_Quantity; i++ ) {
				ZCInternalActorNameCell nameCell = allActorNames[ i ];
				int nameCellSize = nameCell.names.Size();

				ZCGlobal.ClearscopeLog( LL_Debug, GetClassName() .. "::InitAllActorNames(). " .. String.Format(
										"allActorNames[ %2i ] quantity: %3i." .. ( nameCellSize > 0? " First is \"" .. nameCell.names[ 0 ] .. "\"." : "" ), i, nameCellSize ) );
			}
		} // of if ( ZCGlobal.Get().zcCurLogLevel >= LL_Debug ) {}
	} // of void InitAllActorNames( void ) {}



	override void OnRegister() {
		SetOrder( ZCheckerHandlerOrder );

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::OnRegister(). ZChecker initializes..." );

		panelsorderChanged = true;

		for ( int i = 0; i < MaxTestee; i++ ) {
			Testee[ i ] = new( 'ZCheckerField' );
			Testee[ i ].fieldPos = i;
			Testee[ i ].actorType = IAT_Normal;
		}

		zcCCMDInfo = new( 'ZCheckerCCMDInfo' );
		zcCCMDInfo.handler = self;
		zcInfoPanelFont = Font.FindFont( "smallfont" );

		IncludeConsoleClasses();
		InitAllActorNames();

		ZCGlobal.Log( LL_Detailed, "ZChecker initialized successfully. " .. zcConsoleHandleClasses.Size() .. " console commands, " .. zcInfoPanelClasses.Size() .. " info panels." );

		Super.OnRegister();
	}

	// Method to update all of the field meta-information:
	private clearscope Actor UpdateTesteeField( int fieldindex ) {
		Actor curTestee = NULL;

		if ( Testee[ fieldindex ] && Testee[ fieldindex ].mo )
			curTestee = Testee[ fieldindex ].mo;

		// Updating info actors type. Usually it's better not to cross the 
		//ui, data and play scopes in one method...
		if ( curTestee is "StateProvider" && PlayerPawn( Inventory( curTestee ).owner ) ) {
			Testee[ fieldindex ].mo = curTestee = PlayerPawn( Inventory( curTestee ).owner ).player.ReadyWeapon;
			Testee[ fieldindex ].actorType = IAT_StateProvider;
		} else {
			Testee[ fieldindex ].actorType = IAT_Normal;
		}

		return curTestee;
	}



	private void SetPanelsorderCVar( String newvalue ) {
		panelsorderChanged = true;
		panelsorder.SetString( newvalue );

		//ACS_Execute( -int( 'ZChecker_SetUserPanelsOrder' ), 0, consoleplayer );
	}


	override void RenderOverlay( RenderEvent e ) {
		// User CVars locating uses a relatively long algorithm. After a 
		//while I'll optimize them and move somewhere.
		Array<ZCBaseInfoPanelPart> infoPanelParts;
		PlayerInfo pl = players[ consoleplayer ];


		for ( int iCurInfoPanel = 0; iCurInfoPanel < zcInfoPanelClasses.Size(); iCurInfoPanel++ ) {
			ZCBaseInfoPanelPart panelpart = zcInfoPanelClasses[ iCurInfoPanel ];
			CVar curInfoPanelCVar = CVar.GetCVar( panelpart.optionCVarName, pl );

			if ( !curInfoPanelCVar ) {
				ZCGlobal.ClearscopeLog( LL_Emergency, "Info panel class \"" .. TEXTCOLOR_RED .. panelpart.GetClassName() .. LLCOLOR_EMERGENCY .. "\" refers to unknown user CVar \"" .. TEXTCOLOR_RED .. panelpart.optionCVarName .. LLCOLOR_EMERGENCY .."\"." );
			} else if ( curInfoPanelCVar.GetBool() ) {
				infoPanelParts.Push( panelpart );
			}
		}

		double infopanelStartX = CVar.FindCVar( "mcm_zchecker_infopanel_startx" ).GetFloat();
		double infopanelStartY = CVar.FindCVar( "mcm_zchecker_infopanel_starty" ).GetFloat();
		double infopanelScale = CVar.FindCVar( "mcm_zchecker_infopanel_scale" ).GetFloat();
		double infopanelOffsetX = CVar.FindCVar( "mcm_zchecker_infopanel_offsetx" ).GetFloat();


		for ( int i = 0; i < MaxTestee; i++ ) {
			Actor curTestee = UpdateTesteeField( i );

			if ( !curTestee )
				continue;


			// Forming a full information panel:
			String outStr = "";

			for ( int j = 0; j < infoPanelParts.Size(); j++ )
				outStr = outStr .. "\c-" .. infoPanelParts[ j ].GetInfo( curTestee, Testee[ i ] ) .. "\n";


			// Thanks to m8f for the "drawTextCenter()" function code from its "Hellscape Navigator".
			double bordersXMargin = 4.0;
			double scale = 1.0 / infopanelScale;
			double x = infopanelStartX * 0.01 + i * infopanelOffsetX * 0.01;
			double y = infopanelStartY * 0.01;

			int width = int( scale * Screen.GetWidth() );
			int height = int( scale * Screen.GetHeight() );
			double stringWidth = zcInfoPanelFont.StringWidth( outStr );

			x = ( width * x ); //- stringWidth / 2;
			y *= height;

			// Push the text out from the borders:
			if ( x < bordersXMargin )
				x = bordersXMargin;
			else if ( x > width - stringWidth - bordersXMargin )
				x = width - stringWidth - bordersXMargin;

			Screen.DrawText( zcInfoPanelFont, Font.CR_GRAY, x, y, outStr,
							DTA_KeepRatio, true, DTA_VirtualWidth, width, DTA_VirtualHeight, height );
		} // of for ( int i = 0; i < MaxTestee; i++ ) {}

		Super.RenderOverlay( e );
	} // of override void RenderOverlay( RenderEvent e ) {}


	override void NetworkProcess( ConsoleEvent e ) {
		// ZChecker CCMDs parsing:
		String ccmdName = zcCCMDInfo.InitFromEvent( e );

		if ( ccmdName ~== "zc_update_panels_order" ) {
			if ( zcCCMDInfo.args.Size() == 1 ) {
				SetPanelsorderCVar( zcCCMDInfo.args[ 0 ] );
			} else {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::NetworkProcess(). Network event \"zc_update_panels_order\" has wrong amount of the colon-separated arguments (must be one)." );
				ZCGlobal.Log( LL_Main, GetClassName() .. "::NetworkProcess(). Name: \"" .. TEXTCOLOR_TAN .. e.Name .. "\c-\"." );
			}

			Super.NetworkProcess( e );
			return;
		}

		if ( ZCGlobal.Get().zcCurLogLevel >= LL_Debug ) {
			String debugstr = GetClassName() .. "::NetworkProcess(). CCMD: \"" .. ccmdName .. "\"";

			if ( zcCCMDInfo.args.Size() != 0 ) {
				for ( int i = 0; i < zcCCMDInfo.args.Size(); i++ )
					debugstr.AppendFormat( " [" .. TEXTCOLOR_DARKGREEN .. "#%i: \"%s\"" .. LLCOLOR_DEBUG .. "]", i + 1, zcCCMDInfo.args[ i ] );
			} else {
				debugstr = debugstr .. ", no arguments.";
			}

			ZCGlobal.ClearscopeLog( LL_Debug, debugstr );
		}

		// Polling ZChecker CCMD handlers by stored netevent name:
		for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {
			if ( !( zcConsoleHandleClasses[ i ] is 'ZCConsoleCommand' ) )
				continue;

			ZCConsoleCommand curCCMD = ZCConsoleCommand( zcConsoleHandleClasses[ i ] );

			if ( ccmdName ~== curCCMD.GetCommand() ) {
				curCCMD.ccmd = zcCCMDInfo;

				if ( curCCMD.HandleArguments() ) {
					curCCMD.DoCommand();
				} else {
					ZCGlobal.Log( LL_Normal | LL_NoPrefix, TEXTCOLOR_YELLOW .. "Usage\c-:\n" .. curCCMD.GetHelpString() );
				}

				break;
			}
		} // of for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {}

		Super.NetworkProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {}


	void UpdatePanels( void ) {
		uint warningsAmount = 0;
		panelsorderChanged = false;

		zcInfoPanelClasses.Clear();

		String panelsOrderStr = panelsorder.GetString();

		if ( panelsOrderStr != "" ) {
			Array<String> neworder;

			ZCGlobal.Log( LL_Debug, GetClassName() .. "::WorldTick(). panelsorder: \"" .. TEXTCOLOR_TAN .. panelsOrderStr .. LLCOLOR_DEBUG .. "\"." );

			panelsOrderStr.Split( neworder, ",", TOK_SKIPEMPTY );

			for ( int i = 0; i < neworder.Size(); i++ ) {
    			class<Object> curclass = neworder[ i ];

				if ( curclass is "ZCBaseInfoPanelPart" ) {
					bool found = false;

					for ( int j = 0; j < zcDefaultInfoPanelClasses.Size(); j++ ) {
						if ( zcDefaultInfoPanelClasses[ j ].GetClass() == curclass ) {
							found = true;
							zcInfoPanelClasses.Push( zcDefaultInfoPanelClasses[ j ] );
							ZCGlobal.Log( LL_Debug, GetClassName() .. "::GetPanelOptionsOrder(). " .. TEXTCOLOR_GREEN .. "Added Panel class \"" .. neworder[ i ] .. "\"." );
							break;
						}
    				}

					if ( !found )
						ZCGlobal.Log( LL_Detailed, GetClassName() .. "::GetPanelOptionsOrder(). " .. TEXTCOLOR_DARKGRAY .. "Class \"" .. TEXTCOLOR_GRAY .. neworder[ i ] .. TEXTCOLOR_DARKGRAY .. "\" vanished." );
    			} else if ( curclass ) {
					warningsAmount++;
					ZCGlobal.Log( LL_Main, GetClassName() .. "::GetPanelOptionsOrder(). " .. TEXTCOLOR_DARKGRAY .. "Class \"" .. TEXTCOLOR_GRAY .. neworder[ i ] .. TEXTCOLOR_DARKGRAY .. "\" isn't a Panel." );
				} else {
					warningsAmount++;
					ZCGlobal.Log( LL_Main, GetClassName() .. "::GetPanelOptionsOrder(). " .. TEXTCOLOR_DARKGRAY .. "Cannot find Panel class \"" .. TEXTCOLOR_GRAY .. neworder[ i ] .. TEXTCOLOR_DARKGRAY .. "\"." );
				}
			}
		} // of if ( panelsorder.GetString() != "" ) {}

		// Reinitialization (if neccesary):
		if ( zcInfoPanelClasses.Size() == 0 || warningsAmount > 0 ) {
			zcInfoPanelClasses.Clear();

			if ( warningsAmount > 0 )
				ZCGlobal.Log( LL_Main, GetClassName() .. "::UpdatePanels(). It seems like data was corrupted (" .. TEXTCOLOR_FIRE .. warningsAmount .. " warnings\c-). Reinitialization..." );
			else
				ZCGlobal.Log( LL_Debug, GetClassName() .. "::UpdatePanels(). No panel classes defined. Initialization." );

			for ( int i = 0; i < zcDefaultInfoPanelClasses.Size(); i++ )
				zcInfoPanelClasses.Push( zcDefaultInfoPanelClasses[ i ] );
		}
	} // of void UpdatePanels( void ) {}

	override void WorldTick() {
		if ( ( gamestate == GS_LEVEL || gamestate == GS_DEMOSCREEN ) && !( level.maptime % 5 ) )
			globalclass.UpdateLogLevel();

		if ( !( level.maptime % 3 ) ) {
			if ( !panelsorder )
				panelsorder = CVar.GetCVar( "mcm_zchecker_infopanelsorder", players[ consoleplayer ] );

			if ( panelsorderChanged )
				UpdatePanels();
		}

		Super.WorldTick();
	} // of override void WorldTick() {}

	override void WorldLoaded( WorldEvent e ) {
		globalclass = ZCGlobal.Get();
		globalclass.InitZCheckerHandler( self );

		globalclass.SetZCheckerString( "$1", "" );
		globalclass.SetZCheckerString( "$2", "" );
		globalclass.SetZCheckerString( "$3", "" );
		globalclass.SetZCheckerString( "$last", "" );

		Super.WorldLoaded( e );
	}

} // of class ZCheckerHandler: EventHandler {}
