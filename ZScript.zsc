version "3.3.0"

#include "ZScript/ZCUtils.zsc"
#include "ZScript/ZCBaseClasses.zsc"
#include "ZScript/ZCMenus.zsc"
#include "ZScript/ZCMapScripts.zsc"

#include "ZScript/ZCCommandsGeneral.zsc"
#include "ZScript/ZCCommandsActorAlter.zsc"
#include "ZScript/ZCCommandsInfo.zsc"
#include "ZScript/ZCCommandsMap.zsc"
#include "ZScript/ZCTooltipClasses.zsc"

#include "ZScript/ZCInfoPanelMain.zsc"
#include "ZScript/ZCInfoPanelPointers.zsc"
#include "ZScript/ZCInfoPanelGeometry.zsc"
#include "ZScript/ZCInfoPanelOther.zsc"


const ZCheckerVersion = "0.69";


// AutoAmbient: 0x7FAA0004.
const ZCheckerHandlerOrder = 0x7FAA0005;
const ZCheckerMapHandlerOrder = 0x7FAA0006;

const MaxTestee = 3; // Will rename someday...

const ZCHECKER_AGRS_SEPARATOR = "@@";


enum EZCheckerLogLevels {
	LL_Emergency = 0,
	LL_General = 1,
	LL_Detailed,
	LL_Debug,

	LL_Common = LL_General,
	LL_Normal = LL_General,
	LL_Main = LL_General,
	LL_Extended = LL_Detailed,
	LL_Extra = LL_Detailed,
	LL_Critical = LL_Emergency,

	LL_FlagsMask	= 0xFFF0,
	LL_NoDot		= 0x4000,
	LL_NoPrefix		= 0x8000
};

enum EZCheckerInfoActorType {
	IAT_Normal = 0,
	IAT_StateProvider
};

const CCMDCOLOR_TITLE = TEXTCOLOR_ICE;
const CCMDCOLOR_TITLEARGS = TEXTCOLOR_GREEN;
const CCMDCOLOR_TITLEWIP = TEXTCOLOR_DARKGRAY;
const CCMDCOLOR_DESC = "\c-";


class ZCInfoPanelNode {
	ZCBaseInfoPanelPart panel;
	CVar panelCVar;

	void InitCVar( void ) {
		panelCVar = CVar.GetCVar( panel.optionCVarName, players[ consoleplayer ] );
	}
}

class ZCInfoPanelNodeKeeper {
	Array<ZCInfoPanelNode> nodes;
	Array<ZCInfoPanelNode> playnodes;

	void Push( ZCBaseInfoPanelPart saveepanel ) {
		ZCInfoPanelNode newnode = new( 'ZCInfoPanelNode' );

		newnode.panel = saveepanel;

		nodes.Push( newnode );

		if ( saveepanel.IsPlayScope() )
			playnodes.Push( newnode );
	}
	int Size( void ) {
		return nodes.Size();
	}
	int PlayscopedSize( void ) {
		return playnodes.Size();
	}

	void Clear( void ) {
		nodes.Clear();
		playnodes.Clear();
	}
} // of class ZCInfoPanelNodeKeeper {}

// Data-scoped panels storage:
class ZCPanelsStorage {
	Array<ZCBaseInfoPanelPart> defaultPanels;	// Loaded from the ZChecker configuration file ("zchecker.cfg").
	ZCInfoPanelNodeKeeper curPanels;			// Loaded from the *.ini.

	transient CVar panelsOrderCVar;
	bool panelsorderChanged;

	transient CVar fonttypeCVar;
	transient Font infopanelsFont;
	int lastFontType;

	String panelsstr; // General read/write variable.

	// For the "[Init|Tick]SetPanelsorderCVar()":
	String newOrderStr;
	int newOrderSaveTic;
	int newOrderCurPart;
	bool newOrderFirstTic;

	// As "254 - String.Format( "mcm_zchecker_infopanelsorder_part##" ).Length()":
	const availablePartLen = ( 254 - 36 );


	static ZCPanelsStorage Create( void ) {
		ZCPanelsStorage panel = new( 'ZCPanelsStorage' );

		panel.panelsorderChanged = true;
		panel.curpanels = new( 'ZCInfoPanelNodeKeeper' );
		panel.lastFontType = -1;

		return panel;
	}

	void UpdatePanels( bool fromCVar = false ) {
		uint warningsAmount = 0;
		panelsorderChanged = false;

		curPanels.Clear();

		String panelsOrderStr = ( fromCVar? GetPanelsorderFromCVar(): panelsstr );
		int curloglevel = LL_Debug;

		if ( CVar.FindCVar( "mcm_zchecker_loglevel" ) )
			curloglevel = CVar.FindCVar( "mcm_zchecker_loglevel" ).GetInt();

		if ( panelsOrderStr != "" ) {
			Array<String> neworder;

			if ( curloglevel >= LL_Debug )
				ZCGlobal.ClearscopeLog( LL_Debug, GetClassName() .. "::UpdatePanels(). panelsOrderStr: \"" .. TEXTCOLOR_OLIVE .. panelsOrderStr .. LLCOLOR_DEBUG .. "\"." );

			panelsOrderStr.Split( neworder, ",", TOK_SKIPEMPTY );

			for ( int i = 0; i < neworder.Size(); i++ ) {
    			class<Object> curclass = neworder[ i ];

				if ( curclass is "ZCBaseInfoPanelPart" ) {
					bool found = false;

					for ( int j = 0; j < defaultPanels.Size(); j++ ) {
						if ( defaultPanels[ j ].GetClass() == curclass ) {
							found = true;
							curPanels.Push( defaultPanels[ j ] );

							if ( curloglevel >= LL_Debug )
								ZCGlobal.ClearscopeLog( LL_Debug, GetClassName() .. "::UpdatePanels(). Added Panel class \"" .. TEXTCOLOR_DARKGREEN .. neworder[ i ] .. LLCOLOR_DEBUG .. "\"." );

							break;
						}
    				}

					if ( !found && curloglevel >= LL_Detailed )
						ZCGlobal.ClearscopeLog( LL_Detailed, GetClassName() .. "::UpdatePanels(). " .. TEXTCOLOR_DARKGRAY .. "Class \"" .. TEXTCOLOR_GRAY .. neworder[ i ] .. TEXTCOLOR_DARKGRAY .. "\" vanished." );
    			} else if ( curclass ) {
					warningsAmount++;
					ZCGlobal.ClearscopeLog( LL_Main, GetClassName() .. "::UpdatePanels(). " .. TEXTCOLOR_DARKGRAY .. "Class \"" .. TEXTCOLOR_GRAY .. neworder[ i ] .. TEXTCOLOR_DARKGRAY .. "\" isn't a Panel." );
				} else {
					warningsAmount++;
					ZCGlobal.ClearscopeLog( LL_Main, GetClassName() .. "::UpdatePanels(). " .. TEXTCOLOR_DARKGRAY .. "Cannot find Panel class \"" .. TEXTCOLOR_GRAY .. neworder[ i ] .. TEXTCOLOR_DARKGRAY .. "\"." );
				}
			}
		} // of if ( panelsOrderCVar.GetString() != "" ) {}

		// Reinitialization (if neccesary):
		if ( curPanels.Size() == 0 || warningsAmount > 0 ) {
			curPanels.Clear();

			if ( warningsAmount > 0 )
				ZCGlobal.ClearscopeLog( LL_Main, GetClassName() .. "::UpdatePanels(). It seems like data was corrupted (" .. TEXTCOLOR_FIRE .. warningsAmount .. " warnings\c-). Reinitialization..." );
			else if ( curloglevel >= LL_Debug )
				ZCGlobal.ClearscopeLog( LL_Debug, GetClassName() .. "::UpdatePanels(). No panel classes defined. Initialization." );

			for ( int i = 0; i < defaultPanels.Size(); i++ )
				curPanels.Push( defaultPanels[ i ] );
		}

		panelsstr = "";

		for ( int i = 0; i < curPanels.Size(); i++ ) {
			ZCInfoPanelNode panelnode = curPanels.nodes[ i ];

			panelnode.InitCVar();

			if ( !panelnode.panelCVar )
				ZCGlobal.ClearscopeLog( LL_Emergency, GetClassName() .. "::UpdatePanels(). Panel \"" .. TEXTCOLOR_RED .. panelnode.panel.GetClassName() .. LLCOLOR_EMERGENCY .. "\" refers to unknown CVar \"" .. TEXTCOLOR_RED .. panelnode.panel.optionCVarName .. LLCOLOR_EMERGENCY .."\"." );

			panelsstr = panelsstr .. panelnode.panel.GetClassName() .. ",";
		}

		InitSetPanelsorderCVar();
	} // of void UpdatePanels( void ) {}

	void InitSetPanelsorderCVar( String argorder = "" ) {
		newOrderStr = ( argorder == ""? panelsstr : argorder );

		newOrderSaveTic = int( ceil( newOrderStr.Length() / double( availablePartLen ) ) ) + 1;
		newOrderCurPart = 0;
		newOrderFirstTic = true;

		ZCGlobal.DataLog( LL_Debug, String.Format( GetClassName() .. "::InitSetPanelsorderCVar(). strlen %i / %i, ceil == %i", newOrderStr.Length(), availablePartLen, newOrderSaveTic ) );
	}

	// ZScript-ACS API cannot obtain more than one string with maximum of 255 characters.
	void TickSetPanelsorderCVar( void ) {
		if ( newOrderSaveTic <= 0 || newOrderCurPart > 9 )
			return;

		if ( !newOrderFirstTic )
			ACS_Execute( -int( 'ZChecker_SetUserCVar' ), 0, consoleplayer );
		else
			newOrderFirstTic = false;

		int indexfrom = newOrderCurPart * availablePartLen;
		int indexto = min( indexfrom + availablePartLen, newOrderStr.Length() );

		String curpart = newOrderStr.Mid( indexfrom, ( indexto - indexfrom ) );
		ZCGlobal.DataLog( LL_Debug, GetClassName() .. "::TickSetPanelsorderCVar(). Tic " .. newOrderSaveTic .. " part " .. newOrderCurPart .. ": \"" .. curpart .. "\"" );

		ZCGlobal.PrepareSetUserCVarString( "mcm_zchecker_infopanelsorder_part" .. newOrderCurPart, curpart );

		newOrderCurPart++;
		newOrderSaveTic--;

		//if ( indexto >= newOrderStr.Length() )
		//	newOrderSaveTic = 0;
	}

	String GetPanelsorderFromCVar( void ) {
		String outstr = "";

		for ( int i = 0; i < 10; i++ ) {
			String curpart = CVar.GetCVar( "mcm_zchecker_infopanelsorder_part" .. i, players[ consoleplayer ] ).GetString();

			if ( curpart.Length() == 0 )
				break;

			outstr = outstr .. curpart;
		}

		ZCGlobal.DataLog( LL_Debug, GetClassName() .. "::GetPanelsorderFromCVar(). Concatenated: \"" .. outstr .. "\"" );

		return outstr;
	}

	void UpdateFont( void ) {
		int fonttype = -1;

		if ( !fonttypeCVar )
			fonttypeCVar = CVar.GetCVar( "mcm_zchecker_infopanel_fonttype", players[ consoleplayer ] );

		fonttype = fonttypeCVar.GetInt();

		if ( fonttype != lastFontType ) {
			ZCGlobal.DataLog( LL_Debug, GetClassName() .. "::UpdateFont(). Font type changed to " .. fonttype );
			lastFontType = fonttype;

			switch ( fonttype ) {
				case 0:
					infopanelsFont = smallfont;
					break;
				case 1:
					infopanelsFont = Font.FindFont( "zchecker_smallfont_mono" );
					break;
				default:
					ZCGlobal.DataLog( LL_Emergency, GetClassName() .. "::UpdateFont(). Unknown font type \"" .. fonttype .. "\"." );
					break;
			}
		} // of if ( fonttype != lastFontType ) {}

	} // of void UpdateFont( void ) {}

} // of class ZCPanelsStorage {}




class ZCheckerHandler: StaticEventHandler {
	ZCGlobal globalclass;
	ZCPanelsStorage panels;

	Array<ZCConsoleClass> zcConsoleHandleClasses;

	Array<ZCInternalActorNameCell> allActorNames;
	//Array<String> lastUsedActorNames; // Cache.

	// It's impossible to avoid unloading actors (and pointers to them) from 
	//memory on level reloading. Or I just don't know something.
	ZCheckerField Testee[ MaxTestee ];

	ZCheckerCCMDInfo zcCCMDInfo;

	bool handlerInitSuccess;
	String zcConfigFile;
	int zcConfigCurLineIndex;


	ZCConsoleClass GetZCConsoleClass( int index ) {
		ZCConsoleClass ccmd = NULL;

		if ( index >= 0 && index < zcConsoleHandleClasses.Size() ) {
			ccmd = zcConsoleHandleClasses[ index ];
			//ZCGlobal.Log( LL_Debug, GetClassName() .. "::GetZCConsoleClass(). CCMD #" .. index .. " is <" .. zcConsoleHandleClasses[ index ] .. ">." );
		}

		return ccmd;
	} // of ZCConsoleClass GetZCConsoleClass( int index ) {}

	void UpdateInternalClassnameByField( uint fieldnum ) {
		if ( fieldnum < MaxTestee ) {
			String newClassname = "";

			if ( Testee[ fieldnum ].mo )
				newClassname = Testee[ fieldnum ].mo.GetClassName();

			globalclass.SetZCheckerString( "$" .. ( fieldnum + 1 ), newClassname );
		}
	}

	private bool addConsoleClass( class<ZCConsoleClass> classname, bool importantFlag = false ) {
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::addConsoleClass(). Trying to add \"" .. ( classname? classname.GetClassName() .. "" : "<NULL>" ) .. "\"." );

		if ( classname ) {
			ZCConsoleClass newCCMD = ZCConsoleClass.Create( classname, importantFlag );
			zcConsoleHandleClasses.Push( newCCMD );
			newCCMD.PostBeginPlay(); // Calls "OnLoad()".
		}

		return !!classname;
	}
	private void addConsoleSeparator( bool importantFlag = false ) {
		zcConsoleHandleClasses.Push( ZCConsoleClass.Create( 'ZCConsoleSeparator', importantFlag ) );
	}

	private play bool addInfoPanelClass( class<ZCBaseInfoPanelPart> classname ) {
		if ( classname ) {
			ZCBaseInfoPanelPart newPanelPart = NULL;

			if ( classname is "ZCBaseInfoPanelPart_PlayScope" ) {
				ZCGlobal.Log( LL_Debug, GetClassName() .. "::addInfoPanelClass(). Trying to add a " .. TEXTCOLOR_DARKGREEN .. "play-scoped " .. LLCOLOR_DEBUG .. "\"" .. classname.GetClassName() .. "\"." );
				newPanelPart = ZCBaseInfoPanelPart_PlayScope.CreatePlayScope( classname, self );
			} else {
				ZCGlobal.Log( LL_Debug, GetClassName() .. "::addInfoPanelClass(). Trying to add \"" .. classname.GetClassName() .. "\"." );
				newPanelPart = ZCBaseInfoPanelPart.Create( classname, self );
			}

			panels.defaultPanels.Push( newPanelPart );
		} else {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::addInfoPanelClass(). No class<ZCBaseInfoPanelPart> defined." );
		}

		return !!classname;
	}


	private void handleConfigFileNewlines( String newlineTypeComment, String replaceeNewlineSeq ) {
		ZCGlobal.Log( LL_Debug, "New lines type for file \"ZChecker.cfg\" recognized as " .. newlineTypeComment );

		if ( replaceeNewlineSeq != "\n" )
			zcConfigFile.Replace( replaceeNewlineSeq, "\n" );
	}

	private bool checkKeywordArgsAmount( uint argsAmount, String keyword, uint rightAmount, String argsDescription ) {
		if ( argsAmount != rightAmount ) {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::checkKeywordArgsAmount(). Wrong arguments for keyword \"" .. keyword .. "\" at line " .. zcConfigCurLineIndex .. ": has " .. argsAmount .. ", must be " .. rightAmount .. " (" .. TEXTCOLOR_RED .. "\"" .. argsDescription .. "\"" .. LLCOLOR_EMERGENCY .. ")." );
			handlerInitSuccess = false;
			return false;
		}

		return true;
	}

	private void printConfigWarning( String message ) {
		ZCGlobal.Log( LL_Emergency, GetClassName() .. "::IncludeConsoleClasses(). " .. message .. " at line " .. zcConfigCurLineIndex .. "." );
		handlerInitSuccess = false;
	}

	void IncludeConsoleClasses( void ) {
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::IncludeConsoleClasses(). Creating CCMD handlers and info panel classes..." );

        int zcConfigFileHandler = Wads.FindLump( "zchecker.cfg" );

        if ( zcConfigFileHandler != -1 ) {
            zcConfigFile = Wads.ReadLump( zcConfigFileHandler );
            Array<String> zcConfigLines;

            zcConfigFile.ToLower();
			ENewlineTypes newlinesType = ZCGlobal.GetTextNewlinesType( zcConfigFile );

			switch ( newlinesType ) {
				case ZCNL_Unix: handleConfigFileNewlines( "*nix (LF)", "\n" ); break;
				case ZCNL_DOS: handleConfigFileNewlines( "DOS/Windows (CR/LF)", "\r\n" ); break;
				case ZCNL_Mac: handleConfigFileNewlines( "MacOS (CR)", "\r" ); break;
				case ZCNL_DOSReversed: handleConfigFileNewlines( "DOS reversed (LF/CR)", "\n\r" ); break;
				default:
					ZCGlobal.Log( LL_Debug, TEXTCOLOR_YELLOW .. "Cannot recognize new lines type, using *nix" .. LLCOLOR_DEBUG .. "." );
					newlinesType = ZCNL_Unix;
					break;
			}

            zcConfigFile.Replace( "\r\n", "\n" ); // Neccesary???
            zcConfigFile.Split( zcConfigLines, "\n" );

			zcConfigCurLineIndex = 1;

            for ( int i = 0; i < zcConfigLines.Size(); i++, zcConfigCurLineIndex++ ) {
                String curLine = zcConfigLines[ i ];

                // Comments and extra spaces delete:
                int IndexOfCommentStart = curLine.IndexOf( "#" );
                if ( IndexOfCommentStart != -1 )
                    curLine.Truncate( IndexOfCommentStart );

				curLine = ZCGlobal.TruncateStringBySpaces( curLine );

                // Try to unparse current line if it isn't empty or remove it elsewere:
                if ( curLine != "" ) {
	                Array<String> curLineWords;

					curLineWords.Clear();
		            curLine.Replace( "\t", " " );
		            curLine.Split( curLineWords, " ", TOK_SKIPEMPTY );

					int argsamount = ( curLineWords.Size() - 1 );

                    if ( curLineWords[ 0 ] == "ccmd" || curLineWords[ 0 ] == "addccmd" || curLineWords[ 0 ] == "plaintext" || curLineWords[ 0 ] == "addtext" || curLineWords[ 0 ] == "addplaintext" ) {
						if ( argsamount == 1 ) {
							if ( !addConsoleClass( curLineWords[ 1 ], false ) )
								printConfigWarning( "Wrong ZCConsoleClass class \"" .. curLineWords[ 1 ] .. "\"" );
						} else if ( argsamount == 2 && curLineWords[ 2 ] == "important" ) {
							if ( !addConsoleClass( curLineWords[ 1 ], true ) )
								printConfigWarning( "Wrong ZCConsoleClass class \"" .. curLineWords[ 1 ] .. "\"" );
						} else {
							checkKeywordArgsAmount( argsamount, curLineWords[ 0 ], 1, "class<ZCConsoleClass> [important]" );
						}

					} else if ( curLineWords[ 0 ] == "ccmdsep" || curLineWords[ 0 ] == "addccmdsep" || curLineWords[ 0 ] == "ccmdseparator" || curLineWords[ 0 ] == "addccmdseparator" ) {
						addConsoleSeparator( argsamount == 1 && curLineWords[ 1 ] == "important" );

                    } else if ( curLineWords[ 0 ] == "panel" || curLineWords[ 0 ] == "addpanel" || curLineWords[ 0 ] == "infopanel" || curLineWords[ 0 ] == "addinfopanel" ) {
						if ( checkKeywordArgsAmount( argsamount, curLineWords[ 0 ], 1, "class<ZCBaseInfoPanelPart>" ) )
							if ( !addInfoPanelClass( curLineWords[ 1 ] ) )
								printConfigWarning( "Wrong PanelInfo class \"" .. curLineWords[ 1 ] .. "\"" );

                    } else {
						printConfigWarning( "Unknown keyword \"" .. curLineWords[ 0 ] .. "\"" );
					}

                } else {
                    zcConfigLines.Delete( i, 1 );
                    i--;
                } // of else of if ( curLine != "" ) {}

            } // of for ( int i = 0; i < zcConfigLines.Size(); i++, zcConfigCurLineIndex++ ) {}
        } else {
			ZCGlobal.Log( LL_Emergency, GetClassName() .. "::IncludeConsoleClasses(). Cannot find file \"ZChecker.cfg\"." );
			handlerInitSuccess = false;
		} // of else of if ( zcConfigFileHandler != -1 ) {}

	} // of void IncludeConsoleClasses( void ) {}

	void InitAllActorNames( void ) {
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::InitAllActorNames(). Creating storage cells for actor names..." );

		for ( int i = 0; i < ZCInternalActorNameCell.ARRAY_Quantity; i++ )
			allActorNames.Push( ZCInternalActorNameCell.Create( i ) );

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::InitAllActorNames(). Saving actor names by first char..." );

		for ( int i = 0; i < AllActorClasses.Size(); i++ ) {
			String curclass = AllActorClasses[ i ].GetClassName();
			int index = ZCInternalActorNameCell.GetClassnameCellIndex( curclass );

			allActorNames[ index ].orignames.Push( curclass );
			curclass.ToLower();
			allActorNames[ index ].names.Push( curclass ); // To speed up a comparing process.
		}

		if ( ZCGlobal.Get().zcCurLogLevel >= LL_Debug ) {
			for ( int i = 0; i< ZCInternalActorNameCell.ARRAY_Quantity; i++ ) {
				ZCInternalActorNameCell nameCell = allActorNames[ i ];
				int nameCellSize = nameCell.names.Size();

				ZCGlobal.ClearscopeLog( LL_Debug, GetClassName() .. "::InitAllActorNames(). " .. String.Format(
										"allActorNames[ %2i ] quantity: %3i." .. ( nameCellSize > 0? " First is \"" .. nameCell.names[ 0 ] .. "\"." : "" ), i, nameCellSize ) );
			}
		} // of if ( ZCGlobal.Get().zcCurLogLevel >= LL_Debug ) {}
	} // of void InitAllActorNames( void ) {}



	override void OnRegister() {
		handlerInitSuccess = true;

		SetOrder( ZCheckerHandlerOrder );

		ZCGlobal.Log( LL_Debug, GetClassName() .. "::OnRegister(). ZChecker initializes..." );

		panels = ZCPanelsStorage.Create();

		for ( int i = 0; i < MaxTestee; i++ )
			Testee[ i ] = ZCheckerField.Create( i );

		zcCCMDInfo = new( 'ZCheckerCCMDInfo' );
		zcCCMDInfo.handler = self;

		IncludeConsoleClasses();
		InitAllActorNames();

		ZCGlobal.Log( LL_Detailed, String.Format( "ZChecker v%s initialized %s. Total %i console commands, %i info panels.",
									ZCheckerVersion, ( handlerInitSuccess? "successfully" : TEXTCOLOR_RED .. "with warnings" .. LLCOLOR_MAIN ),
									zcConsoleHandleClasses.Size(), panels.defaultPanels.Size() ) );

		Super.OnRegister();
	}

	// Method to update all of the field meta-information:
	private clearscope Actor UpdateTesteeField( int fieldindex ) {
		Actor curTestee = NULL;

		if ( Testee[ fieldindex ] && Testee[ fieldindex ].mo )
			curTestee = Testee[ fieldindex ].mo;

		// Updating info actors type. Usually it's better not to cross the 
		//ui, data and play scopes in one method...
		if ( curTestee is "StateProvider" && PlayerPawn( Inventory( curTestee ).owner ) ) {
			Testee[ fieldindex ].mo = curTestee = PlayerPawn( Inventory( curTestee ).owner ).player.ReadyWeapon;
			Testee[ fieldindex ].actorType = IAT_StateProvider;
		} else {
			Testee[ fieldindex ].actorType = IAT_Normal;
		}

		return curTestee;
	}




	override void RenderOverlay( RenderEvent e ) {
		// User CVars locating uses a relatively long algorithm. After a 
		//while I'll optimize them and move somewhere.
		Array<ZCBaseInfoPanelPart> infoPanelParts;
		PlayerInfo pl = players[ consoleplayer ];

		panels.UpdateFont();

		for ( int iCurInfoPanel = 0; iCurInfoPanel < panels.curPanels.Size(); iCurInfoPanel++ ) {
			ZCInfoPanelNode panelnode = panels.curPanels.nodes[ iCurInfoPanel ];

			if ( panelnode.panelCVar && panelnode.panelCVar.GetBool() )
				infoPanelParts.Push( panelnode.panel );
		}

		double infopanelStartX = CVar.FindCVar( "mcm_zchecker_infopanel_startx" ).GetFloat();
		double infopanelStartY = CVar.FindCVar( "mcm_zchecker_infopanel_starty" ).GetFloat();
		double infopanelScale = CVar.FindCVar( "mcm_zchecker_infopanel_scale" ).GetFloat();
		double infopanelOffsetX = CVar.FindCVar( "mcm_zchecker_infopanel_offsetx" ).GetFloat();
		double infopanelPartsSpaceY = CVar.FindCVar( "mcm_zchecker_infopanelparts_y_gap" ).GetFloat();

		// Thanks to m8f for the "drawTextCenter()" function code from its "Hellscape Navigator".
		double bordersXMargin = 4.0;
		double scale = 1.0 / infopanelScale;

		int height = int( scale * Screen.GetHeight() );
		int width = int( scale * Screen.GetWidth() );

		int fontSymbolHeight = panels.infopanelsFont.GetHeight() + 1;

		for ( int i = 0; i < MaxTestee; i++ ) {
			Actor curTestee = UpdateTesteeField( i );

			if ( !curTestee )
				continue;

			double starty = infopanelStartY * 0.01 * height;
			double y = starty;
			double x = infopanelStartX * 0.01 + i * infopanelOffsetX * 0.01;
			x *= width;

			double maxStringWidth = 0.0;


			// Forming a full information panel:
			Array<String> panelsstr;
			panelsstr.Clear();

			for ( int j = 0; j < infoPanelParts.Size(); j++ ) {
				String outStr = "\c-";

				if ( infoPanelParts[ j ].IsPlayScope() )
					outStr = outStr .. ZCBaseInfoPanelPart_PlayScope( infoPanelParts[ j ] ).InternalGetInfo_clearscope( i ) .. "\n";
				else
					outStr = outStr .. infoPanelParts[ j ].GetInfo( curTestee, Testee[ i ] ) .. "\n";

				panelsstr.Push( outstr );

				double stringWidth = panels.infopanelsFont.StringWidth( outStr );

				// Push the text out from the borders:
				if ( x < bordersXMargin )
					x = bordersXMargin;
				else if ( x > width - stringWidth - bordersXMargin )
					x = width - stringWidth - bordersXMargin;

				if ( maxStringWidth < stringWidth )
					maxStringWidth = stringWidth;
			}

			// Printing infopanels parts:
			int panelsstrAmount = panelsstr.Size();

			for ( int j = 0; j < panelsstrAmount; j++ ) {
				Screen.DrawText( panels.infopanelsFont, Font.CR_GRAY, x, y, panelsstr[ j ],
								DTA_KeepRatio, true, DTA_VirtualWidth, width, DTA_VirtualHeight, height );

				// Adding an Y-offset for the next panel part:
				int newlinesAmount = 0;
				int nextNewlinePos = -1;

				while ( -1 != ( nextNewlinePos = panelsstr[ j ].IndexOf( "\n", nextNewlinePos + 1 ) ) )
					newlinesAmount++;

				y += fontSymbolHeight * ( newlinesAmount + infopanelPartsSpaceY );
			}

			/*if ( panelsstrAmount ) {
				//native static void Dim(Color col, double amount, int x, int y, int w, int h);
				Screen.Dim( 0x000000, 0.5, int( x ), int( starty ), int( maxStringWidth * CleanXFac ), int( ( y - starty ) * CleanYFac ) );
			}*/
		} // of for ( int i = 0; i < MaxTestee; i++ ) {}

		Super.RenderOverlay( e );
	} // of override void RenderOverlay( RenderEvent e ) {}


	private String argColored( int value ) {
		return ( value == 0? TEXTCOLOR_DARKBROWN : TEXTCOLOR_CREAM ) .. value;
	}

	override void NetworkProcess( ConsoleEvent e ) {
		// ZChecker CCMDs parsing:
		String ccmdName = zcCCMDInfo.InitFromEvent( e );

		if ( ccmdName ~== "zc_update_panels_order" ) {
			if ( zcCCMDInfo.args.Size() == 1 ) {
				panels.panelsstr = zcCCMDInfo.args[ 0 ];
				panels.UpdatePanels();
				panels.InitSetPanelsorderCVar( zcCCMDInfo.args[ 0 ] );
			} else {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::NetworkProcess(). Updating panels order netevent has wrong amount of arguments (must be 1, got " .. zcCCMDInfo.args.Size() .. ")." );
				ZCGlobal.Log( LL_Main, GetClassName() .. "::NetworkProcess(). Name: \"" .. TEXTCOLOR_TAN .. e.Name .. "\c-\"." );
			}

			Super.NetworkProcess( e );
			return;
		}

		if ( multiplayer && ccmdName ~== "zc_multiplayer_synctest" && e.args[ 1 ] != consoleplayer ) {
			if ( zcCCMDInfo.args.Size() == 1 ) {
				uint testeePos = e.args[ 0 ];
				uint srcPlayer = e.args[ 1 ];

				bool argerror = false;

				if ( testeePos >= MaxTestee ) {
					argerror = true;
					ZCGlobal.Log( LL_Emergency, GetClassName() .. "::NetworkProcess(). Multiplayer sync netevent: wrong position " .. testeePos .. " to compare." );
				}

				if ( srcPlayer >= MAXPLAYERS ) {
					argerror = true;
					ZCGlobal.Log( LL_Emergency, GetClassName() .. "::NetworkProcess(). Multiplayer sync netevent: wrong source player #" .. srcPlayer .. "." );
				}

				if ( !argerror ) {
					Testee[ testeePos ].asyncwith = ( ( Testee[ testeePos ].hashsync[ srcPlayer ] == zcCCMDInfo.args[ 0 ] )? 0 : srcPlayer + 1 );
				}

			} else {
				ZCGlobal.Log( LL_Emergency, GetClassName() .. "::NetworkProcess(). Multiplayer sync netevent has wrong amount of arguments (must be 3, got " .. zcCCMDInfo.args.Size() .. ")." );
				ZCGlobal.Log( LL_Main, GetClassName() .. "::NetworkProcess(). Name: \"" .. TEXTCOLOR_TAN .. e.Name .. "\c-\"." );
			}

			Super.NetworkProcess( e );
			return;
		}

		// Just a debug NetworkProcess() output.
		if ( ZCGlobal.Get().zcCurLogLevel >= LL_Debug ) {
			String debugstr = GetClassName() .. "::NetworkProcess(). CCMD: \"" .. ccmdName .. "\"";

			if ( zcCCMDInfo.args.Size() != 0 ) {
				for ( int i = 0; i < zcCCMDInfo.args.Size(); i++ )
					debugstr.AppendFormat( " [" .. TEXTCOLOR_DARKGREEN .. "#%i: \"%s\"" .. LLCOLOR_DEBUG .. "]", i + 1, zcCCMDInfo.args[ i ] );
			} else {
				debugstr = debugstr .. ", no arguments.";
			}

			ZCGlobal.ClearscopeLog( LL_Debug, debugstr );
		}

		int interceptNeteventsMode = clamp( CVar.GetCVar( "mcm_zchecker_specinfo_netevents", players[ e.Player ] ).GetInt(), 0, 3 );

		// Polling ZChecker CCMD handlers by stored netevent name:
		for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {
			if ( !( zcConsoleHandleClasses[ i ] is 'ZCConsoleCommand' ) )
				continue; // Skipping tooltips.

			ZCConsoleCommand curCCMD = ZCConsoleCommand( zcConsoleHandleClasses[ i ] );

			if ( ccmdName ~== curCCMD.GetCommand() ) {
				curCCMD.ccmd = zcCCMDInfo;

				if ( curCCMD.HandleArguments() ) {
					curCCMD.DoCommand();
				} else {
					ZCGlobal.Log( LL_Normal | LL_NoPrefix, TEXTCOLOR_YELLOW .. "Usage" .. LLCOLOR_MAIN .. ":\n" .. curCCMD.GetHelpString() );
				}

				interceptNeteventsMode = 0;
				break;
			}
		} // of for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {}

		if ( interceptNeteventsMode ) {
			String outstr = "";

			if ( interceptNeteventsMode == 3 )
				outstr = TEXTCOLOR_GRAY .. ( e.IsManual? "Manual" : "System" ) .. TEXTCOLOR_DARKGRAY .. " netevent ";
			else
				outstr = TEXTCOLOR_DARKGRAY .. "Netevent ";

			// Compatibility between all *ZDoom versions:
			int compatTicRate = max( Thinker.Tics2Seconds( 350000 ), 1 );
			compatTicRate = int( 350000 / compatTicRate );

			if ( interceptNeteventsMode >= 2 )
				outstr.AppendFormat( "at %s.%02i ", level.TimeFormatted(), int( floor( ( level.time % compatTicRate ) / double( compatTicRate ) * 100.0 ) ) );

			String ARGSSEP = TEXTCOLOR_DARKGRAY .. "/" .. TEXTCOLOR_CREAM;

			outstr.AppendFormat( "\"" .. TEXTCOLOR_LIGHTBLUE .. e.Name .. " " .. TEXTCOLOR_CREAM .. "%s%s%s%s%s" .. TEXTCOLOR_DARKGRAY .. "\"",
								argColored( e.args[ 0 ] ), ARGSSEP, argColored( e.args[ 1 ] ), ARGSSEP, argColored( e.args[ 2 ] ) );

			if ( interceptNeteventsMode == 3 )
				outstr = outstr .. " from player #" .. TEXTCOLOR_WHITE .. e.Player;

			ZCGlobal.Log( LL_Normal, outstr );
		} // of if ( interceptNeteventsMode ) {}


		Super.NetworkProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {}


	override void WorldTick() {
		if ( ( gamestate == GS_LEVEL || gamestate == GS_DEMOSCREEN ) && !( level.maptime % 5 ) )
			globalclass.UpdateLogLevel();

		// ACS works only in the play scope.
		panels.TickSetPanelsorderCVar();

		for ( int i = 0; i < panels.curPanels.PlayscopedSize(); i++ ) {
			ZCBaseInfoPanelPart_PlayScope playpanel = ZCBaseInfoPanelPart_PlayScope( panels.curPanels.playnodes[ i ].panel );

			for ( int j = 0; j < MaxTestee; j++ ) {
				Actor curTestee = UpdateTesteeField( j );

				if ( curTestee )
					playpanel.playscopedInfo[ j ] = playpanel.GetInfo_play( curTestee, Testee[ j ] );
			}
		}

		Super.WorldTick();

		// Test for asynchronous actors:
		int playernum = ( level.maptime % MAXPLAYERS );

		if ( multiplayer && playeringame[ playernum ] ) {
			if ( playernum == consoleplayer ) {
				for ( int i = 0; i < MaxTestee; i++ ) {
					// Warning! Hash may generate a format specifier ("%s" etc). Do not use any "printf()" output!
					EventHandler.SendNetworkEvent( "zc_multiplayer_synctest" .. ZCHECKER_AGRS_SEPARATOR .. Testee[ i ].GetHash(), i, consoleplayer );
				}
			} else {
				for ( int i = 0; i < MaxTestee; i++ )
					Testee[ i ].UpdateHash( playernum );
			}

			//for ( int i = 0; i < MaxTestee; i++ )
			//	console.printf( GetClassName() .. "::WorldTick(). ZCheckerField[ " .. i .. " ]: \"" .. Testee[ i ].GetHash() .. "\"" );
		}
	} // of override void WorldTick() {}

	override void WorldLoaded( WorldEvent e ) {
		globalclass = ZCGlobal.Get();
		globalclass.InitZCheckerHandler( self );

		globalclass.SetZCheckerString( "$1", "" );
		globalclass.SetZCheckerString( "$2", "" );
		globalclass.SetZCheckerString( "$3", "" );
		globalclass.SetZCheckerString( "$last", "" );

		if ( panels.panelsorderChanged )
			panels.UpdatePanels( true );

		//ACS_Execute( -int( 'ZChecker_Create_ACS_Thinker' ), 0 );

		Super.WorldLoaded( e );
	}

} // of class ZCheckerHandler: EventHandler {}

