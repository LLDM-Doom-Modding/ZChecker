version "2.4.0"

#include "ZScript/ZCMapScripts.zsc"
#include "ZScript/ZCBaseClasses.zsc"

#include "ZScript/ZCCommandsGeneral.zsc"
#include "ZScript/ZCCommandsActorAlter.zsc"
#include "ZScript/ZCCommandsMap.zsc"

#include "ZScript/ZCInfoPanelMain.zsc"
#include "ZScript/ZCInfoPanelPointers.zsc"
#include "ZScript/ZCInfoPanelOther.zsc"


const MaxTestee = 3;
const ZCheckerVersion = "0.63";

// AutoAmbient: 0x7FAA0004.
const ZCheckerHandlerOrder = 0x7FAA0005;
const ZCheckerMapHandlerOrder = 0x7FAA0006;


/*enum EZCheckerFieldFlags {
	ZCF_Main		= 0x0001,
	ZCF_Extended	= 0x0002, // Position, velocity, args, special, TIDs...
	ZCF_Inventory	= 0x0004,
	ZCF_States		= 0x0008, // States and frames.
	ZCF_Friends		= 0x0010, // "FriendPlayer", "HitFriend()", "DesignatedTeam", ...
	ZCF_Visual		= 0x0020,
	ZCF_Sectors		= 0x0040, // "floorsector", "ceilingsector", ...
	ZCF_Interaction	= 0x0080, // "BlockingMobj", "BlockingLine", "Master", "Target", "LastHeard", "LastLookPlayerNumber", ...
	ZCF_OtherActors	= 0x0100, // "snext", "Alternative", "goal", "Poisoner", "TelefogSourceType", ...
	ZCF_Other		= 0x0200, // "PainThreshold", "WoundHealth", ...
	ZCF_Code		= 0x0400
}*/

enum EZCheckerLogLevels {
	LL_Emergency = 0,
	LL_General = 1,
	LL_Detailed,
	LL_Debug,

	LL_Common = LL_General,
	LL_Normal = LL_General,
	LL_Main = LL_General,
	LL_Extended = LL_Detailed,

	LL_NoPrefix = 0x8000
}

const LLCOLOR_MAIN = "\c-";
const LLCOLOR_DEBUG = TEXTCOLOR_DARKGRAY;
const LLCOLOR_EMERGENCY = TEXTCOLOR_FIRE;

const CCMDCOLOR_TITLE = TEXTCOLOR_GREEN;
const CCMDCOLOR_TITLEWIP = TEXTCOLOR_DARKGRAY;
const CCMDCOLOR_DESC = "\c-";


class ZCGlobal: Thinker {
	int zcCurLogLevel;

	static void UpdateLogLevel( void ) {
		ZCGlobal.Get().zcCurLogLevel = CVar.FindCVar( "mcm_zchecker_loglevel" ).GetInt();
	}

	static play ZCGlobal Get( void ) {
		ZCGlobal it = ZCGlobal( ThinkerIterator.Create( "ZCGlobal", STAT_STATIC ).Next() );

		if ( !it ) {
			// Creating and initializating a singleton global object:
			it = new( "ZCGlobal" );
			it.ChangeStatNum( STAT_STATIC );
			UpdateLogLevel(); // This one calls "Get()" again, yeah...
		}

		return it;
	} // of static play ZCGlobal Get( void ) {

	// Prints well-decorated information string:
	static clearscope void ClearscopeLog( EZCheckerLogLevels loglevel, String text ) {
		String logPrefix = "";

		if ( !( loglevel & LL_NoPrefix ) ) {
			switch ( loglevel & ~LL_NoPrefix ) {
				case LL_Debug:
					logPrefix = LLCOLOR_DEBUG .. "[ZC Debug] ";
					break;
				case LL_Emergency:
					logPrefix = TEXTCOLOR_RED .. "[ZChecker emergency] " .. LLCOLOR_EMERGENCY;
					break;
				default:
					logPrefix = TEXTCOLOR_GRAY .. "[ZC] " .. LLCOLOR_MAIN;
					break;
			} // of switch ( loglevel & ~LL_NoPrefix ) {
		} // of if ( !( loglevel & LL_NoPrefix ) ) {

		console.printf( logPrefix .. text .. ( text.Mid( text.Length() - 1 ) == "."? "" : "." ) );
	} // of static clearscope void ClearscopeLog( EZCheckerLogLevels loglevel, String text ) {

	// A play-scope wrapper around a data-scope method (mostly used):
	static play void Log( EZCheckerLogLevels loglevel, String text ) {
		if ( ZCGlobal.Get().zcCurLogLevel >= ( loglevel & ~LL_NoPrefix ) )
			ClearscopeLog( loglevel, text );
	}

	// Test for the special ZChecker level:
	static clearscope bool IsEverythingLevel( void ) {
		// Got from "mapchecksum everything" CCMD:
		//return level.GetChecksum() ~== "8FBB774BE1D239B5C7CB514DF9B41A2E" || ( CVar.FindCVar( "mcm_zchecker_forceevmap" ).GetBool() );

		//console.printf( "level.mapname: \"" .. level.mapname .. "\", level.levelname: \"" .. level.levelname .. "\"" );
		return ( level.mapname ~== "EVERYTHING" ) || ( level.mapname ~== "EVERYTHING_SIMPLED" )
			|| ( CVar.FindCVar( "mcm_zchecker_ev_forcemap" ).GetBool() );
	}


    static clearscope String squeezeVector2( vector2 vec ) {
        return "(" .. int( vec.x ) .. ", " .. int( vec.y ) .. ")";
    }

    static clearscope String squeezeVector3( vector3 vec ) {
        return "(" .. int( vec.x ) .. ", " .. int( vec.y ) .. ", " .. int( vec.z ) .. ")";
    }

} // of class ZCGlobal: Thinker {



class ZCheckerHandler: StaticEventHandler {
	private Array<ZCConsoleClass> zcConsoleHandleClasses;
	private Array<ZCBaseInfoPanelPart> zcInfoPanelClasses;

	// It's impossible to avoid unloading actors (and pointers to them) from 
	//memory on level reloading. Or I don't know something.
	ZCheckerField Testee[ MaxTestee ];

	ZCheckerCCMDInfo zcCCMDInfo;
	transient Font zcInfoPanelFont;

	// Especially for ZCHelp:
	ZCConsoleClass GetZCConsoleClass( int index ) {
		ZCConsoleClass ccmd = NULL;

		if ( index >= 0 && index < zcConsoleHandleClasses.Size() ) {
			ccmd = zcConsoleHandleClasses[ index ];
			ZCGlobal.Log( LL_Debug, GetClassName() .. "::GetZCConsoleCommand(). CCMD #" .. index .. " is \"" .. zcConsoleHandleClasses[ index ] .. "\"." );
		}

		return ccmd;
	} // of ZCConsoleClass GetZCConsoleClass( int index ) {


	private void addConsoleClass( class<ZCConsoleClass> classname, bool importantFlag = false ) {
		zcConsoleHandleClasses.push( ZCConsoleClass.Create( classname, importantFlag ) );
	}
	private void addConsoleSeparator( bool importantFlag = false ) {
		zcConsoleHandleClasses.push( ZCConsoleClass.Create( 'ZCConsoleSeparator', importantFlag ) );
	}

	private void addInfoPanelClass( class<ZCBaseInfoPanelPart> classname ) {
		ZCBaseInfoPanelPart newPanelPart = ZCBaseInfoPanelPart.Create( classname, self );
		zcInfoPanelClasses.push( newPanelPart );
	}

	override void OnRegister() {
		SetOrder( ZCheckerHandlerOrder );

		//console.printf( "ZCGlobal.Get(): " .. ZCGlobal.Get() .. ", zcCurLogLevel: " .. ZCGlobal.Get().zcCurLogLevel );
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::OnRegister(). ZChecker initializes..." );

		for ( int i = 0; i < MaxTestee; i++ ) {
			Testee[ i ] = new( 'ZCheckerField' );
			Testee[ i ].inv = new( 'ZCheckerInvField' );
		}

		zcCCMDInfo = new( 'ZCheckerCCMDInfo' );
		zcCCMDInfo.handler = self;

		zcInfoPanelFont = Font.FindFont( "smallfont" );

		//
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::OnRegister(). Creating console classes handlers..." );
		addConsoleClass( 'ZCHelpCommand', true );
		addConsoleClass( 'ZCAddCommand', true );
		addConsoleClass( 'ZCRemCommand', true );
		addConsoleClass( 'ZCSetStateCommand' );
		addConsoleClass( 'ZCSetFlagCommand' );
		addConsoleClass( 'ZCBuddhaCommand' );
		addConsoleClass( 'ZCGiveCommand' );
		addConsoleClass( 'ZCTakeCommand' );
		addConsoleClass( 'ZCSummonCommand' );
		addConsoleClass( 'ZCActorActionCommand' );

		addConsoleSeparator( true );
		addConsoleClass( 'ZCEvmapCommand', true );
		addConsoleClass( 'ZCEvmapCommand_goto' );
		addConsoleClass( 'ZCEvmapCommand_pause' );
		addConsoleClass( 'ZCEvmapCommand_recreate', true );

		for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ )
			zcConsoleHandleClasses[ i ].PostBeginPlay();

		//
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::OnRegister(). Creating information panels..." );
		addInfoPanelClass( 'ZCMainInfoPanel' );
		addInfoPanelClass( 'ZCWorldPositionInfoPanel' );
		addInfoPanelClass( 'ZCSpecialsArgsInfoPanel' );
		addInfoPanelClass( 'ZCInventoryInfoPanel' );
		addInfoPanelClass( 'ZCStatesInfoPanel' );
		addInfoPanelClass( 'ZCPlayersInfoPanel' );
		addInfoPanelClass( 'ZCCommonPointersInfoPanel' );
		addInfoPanelClass( 'ZCInteractionPointersInfoPanel' );

		//addInfoPanelClass( 'ZCVisualInfoPanel' );
		//addInfoPanelClass( 'ZCSectorsInfoPanel' );
		//addInfoPanelClass( 'ZCOtherActorsInfoPanel' );
		//addInfoPanelClass( 'ZCOtherInfoPanel' );

		ZCGlobal.Log( LL_Detailed, GetClassName() .. "::OnRegister(). ZChecker initialized successfully. " .. zcConsoleHandleClasses.Size() .. " console classes, " .. zcInfoPanelClasses.Size() .. " info panel classes." );

		Super.OnRegister();
	}

	override void RenderOverlay( RenderEvent e ) {
		for ( int i = 0; i < MaxTestee; i++ ) {
			if ( !Testee[ i ] || !Testee[ i ].mo )
				continue;

			Actor curTestee = Testee[ i ].mo;
			String outStr = "";

			PlayerInfo pl = players[ consoleplayer ];

			for ( int iCurInfoPanel = 0; iCurInfoPanel < zcInfoPanelClasses.Size(); iCurInfoPanel++ ) {
				ZCBaseInfoPanelPart panel = zcInfoPanelClasses[ iCurInfoPanel ];
				CVar curInfoPanelCVar = CVar.GetCVar( panel.GetCVarName(), pl );

				if ( !curInfoPanelCVar ) {
					ZCGlobal.ClearscopeLog( LL_Emergency, "Info panel class \"" .. TEXTCOLOR_RED .. panel.GetClassName() .. LLCOLOR_EMERGENCY .. "\" has no user CVar \"" .. TEXTCOLOR_RED .. panel.GetCVarName() .. LLCOLOR_EMERGENCY .."\"." );
				} else if ( curInfoPanelCVar.GetBool() ) {
					outStr = outStr .. "\c-" .. panel.GetInfo( curTestee, i ) .. "\n";
				}
			}

			// Thanks to m8f for the "drawTextCenter()" function code from "Hellscape Navigator".

			double bordersXMargin = 4.0;
			double scale = 1.0 / CVar.FindCVar( "mcm_zchecker_infopanel_scale" ).GetFloat();
			double x = CVar.FindCVar( "mcm_zchecker_infopanel_startx" ).GetFloat() * 0.01 + i * CVar.FindCVar( "mcm_zchecker_infopanel_offsetx" ).GetFloat() * 0.01;
			double y = CVar.FindCVar( "mcm_zchecker_infopanel_starty" ).GetFloat() * 0.01;

			int width = int( scale * Screen.GetWidth() );
			int height = int( scale * Screen.GetHeight() );
			double stringWidth = zcInfoPanelFont.StringWidth( outStr );

			x = ( width * x ) - stringWidth / 2;
			y *= height;

			// Push the text out from the borders:
			if ( x < bordersXMargin )
				x = bordersXMargin;
			else if ( x > width - stringWidth - bordersXMargin )
				x = width - stringWidth - bordersXMargin;

			Screen.DrawText( zcInfoPanelFont, Font.CR_GRAY, x, y, outStr,
							DTA_KeepRatio, true, DTA_VirtualWidth, width, DTA_VirtualHeight, height );
		} // of for ( int i = 0; i < MaxTestee; i++ ) {

		Super.RenderOverlay( e );
	} // of override void RenderOverlay( RenderEvent e ) {


	override void NetworkProcess( ConsoleEvent e ) {
		// ZChecker CCMDs parsing:
		String ccmdName = zcCCMDInfo.InitFromEvent( e );

		if ( ZCGlobal.Get().zcCurLogLevel == LL_Debug ) {
			ZCGlobal.Log( LL_Debug, GetClassName() .. "::NetworkProcess(). CCMD name: " .. ccmdName .. ". Has " .. zcConsoleHandleClasses.Size() .. " available commands." );

			for ( int i = 0; i < zcCCMDInfo.args.Size(); i++ )
				ZCGlobal.Log( LL_Debug, GetClassName() .. "::NetworkProcess(). CCMD arg " .. i + 1 .. ": " .. zcCCMDInfo.args[ i ] );
		}

		// Polling ZChecker CCMD handlers by stored netevent name:
		for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {
			if ( !( zcConsoleHandleClasses[ i ] is 'ZCConsoleCommand' ) )
				continue;

			ZCConsoleCommand curCCMD = ZCConsoleCommand( zcConsoleHandleClasses[ i ] );

			if ( ccmdName ~== curCCMD.GetCommand() ) {
				if ( curCCMD.HandleArguments( zcCCMDInfo ) )
					curCCMD.DoCommand();
				else
					ZCGlobal.Log( LL_Normal | LL_NoPrefix, TEXTCOLOR_YELLOW .. "Usage\c-:\n" .. curCCMD.GetHelpString() );

				break;
			}
		} // of for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {

		Super.NetworkProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {


	override void WorldTick() {
		if ( ( gamestate == GS_LEVEL || gamestate == GS_DEMOSCREEN ) && !( level.maptime % 5 ) )
			ZCGlobal.UpdateLogLevel();

		Super.WorldTick();
	} // of override void WorldTick() {

} // of class ZCheckerHandler: EventHandler {
