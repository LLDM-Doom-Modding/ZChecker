version "2.4.0"

#include "ZScript/ZCMapScripts.zsc"
#include "ZScript/ZCBaseClasses.zsc"

#include "ZScript/ZCCommandsGeneral.zsc"
#include "ZScript/ZCCommandsActorAlter.zsc"
#include "ZScript/ZCCommandsMap.zsc"
#include "ZScript/ZCInfoPanel.zsc"


const MaxTestee = 3;
const ZCheckerVersion = "0.6c_nightly";

// AutoAmbient: 0x7FAA0004.
const ZCheckerHandlerOrder = 0x7FAA0005;
const ZCheckerMapHandlerOrder = 0x7FAA0006;


const ZCToggle = "ZCToggle";
const ZCAdd = "ZCAdd";
const ZCRem = "ZCRem";
const ZCBud = "ZCBud";
const ZCAddSelf = "ZCAddSelf";
const ZCAddWeap = "ZCAddWeap";

const ZCHelp = "ZCHelp";

enum EZCheckerFieldFlags {
	ZCF_Main		= 0x0001,
	ZCF_Extended	= 0x0002, // Position, velocity, args, special, TIDs...
	ZCF_Inventory	= 0x0004,
	ZCF_States		= 0x0008, // States and frames.
	ZCF_Friends		= 0x0010, // "FriendPlayer", "HitFriend()", "DesignatedTeam", ...
	ZCF_Visual		= 0x0020,
	ZCF_Sectors		= 0x0040, // "floorsector", "ceilingsector", ...
	ZCF_Interaction	= 0x0080, // "BlockingMobj", "BlockingLine", "Master", "Target", "LastHeard", "LastLookPlayerNumber", ...
	ZCF_OtherActors	= 0x0100, // "snext", "Alternative", "goal", "Poisoner", "TelefogSourceType", ...
	ZCF_Other		= 0x0200, // "PainThreshold", "WoundHealth", ...
	ZCF_Code		= 0x0400
}

enum EZCheckerFieldTypes {
	ZCT_Actor = 0,
	ZCT_StateProvider,
	ZCT_Player,
	ZCT_
}

enum EZCheckerLogLevels {
	LL_Emergency = 0,
	LL_General = 1,
	LL_Detailed,
	LL_Debug,

	LL_Common = LL_General,
	LL_Normal = LL_General,
	LL_Main = LL_General,
	LL_Extended = LL_Detailed,

	LL_NoPrefix = 0x8000
}

const LLCOLOR_MAIN = "\c-";
const LLCOLOR_DEBUG = TEXTCOLOR_DARKGRAY;
const LLCOLOR_EMERGENCY = TEXTCOLOR_FIRE;

const CCMDCOLOR_TITLE = TEXTCOLOR_GREEN;
const CCMDCOLOR_TITLEWIP = TEXTCOLOR_DARKGRAY;
const CCMDCOLOR_DESC = "\c-";


class ZCGlobal: Thinker {
	int zcCurLogLevel;

	static void UpdateLogLevel( void ) {
		ZCGlobal.Get().zcCurLogLevel = CVar.FindCVar( "mcm_zchecker_loglevel" ).GetInt();
	}

	static play ZCGlobal Get( void ) {
		ZCGlobal it = ZCGlobal( ThinkerIterator.Create( "ZCGlobal", STAT_STATIC ).Next() );

		if ( !it ) {
			// Creating and initializating a singleton global object:
			it = new( "ZCGlobal" );
			it.ChangeStatNum( STAT_STATIC );
			it.UpdateLogLevel(); // This one calls "Get()" again, yeah...
		}

		return it;
	} // of static play ZCGlobal Get( void ) {

	// Prints well-decorated information string:
	static clearscope void ClearscopeLog( EZCheckerLogLevels loglevel, String text ) {
		String logPrefix = "";

		if ( !( loglevel & LL_NoPrefix ) ) {
			switch ( loglevel & ~LL_NoPrefix ) {
				case LL_Debug:
					logPrefix = LLCOLOR_DEBUG .. "[ZC Debug] ";
					break;
				case LL_Emergency:
					logPrefix = TEXTCOLOR_RED .. "[ZChecker emergency] " .. LLCOLOR_EMERGENCY;
					break;
				default:
					logPrefix = TEXTCOLOR_GRAY .. "[ZC] " .. LLCOLOR_MAIN;
					break;
			} // of switch ( loglevel & ~LL_NoPrefix ) {
		} // of if ( !( loglevel & LL_NoPrefix ) ) {

		console.printf( logPrefix .. text .. ( text.Mid( text.Length() - 1 ) == "."? "" : "." ) );
	} // of static clearscope void ClearscopeLog( EZCheckerLogLevels loglevel, String text ) {

	// A play-scope wrapper around a data-scope method (mostly used):
	static play void Log( EZCheckerLogLevels loglevel, String text ) {
		if ( ZCGlobal.Get().zcCurLogLevel >= ( loglevel & ~LL_NoPrefix ) )
			ClearscopeLog( loglevel, text );
	}

	// Test for the special ZChecker level:
	static clearscope bool IsEverythingLevel( void ) {
		// Got from "mapchecksum everything" CCMD:
		//return level.GetChecksum() ~== "8FBB774BE1D239B5C7CB514DF9B41A2E" || ( CVar.FindCVar( "mcm_zchecker_forceevmap" ).GetBool() );

		//console.printf( "level.mapname: \"" .. level.mapname .. "\", level.levelname: \"" .. level.levelname .. "\"" );
		return ( ( level.mapname ~== "EVERYTHING" ) && ( level.levelname == "ZChecker: Everything" ) )
			|| ( CVar.FindCVar( "mcm_zchecker_ev_forcemap" ).GetBool() );
	}

} // of class ZCGlobal: Thinker {



class ZCheckerHandler: EventHandler {
	private Array<ZCConsoleClass> zcConsoleHandleClasses;
	private Array<ZCBaseInfoPanelPart> zcInfoPanelClasses;

	ZCheckerField Testee[ MaxTestee ];
	ZCheckerCCMDInfo zcCCMDInfo;

	Font ZCheckerInfoPanelFont;

	// Especially for ZCHelp:
	ZCConsoleClass GetZCConsoleClass( int index ) {
		ZCConsoleClass ccmd = NULL;

		if ( index >= 0 && index < zcConsoleHandleClasses.Size() ) {
			ccmd = zcConsoleHandleClasses[ index ];
			ZCGlobal.Log( LL_Debug, GetClassName() .. "::GetZCConsoleCommand(). CCMD #" .. index .. " is \"" .. zcConsoleHandleClasses[ index ] .. "\"." );
		}

		return ccmd;
	} // of ZCConsoleClass GetZCConsoleClass( int index ) {


	private void addConsoleClass( class<ZCConsoleClass> classname, bool importantFlag = false ) {
		zcConsoleHandleClasses.push( ZCConsoleClass.Create( classname, importantFlag ) );
	}
	private void addConsoleSeparator( bool importantFlag = false ) {
		zcConsoleHandleClasses.push( ZCConsoleClass.Create( 'ZCConsoleSeparator', importantFlag ) );
	}

	private void addInfoPanelClass( class<ZCBaseInfoPanelPart> classname ) {
		ZCBaseInfoPanelPart newPanelPart = ZCBaseInfoPanelPart( new( classname ) );
		zcInfoPanelClasses.push( newPanelPart );
	}


	override void OnRegister() {
		SetOrder( ZCheckerHandlerOrder );

		//console.printf( "ZCGlobal.Get(): " .. ZCGlobal.Get() .. ", zcCurLogLevel: " .. ZCGlobal.Get().zcCurLogLevel );
		ZCGlobal.Log( LL_Debug, GetClassName() .. "::OnRegister(). ZChecker initializes..." );

		for ( int i = 0; i < MaxTestee; i++ ) {
			Testee[ i ] = new( 'ZCheckerField' );
			Testee[ i ].inv = new( 'ZCheckerInvField' );
		}

		zcCCMDInfo = new( 'ZCheckerCCMDInfo' );
		zcCCMDInfo.handler = self;

		ZCheckerInfoPanelFont = Font.FindFont( "smallfont" );


		ZCGlobal.Log( LL_Debug, GetClassName() .. "::OnRegister(). Creating console classes handlers..." );

		// 
		addConsoleClass( 'ZCHelpCommand', true );
		addConsoleClass( 'ZCAddCommand', true );
		addConsoleClass( 'ZCRemCommand', true );
		addConsoleClass( 'ZCSetStateCommand' );
		addConsoleClass( 'ZCBuddhaCommand' );
		addConsoleClass( 'ZCToggleFlagCommand' );
		addConsoleClass( 'ZCGiveCommand' );
		addConsoleClass( 'ZCTakeCommand' );
		addConsoleClass( 'ZCActorActionCommand' );

		addConsoleSeparator( true );
		addConsoleClass( 'ZCEvmapCommand', true );
		addConsoleClass( 'ZCEvmapCommand_goto' );
		addConsoleClass( 'ZCEvmapCommand_pause' );
		addConsoleClass( 'ZCEvmapCommand_recreate', true );

		//
		addInfoPanelClass( 'ZCMainInfoPanel' );
		addInfoPanelClass( 'ZCExtendedInfoPanel' );
		addInfoPanelClass( 'ZCInventoryInfoPanel' );
		addInfoPanelClass( 'ZCStatesInfoPanel' );
		addInfoPanelClass( 'ZCFriendsInfoPanel' );
		//addInfoPanelClass( 'ZCVisualInfoPanel' );
		//addInfoPanelClass( 'ZCSectorsInfoPanel' );
		//addInfoPanelClass( 'ZCInteractionInfoPanel' );
		//addInfoPanelClass( 'ZCOtherActorsInfoPanel' );
		//addInfoPanelClass( 'ZCOtherInfoPanel' );


		ZCGlobal.Log( LL_Debug, GetClassName() .. "::OnRegister(). ZChecker initialized successfully." );

		Super.OnRegister();
	}

	override void RenderOverlay( RenderEvent e ) {
		//if ( !CVar.GetCVar( "mcm_zchecker_enabled" ).GetBool() )
		//	return;

		for ( int i = 0; i < MaxTestee; i++ ) {
			if ( !Testee[ i ] || !Testee[ i ].mo )
				continue;

			Actor curTestee = Testee[ i ].mo;
			String outStr = "";

			for ( int iCurInfoPanel = 0; iCurInfoPanel < zcInfoPanelClasses.Size(); iCurInfoPanel++ ) {
				CVar curInfoPanelCVar = CVar.GetCVar( zcInfoPanelClasses[ iCurInfoPanel ].GetCVarName() );

				if ( curInfoPanelCVar && curInfoPanelCVar.GetBool() ) {
					outStr = outStr .. zcInfoPanelClasses[ iCurInfoPanel ].GetInfo( curTestee, i );
				}
			}

			Screen.DrawText( ZCheckerInfoPanelFont, Font.CR_GRAY, 5 + ( 220 * i ), 30, 
							outStr, DTA_VirtualWidth, 640, DTA_VirtualHeight, 480 );
		} // of for ( int i = 0; i < MaxTestee; i++ ) {

		Super.RenderOverlay( e );
	} // of override void RenderOverlay( RenderEvent e ) {



	override void NetworkProcess( ConsoleEvent e ) {
		// ZChecker CCMDs parsing:
		String ccmdName = zcCCMDInfo.InitFromEvent( e );

		if ( ZCGlobal.Get().zcCurLogLevel == LL_Debug ) {
			ZCGlobal.Log( LL_Debug, GetClassName() .. "::NetworkProcess(). CCMD name: " .. ccmdName );

			for ( int i = 0; i < zcCCMDInfo.args.Size(); i++ )
				ZCGlobal.Log( LL_Debug, GetClassName() .. "::NetworkProcess(). CCMD arg " .. i + 1 .. ": " .. zcCCMDInfo.args[ i ] );
		}

		// Polling ZChecker CCMD handlers by stored netevent name:
		for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {
			if ( !( zcConsoleHandleClasses[ i ] is 'ZCConsoleCommand' ) )
				continue;

			ZCConsoleCommand curCCMD = ZCConsoleCommand( zcConsoleHandleClasses[ i ] );

			if ( ccmdName ~== curCCMD.GetCommand() )
				if ( curCCMD.HandleArguments( zcCCMDInfo ) ) {
					curCCMD.DoCommand();
					break;
				} else {
					ZCGlobal.Log( LL_Normal | LL_NoPrefix, TEXTCOLOR_YELLOW .. "Usage\c-:\n" .. curCCMD.GetHelpString() );
				}
		} // of for ( int i = 0; i < zcConsoleHandleClasses.Size(); i++ ) {

		Super.NetworkProcess( e );
	} // of override void NetworkProcess( ConsoleEvent e ) {


	override void WorldTick() {
		if ( !( level.maptime % 5 ) )
			ZCGlobal.UpdateLogLevel();

		Super.WorldTick();
	} // of override void WorldTick() {

} // of class ZCheckerHandler: EventHandler {
